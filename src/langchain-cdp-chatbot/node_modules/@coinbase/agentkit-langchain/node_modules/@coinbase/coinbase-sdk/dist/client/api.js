"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Coinbase Platform API
 * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.
 *
 * The version of the OpenAPI document: 0.0.1-alpha
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworksApiFp = exports.NetworksApiAxiosParamCreator = exports.MPCWalletStakeApi = exports.MPCWalletStakeApiFactory = exports.MPCWalletStakeApiFp = exports.MPCWalletStakeApiAxiosParamCreator = exports.FundApi = exports.FundApiFactory = exports.FundApiFp = exports.FundApiAxiosParamCreator = exports.ExternalAddressesApi = exports.ExternalAddressesApiFactory = exports.ExternalAddressesApiFp = exports.ExternalAddressesApiAxiosParamCreator = exports.ContractInvocationsApi = exports.ContractInvocationsApiFactory = exports.ContractInvocationsApiFp = exports.ContractInvocationsApiAxiosParamCreator = exports.ContractEventsApi = exports.ContractEventsApiFactory = exports.ContractEventsApiFp = exports.ContractEventsApiAxiosParamCreator = exports.BalanceHistoryApi = exports.BalanceHistoryApiFactory = exports.BalanceHistoryApiFp = exports.BalanceHistoryApiAxiosParamCreator = exports.AssetsApi = exports.AssetsApiFactory = exports.AssetsApiFp = exports.AssetsApiAxiosParamCreator = exports.AddressesApi = exports.AddressesApiFactory = exports.AddressesApiFp = exports.AddressesApiAxiosParamCreator = exports.WebhookEventType = exports.WalletServerSignerStatusEnum = exports.ValidatorStatus = exports.TransactionType = exports.TransactionStatusEnum = exports.TokenTransferType = exports.StakingRewardFormat = exports.StakingRewardStateEnum = exports.StakingOperationStatusEnum = exports.SponsoredSendStatusEnum = exports.SolidityValueTypeEnum = exports.SmartContractType = exports.PayloadSignatureStatusEnum = exports.NetworkIdentifier = exports.NetworkProtocolFamilyEnum = exports.FundOperationStatusEnum = void 0;
exports.WebhooksApi = exports.WebhooksApiFactory = exports.WebhooksApiFp = exports.WebhooksApiAxiosParamCreator = exports.WalletsApi = exports.WalletsApiFactory = exports.WalletsApiFp = exports.WalletsApiAxiosParamCreator = exports.UsersApi = exports.UsersApiFactory = exports.UsersApiFp = exports.UsersApiAxiosParamCreator = exports.TransfersApi = exports.TransfersApiFactory = exports.TransfersApiFp = exports.TransfersApiAxiosParamCreator = exports.TransactionHistoryApi = exports.TransactionHistoryApiFactory = exports.TransactionHistoryApiFp = exports.TransactionHistoryApiAxiosParamCreator = exports.TradesApi = exports.TradesApiFactory = exports.TradesApiFp = exports.TradesApiAxiosParamCreator = exports.StakeApi = exports.StakeApiFactory = exports.StakeApiFp = exports.StakeApiAxiosParamCreator = exports.SmartContractsApi = exports.SmartContractsApiFactory = exports.SmartContractsApiFp = exports.SmartContractsApiAxiosParamCreator = exports.ServerSignersApi = exports.ServerSignersApiFactory = exports.ServerSignersApiFp = exports.ServerSignersApiAxiosParamCreator = exports.ReputationApi = exports.ReputationApiFactory = exports.ReputationApiFp = exports.ReputationApiAxiosParamCreator = exports.ResolveIdentityByAddressRolesEnum = exports.OnchainIdentityApi = exports.OnchainIdentityApiFactory = exports.OnchainIdentityApiFp = exports.OnchainIdentityApiAxiosParamCreator = exports.NetworksApi = exports.NetworksApiFactory = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
exports.FundOperationStatusEnum = {
    Pending: 'pending',
    Complete: 'complete',
    Failed: 'failed'
};
exports.NetworkProtocolFamilyEnum = {
    Evm: 'evm',
    Solana: 'solana'
};
/**
 * The ID of the blockchain network. This is unique across all networks, and takes the form of `<blockchain>-<network>`.
 * @export
 * @enum {string}
 */
exports.NetworkIdentifier = {
    BaseSepolia: 'base-sepolia',
    BaseMainnet: 'base-mainnet',
    EthereumHolesky: 'ethereum-holesky',
    EthereumMainnet: 'ethereum-mainnet',
    PolygonMainnet: 'polygon-mainnet',
    SolanaDevnet: 'solana-devnet',
    SolanaMainnet: 'solana-mainnet',
    ArbitrumMainnet: 'arbitrum-mainnet'
};
exports.PayloadSignatureStatusEnum = {
    Pending: 'pending',
    Signed: 'signed',
    Failed: 'failed'
};
/**
 * The type of the smart contract.
 * @export
 * @enum {string}
 */
exports.SmartContractType = {
    Erc20: 'erc20',
    Erc721: 'erc721',
    Erc1155: 'erc1155',
    Custom: 'custom'
};
exports.SolidityValueTypeEnum = {
    Uint8: 'uint8',
    Uint16: 'uint16',
    Uint32: 'uint32',
    Uint64: 'uint64',
    Uint128: 'uint128',
    Uint160: 'uint160',
    Uint256: 'uint256',
    Int8: 'int8',
    Int16: 'int16',
    Int24: 'int24',
    Int32: 'int32',
    Int56: 'int56',
    Int64: 'int64',
    Int128: 'int128',
    Int256: 'int256',
    Address: 'address',
    Bool: 'bool',
    String: 'string',
    Bytes: 'bytes',
    Bytes1: 'bytes1',
    Bytes2: 'bytes2',
    Bytes3: 'bytes3',
    Bytes4: 'bytes4',
    Bytes5: 'bytes5',
    Bytes6: 'bytes6',
    Bytes7: 'bytes7',
    Bytes8: 'bytes8',
    Bytes9: 'bytes9',
    Bytes10: 'bytes10',
    Bytes11: 'bytes11',
    Bytes12: 'bytes12',
    Bytes13: 'bytes13',
    Bytes14: 'bytes14',
    Bytes15: 'bytes15',
    Bytes16: 'bytes16',
    Bytes17: 'bytes17',
    Bytes18: 'bytes18',
    Bytes19: 'bytes19',
    Bytes20: 'bytes20',
    Bytes21: 'bytes21',
    Bytes22: 'bytes22',
    Bytes23: 'bytes23',
    Bytes24: 'bytes24',
    Bytes25: 'bytes25',
    Bytes26: 'bytes26',
    Bytes27: 'bytes27',
    Bytes28: 'bytes28',
    Bytes29: 'bytes29',
    Bytes30: 'bytes30',
    Bytes31: 'bytes31',
    Bytes32: 'bytes32',
    Array: 'array',
    Tuple: 'tuple'
};
exports.SponsoredSendStatusEnum = {
    Pending: 'pending',
    Signed: 'signed',
    Submitted: 'submitted',
    Complete: 'complete',
    Failed: 'failed'
};
exports.StakingOperationStatusEnum = {
    Initialized: 'initialized',
    Complete: 'complete',
    Failed: 'failed',
    Unspecified: 'unspecified'
};
exports.StakingRewardStateEnum = {
    Pending: 'pending',
    Distributed: 'distributed'
};
/**
 * The format in which the rewards are to be fetched i.e native or in equivalent USD
 * @export
 * @enum {string}
 */
exports.StakingRewardFormat = {
    Usd: 'usd',
    Native: 'native'
};
/**
 * The type of the token transfer.
 * @export
 * @enum {string}
 */
exports.TokenTransferType = {
    Erc20: 'erc20',
    Erc721: 'erc721',
    Erc1155: 'erc1155',
    Unknown: 'unknown'
};
exports.TransactionStatusEnum = {
    Pending: 'pending',
    Signed: 'signed',
    Broadcast: 'broadcast',
    Complete: 'complete',
    Failed: 'failed',
    Unspecified: 'unspecified'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.TransactionType = {
    Transfer: 'transfer'
};
/**
 * The status of the validator.
 * @export
 * @enum {string}
 */
exports.ValidatorStatus = {
    Unknown: 'unknown',
    Provisioning: 'provisioning',
    Provisioned: 'provisioned',
    Deposited: 'deposited',
    PendingActivation: 'pending_activation',
    Active: 'active',
    Exiting: 'exiting',
    Exited: 'exited',
    WithdrawalAvailable: 'withdrawal_available',
    WithdrawalComplete: 'withdrawal_complete',
    ActiveSlashed: 'active_slashed',
    ExitedSlashed: 'exited_slashed',
    Reaped: 'reaped'
};
exports.WalletServerSignerStatusEnum = {
    PendingSeedCreation: 'pending_seed_creation',
    ActiveSeed: 'active_seed'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.WebhookEventType = {
    Unspecified: 'unspecified',
    Erc20Transfer: 'erc20_transfer',
    Erc721Transfer: 'erc721_transfer',
    WalletActivity: 'wallet_activity',
    SmartContractEventActivity: 'smart_contract_event_activity'
};
/**
 * AddressesApi - axios parameter creator
 * @export
 */
const AddressesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new address scoped to the wallet.
         * @summary Create a new address
         * @param {string} walletId The ID of the wallet to create the address in.
         * @param {CreateAddressRequest} [createAddressRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddress: async (walletId, createAddressRequest, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('createAddress', 'walletId', walletId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createAddressRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new payload signature with an address.
         * @summary Create a new payload signature.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address to sign the payload with.
         * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayloadSignature: async (walletId, addressId, createPayloadSignatureRequest, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('createPayloadSignature', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('createPayloadSignature', 'addressId', addressId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/payload_signatures`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createPayloadSignatureRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get address
         * @summary Get address by onchain address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddress: async (walletId, addressId, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('getAddress', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('getAddress', 'addressId', addressId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get address balance
         * @summary Get address balance for asset
         * @param {string} walletId The ID of the wallet to fetch the balance for
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} assetId The symbol of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressBalance: async (walletId, addressId, assetId, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('getAddressBalance', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('getAddressBalance', 'addressId', addressId);
            // verify required parameter 'assetId' is not null or undefined
            (0, common_1.assertParamExists)('getAddressBalance', 'assetId', assetId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/balances/{asset_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get payload signature.
         * @summary Get payload signature.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that signed the payload.
         * @param {string} payloadSignatureId The ID of the payload signature to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayloadSignature: async (walletId, addressId, payloadSignatureId, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('getPayloadSignature', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('getPayloadSignature', 'addressId', addressId);
            // verify required parameter 'payloadSignatureId' is not null or undefined
            (0, common_1.assertParamExists)('getPayloadSignature', 'payloadSignatureId', payloadSignatureId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/payload_signatures/{payload_signature_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"payload_signature_id"}}`, encodeURIComponent(String(payloadSignatureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get address balances
         * @summary Get all balances for address
         * @param {string} walletId The ID of the wallet to fetch the balances for
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressBalances: async (walletId, addressId, page, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('listAddressBalances', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('listAddressBalances', 'addressId', addressId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/balances`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List addresses in the wallet.
         * @summary List addresses in a wallet.
         * @param {string} walletId The ID of the wallet whose addresses to fetch
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddresses: async (walletId, limit, page, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('listAddresses', 'walletId', walletId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List payload signatures for an address.
         * @summary List payload signatures for an address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address whose payload signatures to fetch.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayloadSignatures: async (walletId, addressId, limit, page, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('listPayloadSignatures', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('listPayloadSignatures', 'addressId', addressId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/payload_signatures`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request faucet funds to be sent to onchain address.
         * @summary Request faucet funds for onchain address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [assetId] The ID of the asset to transfer from the faucet.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        requestFaucetFunds: async (walletId, addressId, assetId, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('requestFaucetFunds', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('requestFaucetFunds', 'addressId', addressId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/faucet`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AddressesApiAxiosParamCreator = AddressesApiAxiosParamCreator;
/**
 * AddressesApi - functional programming interface
 * @export
 */
const AddressesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AddressesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a new address scoped to the wallet.
         * @summary Create a new address
         * @param {string} walletId The ID of the wallet to create the address in.
         * @param {CreateAddressRequest} [createAddressRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAddress(walletId, createAddressRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAddress(walletId, createAddressRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.createAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new payload signature with an address.
         * @summary Create a new payload signature.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address to sign the payload with.
         * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.createPayloadSignature']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get address
         * @summary Get address by onchain address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddress(walletId, addressId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddress(walletId, addressId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.getAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get address balance
         * @summary Get address balance for asset
         * @param {string} walletId The ID of the wallet to fetch the balance for
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} assetId The symbol of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressBalance(walletId, addressId, assetId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressBalance(walletId, addressId, assetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.getAddressBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get payload signature.
         * @summary Get payload signature.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that signed the payload.
         * @param {string} payloadSignatureId The ID of the payload signature to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayloadSignature(walletId, addressId, payloadSignatureId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayloadSignature(walletId, addressId, payloadSignatureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.getPayloadSignature']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get address balances
         * @summary Get all balances for address
         * @param {string} walletId The ID of the wallet to fetch the balances for
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAddressBalances(walletId, addressId, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressBalances(walletId, addressId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.listAddressBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List addresses in the wallet.
         * @summary List addresses in a wallet.
         * @param {string} walletId The ID of the wallet whose addresses to fetch
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAddresses(walletId, limit, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddresses(walletId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.listAddresses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List payload signatures for an address.
         * @summary List payload signatures for an address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address whose payload signatures to fetch.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPayloadSignatures(walletId, addressId, limit, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPayloadSignatures(walletId, addressId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.listPayloadSignatures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request faucet funds to be sent to onchain address.
         * @summary Request faucet funds for onchain address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [assetId] The ID of the asset to transfer from the faucet.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async requestFaucetFunds(walletId, addressId, assetId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestFaucetFunds(walletId, addressId, assetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.requestFaucetFunds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AddressesApiFp = AddressesApiFp;
/**
 * AddressesApi - factory interface
 * @export
 */
const AddressesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AddressesApiFp)(configuration);
    return {
        /**
         * Create a new address scoped to the wallet.
         * @summary Create a new address
         * @param {string} walletId The ID of the wallet to create the address in.
         * @param {CreateAddressRequest} [createAddressRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddress(walletId, createAddressRequest, options) {
            return localVarFp.createAddress(walletId, createAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new payload signature with an address.
         * @summary Create a new payload signature.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address to sign the payload with.
         * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options) {
            return localVarFp.createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get address
         * @summary Get address by onchain address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddress(walletId, addressId, options) {
            return localVarFp.getAddress(walletId, addressId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get address balance
         * @summary Get address balance for asset
         * @param {string} walletId The ID of the wallet to fetch the balance for
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} assetId The symbol of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressBalance(walletId, addressId, assetId, options) {
            return localVarFp.getAddressBalance(walletId, addressId, assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get payload signature.
         * @summary Get payload signature.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that signed the payload.
         * @param {string} payloadSignatureId The ID of the payload signature to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayloadSignature(walletId, addressId, payloadSignatureId, options) {
            return localVarFp.getPayloadSignature(walletId, addressId, payloadSignatureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get address balances
         * @summary Get all balances for address
         * @param {string} walletId The ID of the wallet to fetch the balances for
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressBalances(walletId, addressId, page, options) {
            return localVarFp.listAddressBalances(walletId, addressId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List addresses in the wallet.
         * @summary List addresses in a wallet.
         * @param {string} walletId The ID of the wallet whose addresses to fetch
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddresses(walletId, limit, page, options) {
            return localVarFp.listAddresses(walletId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List payload signatures for an address.
         * @summary List payload signatures for an address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address whose payload signatures to fetch.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayloadSignatures(walletId, addressId, limit, page, options) {
            return localVarFp.listPayloadSignatures(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Request faucet funds to be sent to onchain address.
         * @summary Request faucet funds for onchain address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [assetId] The ID of the asset to transfer from the faucet.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        requestFaucetFunds(walletId, addressId, assetId, options) {
            return localVarFp.requestFaucetFunds(walletId, addressId, assetId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AddressesApiFactory = AddressesApiFactory;
/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
class AddressesApi extends base_1.BaseAPI {
    /**
     * Create a new address scoped to the wallet.
     * @summary Create a new address
     * @param {string} walletId The ID of the wallet to create the address in.
     * @param {CreateAddressRequest} [createAddressRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    createAddress(walletId, createAddressRequest, options) {
        return (0, exports.AddressesApiFp)(this.configuration).createAddress(walletId, createAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new payload signature with an address.
     * @summary Create a new payload signature.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address to sign the payload with.
     * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options) {
        return (0, exports.AddressesApiFp)(this.configuration).createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get address
     * @summary Get address by onchain address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    getAddress(walletId, addressId, options) {
        return (0, exports.AddressesApiFp)(this.configuration).getAddress(walletId, addressId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get address balance
     * @summary Get address balance for asset
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    getAddressBalance(walletId, addressId, assetId, options) {
        return (0, exports.AddressesApiFp)(this.configuration).getAddressBalance(walletId, addressId, assetId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get payload signature.
     * @summary Get payload signature.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that signed the payload.
     * @param {string} payloadSignatureId The ID of the payload signature to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    getPayloadSignature(walletId, addressId, payloadSignatureId, options) {
        return (0, exports.AddressesApiFp)(this.configuration).getPayloadSignature(walletId, addressId, payloadSignatureId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get address balances
     * @summary Get all balances for address
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    listAddressBalances(walletId, addressId, page, options) {
        return (0, exports.AddressesApiFp)(this.configuration).listAddressBalances(walletId, addressId, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List addresses in the wallet.
     * @summary List addresses in a wallet.
     * @param {string} walletId The ID of the wallet whose addresses to fetch
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    listAddresses(walletId, limit, page, options) {
        return (0, exports.AddressesApiFp)(this.configuration).listAddresses(walletId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List payload signatures for an address.
     * @summary List payload signatures for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address whose payload signatures to fetch.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    listPayloadSignatures(walletId, addressId, limit, page, options) {
        return (0, exports.AddressesApiFp)(this.configuration).listPayloadSignatures(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Request faucet funds to be sent to onchain address.
     * @summary Request faucet funds for onchain address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [assetId] The ID of the asset to transfer from the faucet.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    requestFaucetFunds(walletId, addressId, assetId, options) {
        return (0, exports.AddressesApiFp)(this.configuration).requestFaucetFunds(walletId, addressId, assetId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AddressesApi = AddressesApi;
/**
 * AssetsApi - axios parameter creator
 * @export
 */
const AssetsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get the asset for the specified asset ID.
         * @summary Get the asset for the specified asset ID.
         * @param {string} networkId The ID of the blockchain network
         * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset: async (networkId, assetId, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('getAsset', 'networkId', networkId);
            // verify required parameter 'assetId' is not null or undefined
            (0, common_1.assertParamExists)('getAsset', 'assetId', assetId);
            const localVarPath = `/v1/networks/{network_id}/assets/{asset_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AssetsApiAxiosParamCreator = AssetsApiAxiosParamCreator;
/**
 * AssetsApi - functional programming interface
 * @export
 */
const AssetsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AssetsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get the asset for the specified asset ID.
         * @summary Get the asset for the specified asset ID.
         * @param {string} networkId The ID of the blockchain network
         * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAsset(networkId, assetId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAsset(networkId, assetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AssetsApi.getAsset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AssetsApiFp = AssetsApiFp;
/**
 * AssetsApi - factory interface
 * @export
 */
const AssetsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AssetsApiFp)(configuration);
    return {
        /**
         * Get the asset for the specified asset ID.
         * @summary Get the asset for the specified asset ID.
         * @param {string} networkId The ID of the blockchain network
         * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset(networkId, assetId, options) {
            return localVarFp.getAsset(networkId, assetId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AssetsApiFactory = AssetsApiFactory;
/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
class AssetsApi extends base_1.BaseAPI {
    /**
     * Get the asset for the specified asset ID.
     * @summary Get the asset for the specified asset ID.
     * @param {string} networkId The ID of the blockchain network
     * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    getAsset(networkId, assetId, options) {
        return (0, exports.AssetsApiFp)(this.configuration).getAsset(networkId, assetId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AssetsApi = AssetsApi;
/**
 * BalanceHistoryApi - axios parameter creator
 * @export
 */
const BalanceHistoryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List the historical balance of an asset in a specific address.
         * @summary Get address balance history for asset
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the historical balance for.
         * @param {string} assetId The symbol of the asset to fetch the historical balance for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressHistoricalBalance: async (networkId, addressId, assetId, limit, page, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('listAddressHistoricalBalance', 'networkId', networkId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('listAddressHistoricalBalance', 'addressId', addressId);
            // verify required parameter 'assetId' is not null or undefined
            (0, common_1.assertParamExists)('listAddressHistoricalBalance', 'assetId', assetId);
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/balance_history/{asset_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.BalanceHistoryApiAxiosParamCreator = BalanceHistoryApiAxiosParamCreator;
/**
 * BalanceHistoryApi - functional programming interface
 * @export
 */
const BalanceHistoryApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.BalanceHistoryApiAxiosParamCreator)(configuration);
    return {
        /**
         * List the historical balance of an asset in a specific address.
         * @summary Get address balance history for asset
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the historical balance for.
         * @param {string} assetId The symbol of the asset to fetch the historical balance for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['BalanceHistoryApi.listAddressHistoricalBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.BalanceHistoryApiFp = BalanceHistoryApiFp;
/**
 * BalanceHistoryApi - factory interface
 * @export
 */
const BalanceHistoryApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.BalanceHistoryApiFp)(configuration);
    return {
        /**
         * List the historical balance of an asset in a specific address.
         * @summary Get address balance history for asset
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the historical balance for.
         * @param {string} assetId The symbol of the asset to fetch the historical balance for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options) {
            return localVarFp.listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};
exports.BalanceHistoryApiFactory = BalanceHistoryApiFactory;
/**
 * BalanceHistoryApi - object-oriented interface
 * @export
 * @class BalanceHistoryApi
 * @extends {BaseAPI}
 */
class BalanceHistoryApi extends base_1.BaseAPI {
    /**
     * List the historical balance of an asset in a specific address.
     * @summary Get address balance history for asset
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the historical balance for.
     * @param {string} assetId The symbol of the asset to fetch the historical balance for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceHistoryApi
     */
    listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options) {
        return (0, exports.BalanceHistoryApiFp)(this.configuration).listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BalanceHistoryApi = BalanceHistoryApi;
/**
 * ContractEventsApi - axios parameter creator
 * @export
 */
const ContractEventsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve events for a specific contract
         * @summary List contract events
         * @param {string} networkId Unique identifier for the blockchain network
         * @param {string} protocolName Case-sensitive name of the blockchain protocol
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {string} contractName Case-sensitive name of the specific contract within the project
         * @param {string} eventName Case-sensitive name of the event to filter for in the contract\&#39;s logs
         * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
         * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
         * @param {string} [nextPage] Pagination token for retrieving the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContractEvents: async (networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('listContractEvents', 'networkId', networkId);
            // verify required parameter 'protocolName' is not null or undefined
            (0, common_1.assertParamExists)('listContractEvents', 'protocolName', protocolName);
            // verify required parameter 'contractAddress' is not null or undefined
            (0, common_1.assertParamExists)('listContractEvents', 'contractAddress', contractAddress);
            // verify required parameter 'contractName' is not null or undefined
            (0, common_1.assertParamExists)('listContractEvents', 'contractName', contractName);
            // verify required parameter 'eventName' is not null or undefined
            (0, common_1.assertParamExists)('listContractEvents', 'eventName', eventName);
            // verify required parameter 'fromBlockHeight' is not null or undefined
            (0, common_1.assertParamExists)('listContractEvents', 'fromBlockHeight', fromBlockHeight);
            // verify required parameter 'toBlockHeight' is not null or undefined
            (0, common_1.assertParamExists)('listContractEvents', 'toBlockHeight', toBlockHeight);
            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}/events`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (protocolName !== undefined) {
                localVarQueryParameter['protocol_name'] = protocolName;
            }
            if (contractName !== undefined) {
                localVarQueryParameter['contract_name'] = contractName;
            }
            if (eventName !== undefined) {
                localVarQueryParameter['event_name'] = eventName;
            }
            if (fromBlockHeight !== undefined) {
                localVarQueryParameter['from_block_height'] = fromBlockHeight;
            }
            if (toBlockHeight !== undefined) {
                localVarQueryParameter['to_block_height'] = toBlockHeight;
            }
            if (nextPage !== undefined) {
                localVarQueryParameter['next_page'] = nextPage;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ContractEventsApiAxiosParamCreator = ContractEventsApiAxiosParamCreator;
/**
 * ContractEventsApi - functional programming interface
 * @export
 */
const ContractEventsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ContractEventsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieve events for a specific contract
         * @summary List contract events
         * @param {string} networkId Unique identifier for the blockchain network
         * @param {string} protocolName Case-sensitive name of the blockchain protocol
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {string} contractName Case-sensitive name of the specific contract within the project
         * @param {string} eventName Case-sensitive name of the event to filter for in the contract\&#39;s logs
         * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
         * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
         * @param {string} [nextPage] Pagination token for retrieving the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ContractEventsApi.listContractEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.ContractEventsApiFp = ContractEventsApiFp;
/**
 * ContractEventsApi - factory interface
 * @export
 */
const ContractEventsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ContractEventsApiFp)(configuration);
    return {
        /**
         * Retrieve events for a specific contract
         * @summary List contract events
         * @param {string} networkId Unique identifier for the blockchain network
         * @param {string} protocolName Case-sensitive name of the blockchain protocol
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {string} contractName Case-sensitive name of the specific contract within the project
         * @param {string} eventName Case-sensitive name of the event to filter for in the contract\&#39;s logs
         * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
         * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
         * @param {string} [nextPage] Pagination token for retrieving the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options) {
            return localVarFp.listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ContractEventsApiFactory = ContractEventsApiFactory;
/**
 * ContractEventsApi - object-oriented interface
 * @export
 * @class ContractEventsApi
 * @extends {BaseAPI}
 */
class ContractEventsApi extends base_1.BaseAPI {
    /**
     * Retrieve events for a specific contract
     * @summary List contract events
     * @param {string} networkId Unique identifier for the blockchain network
     * @param {string} protocolName Case-sensitive name of the blockchain protocol
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {string} contractName Case-sensitive name of the specific contract within the project
     * @param {string} eventName Case-sensitive name of the event to filter for in the contract\&#39;s logs
     * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
     * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
     * @param {string} [nextPage] Pagination token for retrieving the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractEventsApi
     */
    listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options) {
        return (0, exports.ContractEventsApiFp)(this.configuration).listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ContractEventsApi = ContractEventsApi;
/**
 * ContractInvocationsApi - axios parameter creator
 * @export
 */
const ContractInvocationsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Broadcast a contract invocation.
         * @summary Broadcast a contract invocation.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the contract invocation belongs to.
         * @param {string} contractInvocationId The ID of the contract invocation to broadcast.
         * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastContractInvocation: async (walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('broadcastContractInvocation', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('broadcastContractInvocation', 'addressId', addressId);
            // verify required parameter 'contractInvocationId' is not null or undefined
            (0, common_1.assertParamExists)('broadcastContractInvocation', 'contractInvocationId', contractInvocationId);
            // verify required parameter 'broadcastContractInvocationRequest' is not null or undefined
            (0, common_1.assertParamExists)('broadcastContractInvocation', 'broadcastContractInvocationRequest', broadcastContractInvocationRequest);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations/{contract_invocation_id}/broadcast`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"contract_invocation_id"}}`, encodeURIComponent(String(contractInvocationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastContractInvocationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new contract invocation.
         * @summary Create a new contract invocation for an address.
         * @param {string} walletId The ID of the wallet the source address belongs to.
         * @param {string} addressId The ID of the address to invoke the contract from.
         * @param {CreateContractInvocationRequest} createContractInvocationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContractInvocation: async (walletId, addressId, createContractInvocationRequest, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('createContractInvocation', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('createContractInvocation', 'addressId', addressId);
            // verify required parameter 'createContractInvocationRequest' is not null or undefined
            (0, common_1.assertParamExists)('createContractInvocation', 'createContractInvocationRequest', createContractInvocationRequest);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createContractInvocationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a contract invocation by ID.
         * @summary Get a contract invocation by ID.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the contract invocation belongs to.
         * @param {string} contractInvocationId The ID of the contract invocation to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractInvocation: async (walletId, addressId, contractInvocationId, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('getContractInvocation', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('getContractInvocation', 'addressId', addressId);
            // verify required parameter 'contractInvocationId' is not null or undefined
            (0, common_1.assertParamExists)('getContractInvocation', 'contractInvocationId', contractInvocationId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations/{contract_invocation_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"contract_invocation_id"}}`, encodeURIComponent(String(contractInvocationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List contract invocations for an address.
         * @summary List contract invocations for an address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to list contract invocations for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContractInvocations: async (walletId, addressId, limit, page, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('listContractInvocations', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('listContractInvocations', 'addressId', addressId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ContractInvocationsApiAxiosParamCreator = ContractInvocationsApiAxiosParamCreator;
/**
 * ContractInvocationsApi - functional programming interface
 * @export
 */
const ContractInvocationsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ContractInvocationsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Broadcast a contract invocation.
         * @summary Broadcast a contract invocation.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the contract invocation belongs to.
         * @param {string} contractInvocationId The ID of the contract invocation to broadcast.
         * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ContractInvocationsApi.broadcastContractInvocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new contract invocation.
         * @summary Create a new contract invocation for an address.
         * @param {string} walletId The ID of the wallet the source address belongs to.
         * @param {string} addressId The ID of the address to invoke the contract from.
         * @param {CreateContractInvocationRequest} createContractInvocationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContractInvocation(walletId, addressId, createContractInvocationRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContractInvocation(walletId, addressId, createContractInvocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ContractInvocationsApi.createContractInvocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a contract invocation by ID.
         * @summary Get a contract invocation by ID.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the contract invocation belongs to.
         * @param {string} contractInvocationId The ID of the contract invocation to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractInvocation(walletId, addressId, contractInvocationId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractInvocation(walletId, addressId, contractInvocationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ContractInvocationsApi.getContractInvocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List contract invocations for an address.
         * @summary List contract invocations for an address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to list contract invocations for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContractInvocations(walletId, addressId, limit, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContractInvocations(walletId, addressId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ContractInvocationsApi.listContractInvocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.ContractInvocationsApiFp = ContractInvocationsApiFp;
/**
 * ContractInvocationsApi - factory interface
 * @export
 */
const ContractInvocationsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ContractInvocationsApiFp)(configuration);
    return {
        /**
         * Broadcast a contract invocation.
         * @summary Broadcast a contract invocation.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the contract invocation belongs to.
         * @param {string} contractInvocationId The ID of the contract invocation to broadcast.
         * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options) {
            return localVarFp.broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new contract invocation.
         * @summary Create a new contract invocation for an address.
         * @param {string} walletId The ID of the wallet the source address belongs to.
         * @param {string} addressId The ID of the address to invoke the contract from.
         * @param {CreateContractInvocationRequest} createContractInvocationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContractInvocation(walletId, addressId, createContractInvocationRequest, options) {
            return localVarFp.createContractInvocation(walletId, addressId, createContractInvocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a contract invocation by ID.
         * @summary Get a contract invocation by ID.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the contract invocation belongs to.
         * @param {string} contractInvocationId The ID of the contract invocation to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractInvocation(walletId, addressId, contractInvocationId, options) {
            return localVarFp.getContractInvocation(walletId, addressId, contractInvocationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List contract invocations for an address.
         * @summary List contract invocations for an address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to list contract invocations for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContractInvocations(walletId, addressId, limit, page, options) {
            return localVarFp.listContractInvocations(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ContractInvocationsApiFactory = ContractInvocationsApiFactory;
/**
 * ContractInvocationsApi - object-oriented interface
 * @export
 * @class ContractInvocationsApi
 * @extends {BaseAPI}
 */
class ContractInvocationsApi extends base_1.BaseAPI {
    /**
     * Broadcast a contract invocation.
     * @summary Broadcast a contract invocation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the contract invocation belongs to.
     * @param {string} contractInvocationId The ID of the contract invocation to broadcast.
     * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApi
     */
    broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options) {
        return (0, exports.ContractInvocationsApiFp)(this.configuration).broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new contract invocation.
     * @summary Create a new contract invocation for an address.
     * @param {string} walletId The ID of the wallet the source address belongs to.
     * @param {string} addressId The ID of the address to invoke the contract from.
     * @param {CreateContractInvocationRequest} createContractInvocationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApi
     */
    createContractInvocation(walletId, addressId, createContractInvocationRequest, options) {
        return (0, exports.ContractInvocationsApiFp)(this.configuration).createContractInvocation(walletId, addressId, createContractInvocationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a contract invocation by ID.
     * @summary Get a contract invocation by ID.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the contract invocation belongs to.
     * @param {string} contractInvocationId The ID of the contract invocation to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApi
     */
    getContractInvocation(walletId, addressId, contractInvocationId, options) {
        return (0, exports.ContractInvocationsApiFp)(this.configuration).getContractInvocation(walletId, addressId, contractInvocationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List contract invocations for an address.
     * @summary List contract invocations for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to list contract invocations for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApi
     */
    listContractInvocations(walletId, addressId, limit, page, options) {
        return (0, exports.ContractInvocationsApiFp)(this.configuration).listContractInvocations(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ContractInvocationsApi = ContractInvocationsApi;
/**
 * ExternalAddressesApi - axios parameter creator
 * @export
 */
const ExternalAddressesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Broadcast an external address\'s transfer with a signed payload
         * @summary Broadcast an external address\' transfer
         * @param {string} networkId The ID of the network the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to broadcast
         * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastExternalTransfer: async (networkId, addressId, transferId, broadcastExternalTransferRequest, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('broadcastExternalTransfer', 'networkId', networkId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('broadcastExternalTransfer', 'addressId', addressId);
            // verify required parameter 'transferId' is not null or undefined
            (0, common_1.assertParamExists)('broadcastExternalTransfer', 'transferId', transferId);
            // verify required parameter 'broadcastExternalTransferRequest' is not null or undefined
            (0, common_1.assertParamExists)('broadcastExternalTransfer', 'broadcastExternalTransferRequest', broadcastExternalTransferRequest);
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transfers/{transfer_id}/broadcast`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"transfer_id"}}`, encodeURIComponent(String(transferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastExternalTransferRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new transfer between addresses.
         * @summary Create a new transfer
         * @param {string} networkId The ID of the network the address is on
         * @param {string} addressId The ID of the address to transfer from
         * @param {CreateExternalTransferRequest} createExternalTransferRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalTransfer: async (networkId, addressId, createExternalTransferRequest, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('createExternalTransfer', 'networkId', networkId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('createExternalTransfer', 'addressId', addressId);
            // verify required parameter 'createExternalTransferRequest' is not null or undefined
            (0, common_1.assertParamExists)('createExternalTransfer', 'createExternalTransferRequest', createExternalTransferRequest);
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transfers`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createExternalTransferRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the balance of an asset in an external address
         * @summary Get the balance of an asset in an external address
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the balance for
         * @param {string} assetId The ID of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalAddressBalance: async (networkId, addressId, assetId, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('getExternalAddressBalance', 'networkId', networkId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('getExternalAddressBalance', 'addressId', addressId);
            // verify required parameter 'assetId' is not null or undefined
            (0, common_1.assertParamExists)('getExternalAddressBalance', 'assetId', assetId);
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/balances/{asset_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an external address\' transfer by ID
         * @summary Get a external address\' transfer
         * @param {string} networkId The ID of the network the address is on
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTransfer: async (networkId, addressId, transferId, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('getExternalTransfer', 'networkId', networkId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('getExternalTransfer', 'addressId', addressId);
            // verify required parameter 'transferId' is not null or undefined
            (0, common_1.assertParamExists)('getExternalTransfer', 'transferId', transferId);
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transfers/{transfer_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"transfer_id"}}`, encodeURIComponent(String(transferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of a faucet transaction
         * @summary Get the status of a faucet transaction
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the faucet transaction for
         * @param {string} txHash The hash of the faucet transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaucetTransaction: async (networkId, addressId, txHash, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('getFaucetTransaction', 'networkId', networkId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('getFaucetTransaction', 'addressId', addressId);
            // verify required parameter 'txHash' is not null or undefined
            (0, common_1.assertParamExists)('getFaucetTransaction', 'txHash', txHash);
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/faucet/{tx_hash}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"tx_hash"}}`, encodeURIComponent(String(txHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of the balances of an external address
         * @summary Get the balances of an external address
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the balance for
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExternalAddressBalances: async (networkId, addressId, page, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('listExternalAddressBalances', 'networkId', networkId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('listExternalAddressBalances', 'addressId', addressId);
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/balances`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request faucet funds to be sent to external address.
         * @summary Request faucet funds for external address.
         * @param {string} networkId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [assetId] The ID of the asset to transfer from the faucet.
         * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestExternalFaucetFunds: async (networkId, addressId, assetId, skipWait, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('requestExternalFaucetFunds', 'networkId', networkId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('requestExternalFaucetFunds', 'addressId', addressId);
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/faucet`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }
            if (skipWait !== undefined) {
                localVarQueryParameter['skip_wait'] = skipWait;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ExternalAddressesApiAxiosParamCreator = ExternalAddressesApiAxiosParamCreator;
/**
 * ExternalAddressesApi - functional programming interface
 * @export
 */
const ExternalAddressesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ExternalAddressesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Broadcast an external address\'s transfer with a signed payload
         * @summary Broadcast an external address\' transfer
         * @param {string} networkId The ID of the network the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to broadcast
         * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.broadcastExternalTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new transfer between addresses.
         * @summary Create a new transfer
         * @param {string} networkId The ID of the network the address is on
         * @param {string} addressId The ID of the address to transfer from
         * @param {CreateExternalTransferRequest} createExternalTransferRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExternalTransfer(networkId, addressId, createExternalTransferRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExternalTransfer(networkId, addressId, createExternalTransferRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.createExternalTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the balance of an asset in an external address
         * @summary Get the balance of an asset in an external address
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the balance for
         * @param {string} assetId The ID of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalAddressBalance(networkId, addressId, assetId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalAddressBalance(networkId, addressId, assetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.getExternalAddressBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an external address\' transfer by ID
         * @summary Get a external address\' transfer
         * @param {string} networkId The ID of the network the address is on
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalTransfer(networkId, addressId, transferId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalTransfer(networkId, addressId, transferId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.getExternalTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the status of a faucet transaction
         * @summary Get the status of a faucet transaction
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the faucet transaction for
         * @param {string} txHash The hash of the faucet transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFaucetTransaction(networkId, addressId, txHash, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFaucetTransaction(networkId, addressId, txHash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.getFaucetTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all of the balances of an external address
         * @summary Get the balances of an external address
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the balance for
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExternalAddressBalances(networkId, addressId, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExternalAddressBalances(networkId, addressId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.listExternalAddressBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request faucet funds to be sent to external address.
         * @summary Request faucet funds for external address.
         * @param {string} networkId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [assetId] The ID of the asset to transfer from the faucet.
         * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.requestExternalFaucetFunds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.ExternalAddressesApiFp = ExternalAddressesApiFp;
/**
 * ExternalAddressesApi - factory interface
 * @export
 */
const ExternalAddressesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ExternalAddressesApiFp)(configuration);
    return {
        /**
         * Broadcast an external address\'s transfer with a signed payload
         * @summary Broadcast an external address\' transfer
         * @param {string} networkId The ID of the network the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to broadcast
         * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options) {
            return localVarFp.broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new transfer between addresses.
         * @summary Create a new transfer
         * @param {string} networkId The ID of the network the address is on
         * @param {string} addressId The ID of the address to transfer from
         * @param {CreateExternalTransferRequest} createExternalTransferRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalTransfer(networkId, addressId, createExternalTransferRequest, options) {
            return localVarFp.createExternalTransfer(networkId, addressId, createExternalTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the balance of an asset in an external address
         * @summary Get the balance of an asset in an external address
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the balance for
         * @param {string} assetId The ID of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalAddressBalance(networkId, addressId, assetId, options) {
            return localVarFp.getExternalAddressBalance(networkId, addressId, assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an external address\' transfer by ID
         * @summary Get a external address\' transfer
         * @param {string} networkId The ID of the network the address is on
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTransfer(networkId, addressId, transferId, options) {
            return localVarFp.getExternalTransfer(networkId, addressId, transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of a faucet transaction
         * @summary Get the status of a faucet transaction
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the faucet transaction for
         * @param {string} txHash The hash of the faucet transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaucetTransaction(networkId, addressId, txHash, options) {
            return localVarFp.getFaucetTransaction(networkId, addressId, txHash, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the balances of an external address
         * @summary Get the balances of an external address
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the balance for
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExternalAddressBalances(networkId, addressId, page, options) {
            return localVarFp.listExternalAddressBalances(networkId, addressId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Request faucet funds to be sent to external address.
         * @summary Request faucet funds for external address.
         * @param {string} networkId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that is being fetched.
         * @param {string} [assetId] The ID of the asset to transfer from the faucet.
         * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options) {
            return localVarFp.requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ExternalAddressesApiFactory = ExternalAddressesApiFactory;
/**
 * ExternalAddressesApi - object-oriented interface
 * @export
 * @class ExternalAddressesApi
 * @extends {BaseAPI}
 */
class ExternalAddressesApi extends base_1.BaseAPI {
    /**
     * Broadcast an external address\'s transfer with a signed payload
     * @summary Broadcast an external address\' transfer
     * @param {string} networkId The ID of the network the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options) {
        return (0, exports.ExternalAddressesApiFp)(this.configuration).broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new transfer between addresses.
     * @summary Create a new transfer
     * @param {string} networkId The ID of the network the address is on
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateExternalTransferRequest} createExternalTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    createExternalTransfer(networkId, addressId, createExternalTransferRequest, options) {
        return (0, exports.ExternalAddressesApiFp)(this.configuration).createExternalTransfer(networkId, addressId, createExternalTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the balance of an asset in an external address
     * @summary Get the balance of an asset in an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} assetId The ID of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    getExternalAddressBalance(networkId, addressId, assetId, options) {
        return (0, exports.ExternalAddressesApiFp)(this.configuration).getExternalAddressBalance(networkId, addressId, assetId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an external address\' transfer by ID
     * @summary Get a external address\' transfer
     * @param {string} networkId The ID of the network the address is on
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    getExternalTransfer(networkId, addressId, transferId, options) {
        return (0, exports.ExternalAddressesApiFp)(this.configuration).getExternalTransfer(networkId, addressId, transferId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the status of a faucet transaction
     * @summary Get the status of a faucet transaction
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the faucet transaction for
     * @param {string} txHash The hash of the faucet transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    getFaucetTransaction(networkId, addressId, txHash, options) {
        return (0, exports.ExternalAddressesApiFp)(this.configuration).getFaucetTransaction(networkId, addressId, txHash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all of the balances of an external address
     * @summary Get the balances of an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    listExternalAddressBalances(networkId, addressId, page, options) {
        return (0, exports.ExternalAddressesApiFp)(this.configuration).listExternalAddressBalances(networkId, addressId, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Request faucet funds to be sent to external address.
     * @summary Request faucet funds for external address.
     * @param {string} networkId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [assetId] The ID of the asset to transfer from the faucet.
     * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options) {
        return (0, exports.ExternalAddressesApiFp)(this.configuration).requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ExternalAddressesApi = ExternalAddressesApi;
/**
 * FundApi - axios parameter creator
 * @export
 */
const FundApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new fund operation with an address.
         * @summary Create a new fund operation.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address to be funded.
         * @param {CreateFundOperationRequest} createFundOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFundOperation: async (walletId, addressId, createFundOperationRequest, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('createFundOperation', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('createFundOperation', 'addressId', addressId);
            // verify required parameter 'createFundOperationRequest' is not null or undefined
            (0, common_1.assertParamExists)('createFundOperation', 'createFundOperationRequest', createFundOperationRequest);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createFundOperationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new fund operation with an address.
         * @summary Create a Fund Operation quote.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address to be funded.
         * @param {CreateFundQuoteRequest} createFundQuoteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFundQuote: async (walletId, addressId, createFundQuoteRequest, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('createFundQuote', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('createFundQuote', 'addressId', addressId);
            // verify required parameter 'createFundQuoteRequest' is not null or undefined
            (0, common_1.assertParamExists)('createFundQuote', 'createFundQuoteRequest', createFundQuoteRequest);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations/quote`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createFundQuoteRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get fund operation.
         * @summary Get fund operation.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that created the fund operation.
         * @param {string} fundOperationId The ID of the fund operation to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundOperation: async (walletId, addressId, fundOperationId, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('getFundOperation', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('getFundOperation', 'addressId', addressId);
            // verify required parameter 'fundOperationId' is not null or undefined
            (0, common_1.assertParamExists)('getFundOperation', 'fundOperationId', fundOperationId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations/{fund_operation_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"fund_operation_id"}}`, encodeURIComponent(String(fundOperationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List fund operations for an address.
         * @summary List fund operations for an address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address to list fund operations for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFundOperations: async (walletId, addressId, limit, page, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('listFundOperations', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('listFundOperations', 'addressId', addressId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.FundApiAxiosParamCreator = FundApiAxiosParamCreator;
/**
 * FundApi - functional programming interface
 * @export
 */
const FundApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FundApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a new fund operation with an address.
         * @summary Create a new fund operation.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address to be funded.
         * @param {CreateFundOperationRequest} createFundOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFundOperation(walletId, addressId, createFundOperationRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFundOperation(walletId, addressId, createFundOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['FundApi.createFundOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new fund operation with an address.
         * @summary Create a Fund Operation quote.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address to be funded.
         * @param {CreateFundQuoteRequest} createFundQuoteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFundQuote(walletId, addressId, createFundQuoteRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFundQuote(walletId, addressId, createFundQuoteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['FundApi.createFundQuote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get fund operation.
         * @summary Get fund operation.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that created the fund operation.
         * @param {string} fundOperationId The ID of the fund operation to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundOperation(walletId, addressId, fundOperationId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundOperation(walletId, addressId, fundOperationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['FundApi.getFundOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List fund operations for an address.
         * @summary List fund operations for an address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address to list fund operations for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFundOperations(walletId, addressId, limit, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFundOperations(walletId, addressId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['FundApi.listFundOperations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.FundApiFp = FundApiFp;
/**
 * FundApi - factory interface
 * @export
 */
const FundApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FundApiFp)(configuration);
    return {
        /**
         * Create a new fund operation with an address.
         * @summary Create a new fund operation.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address to be funded.
         * @param {CreateFundOperationRequest} createFundOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFundOperation(walletId, addressId, createFundOperationRequest, options) {
            return localVarFp.createFundOperation(walletId, addressId, createFundOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new fund operation with an address.
         * @summary Create a Fund Operation quote.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address to be funded.
         * @param {CreateFundQuoteRequest} createFundQuoteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFundQuote(walletId, addressId, createFundQuoteRequest, options) {
            return localVarFp.createFundQuote(walletId, addressId, createFundQuoteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get fund operation.
         * @summary Get fund operation.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address that created the fund operation.
         * @param {string} fundOperationId The ID of the fund operation to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundOperation(walletId, addressId, fundOperationId, options) {
            return localVarFp.getFundOperation(walletId, addressId, fundOperationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List fund operations for an address.
         * @summary List fund operations for an address.
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The onchain address of the address to list fund operations for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFundOperations(walletId, addressId, limit, page, options) {
            return localVarFp.listFundOperations(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FundApiFactory = FundApiFactory;
/**
 * FundApi - object-oriented interface
 * @export
 * @class FundApi
 * @extends {BaseAPI}
 */
class FundApi extends base_1.BaseAPI {
    /**
     * Create a new fund operation with an address.
     * @summary Create a new fund operation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address to be funded.
     * @param {CreateFundOperationRequest} createFundOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    createFundOperation(walletId, addressId, createFundOperationRequest, options) {
        return (0, exports.FundApiFp)(this.configuration).createFundOperation(walletId, addressId, createFundOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new fund operation with an address.
     * @summary Create a Fund Operation quote.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address to be funded.
     * @param {CreateFundQuoteRequest} createFundQuoteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    createFundQuote(walletId, addressId, createFundQuoteRequest, options) {
        return (0, exports.FundApiFp)(this.configuration).createFundQuote(walletId, addressId, createFundQuoteRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get fund operation.
     * @summary Get fund operation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that created the fund operation.
     * @param {string} fundOperationId The ID of the fund operation to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    getFundOperation(walletId, addressId, fundOperationId, options) {
        return (0, exports.FundApiFp)(this.configuration).getFundOperation(walletId, addressId, fundOperationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List fund operations for an address.
     * @summary List fund operations for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address to list fund operations for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    listFundOperations(walletId, addressId, limit, page, options) {
        return (0, exports.FundApiFp)(this.configuration).listFundOperations(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FundApi = FundApi;
/**
 * MPCWalletStakeApi - axios parameter creator
 * @export
 */
const MPCWalletStakeApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Broadcast a staking operation.
         * @summary Broadcast a staking operation
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the staking operation belongs to.
         * @param {string} stakingOperationId The ID of the staking operation to broadcast.
         * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastStakingOperation: async (walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('broadcastStakingOperation', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('broadcastStakingOperation', 'addressId', addressId);
            // verify required parameter 'stakingOperationId' is not null or undefined
            (0, common_1.assertParamExists)('broadcastStakingOperation', 'stakingOperationId', stakingOperationId);
            // verify required parameter 'broadcastStakingOperationRequest' is not null or undefined
            (0, common_1.assertParamExists)('broadcastStakingOperation', 'broadcastStakingOperationRequest', broadcastStakingOperationRequest);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/staking_operations/{staking_operation_id}/broadcast`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"staking_operation_id"}}`, encodeURIComponent(String(stakingOperationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastStakingOperationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new staking operation.
         * @summary Create a new staking operation for an address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to create the staking operation for.
         * @param {CreateStakingOperationRequest} createStakingOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStakingOperation: async (walletId, addressId, createStakingOperationRequest, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('createStakingOperation', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('createStakingOperation', 'addressId', addressId);
            // verify required parameter 'createStakingOperationRequest' is not null or undefined
            (0, common_1.assertParamExists)('createStakingOperation', 'createStakingOperationRequest', createStakingOperationRequest);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/staking_operations`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createStakingOperationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the latest state of a staking operation.
         * @summary Get the latest state of a staking operation
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to fetch the staking operation for.
         * @param {string} stakingOperationId The ID of the staking operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingOperation: async (walletId, addressId, stakingOperationId, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('getStakingOperation', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('getStakingOperation', 'addressId', addressId);
            // verify required parameter 'stakingOperationId' is not null or undefined
            (0, common_1.assertParamExists)('getStakingOperation', 'stakingOperationId', stakingOperationId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/staking_operations/{staking_operation_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"staking_operation_id"}}`, encodeURIComponent(String(stakingOperationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.MPCWalletStakeApiAxiosParamCreator = MPCWalletStakeApiAxiosParamCreator;
/**
 * MPCWalletStakeApi - functional programming interface
 * @export
 */
const MPCWalletStakeApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.MPCWalletStakeApiAxiosParamCreator)(configuration);
    return {
        /**
         * Broadcast a staking operation.
         * @summary Broadcast a staking operation
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the staking operation belongs to.
         * @param {string} stakingOperationId The ID of the staking operation to broadcast.
         * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['MPCWalletStakeApi.broadcastStakingOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new staking operation.
         * @summary Create a new staking operation for an address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to create the staking operation for.
         * @param {CreateStakingOperationRequest} createStakingOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStakingOperation(walletId, addressId, createStakingOperationRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStakingOperation(walletId, addressId, createStakingOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['MPCWalletStakeApi.createStakingOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the latest state of a staking operation.
         * @summary Get the latest state of a staking operation
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to fetch the staking operation for.
         * @param {string} stakingOperationId The ID of the staking operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStakingOperation(walletId, addressId, stakingOperationId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakingOperation(walletId, addressId, stakingOperationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['MPCWalletStakeApi.getStakingOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.MPCWalletStakeApiFp = MPCWalletStakeApiFp;
/**
 * MPCWalletStakeApi - factory interface
 * @export
 */
const MPCWalletStakeApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.MPCWalletStakeApiFp)(configuration);
    return {
        /**
         * Broadcast a staking operation.
         * @summary Broadcast a staking operation
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address the staking operation belongs to.
         * @param {string} stakingOperationId The ID of the staking operation to broadcast.
         * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options) {
            return localVarFp.broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new staking operation.
         * @summary Create a new staking operation for an address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to create the staking operation for.
         * @param {CreateStakingOperationRequest} createStakingOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStakingOperation(walletId, addressId, createStakingOperationRequest, options) {
            return localVarFp.createStakingOperation(walletId, addressId, createStakingOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the latest state of a staking operation.
         * @summary Get the latest state of a staking operation
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to fetch the staking operation for.
         * @param {string} stakingOperationId The ID of the staking operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingOperation(walletId, addressId, stakingOperationId, options) {
            return localVarFp.getStakingOperation(walletId, addressId, stakingOperationId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.MPCWalletStakeApiFactory = MPCWalletStakeApiFactory;
/**
 * MPCWalletStakeApi - object-oriented interface
 * @export
 * @class MPCWalletStakeApi
 * @extends {BaseAPI}
 */
class MPCWalletStakeApi extends base_1.BaseAPI {
    /**
     * Broadcast a staking operation.
     * @summary Broadcast a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the staking operation belongs to.
     * @param {string} stakingOperationId The ID of the staking operation to broadcast.
     * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MPCWalletStakeApi
     */
    broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options) {
        return (0, exports.MPCWalletStakeApiFp)(this.configuration).broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new staking operation.
     * @summary Create a new staking operation for an address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to create the staking operation for.
     * @param {CreateStakingOperationRequest} createStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MPCWalletStakeApi
     */
    createStakingOperation(walletId, addressId, createStakingOperationRequest, options) {
        return (0, exports.MPCWalletStakeApiFp)(this.configuration).createStakingOperation(walletId, addressId, createStakingOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the latest state of a staking operation.
     * @summary Get the latest state of a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to fetch the staking operation for.
     * @param {string} stakingOperationId The ID of the staking operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MPCWalletStakeApi
     */
    getStakingOperation(walletId, addressId, stakingOperationId, options) {
        return (0, exports.MPCWalletStakeApiFp)(this.configuration).getStakingOperation(walletId, addressId, stakingOperationId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.MPCWalletStakeApi = MPCWalletStakeApi;
/**
 * NetworksApi - axios parameter creator
 * @export
 */
const NetworksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get network
         * @summary Get network by ID
         * @param {string} networkId The ID of the network to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetwork: async (networkId, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('getNetwork', 'networkId', networkId);
            const localVarPath = `/v1/networks/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.NetworksApiAxiosParamCreator = NetworksApiAxiosParamCreator;
/**
 * NetworksApi - functional programming interface
 * @export
 */
const NetworksApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.NetworksApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get network
         * @summary Get network by ID
         * @param {string} networkId The ID of the network to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetwork(networkId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetwork(networkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['NetworksApi.getNetwork']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.NetworksApiFp = NetworksApiFp;
/**
 * NetworksApi - factory interface
 * @export
 */
const NetworksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.NetworksApiFp)(configuration);
    return {
        /**
         * Get network
         * @summary Get network by ID
         * @param {string} networkId The ID of the network to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetwork(networkId, options) {
            return localVarFp.getNetwork(networkId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.NetworksApiFactory = NetworksApiFactory;
/**
 * NetworksApi - object-oriented interface
 * @export
 * @class NetworksApi
 * @extends {BaseAPI}
 */
class NetworksApi extends base_1.BaseAPI {
    /**
     * Get network
     * @summary Get network by ID
     * @param {string} networkId The ID of the network to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    getNetwork(networkId, options) {
        return (0, exports.NetworksApiFp)(this.configuration).getNetwork(networkId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.NetworksApi = NetworksApi;
/**
 * OnchainIdentityApi - axios parameter creator
 * @export
 */
const OnchainIdentityApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Obtains onchain identity for an address on a specific network
         * @summary Obtains onchain identity for an address on a specific network
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the identity for
         * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveIdentityByAddress: async (networkId, addressId, roles, limit, page, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('resolveIdentityByAddress', 'networkId', networkId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('resolveIdentityByAddress', 'addressId', addressId);
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/identity`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (roles) {
                localVarQueryParameter['roles'] = roles.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.OnchainIdentityApiAxiosParamCreator = OnchainIdentityApiAxiosParamCreator;
/**
 * OnchainIdentityApi - functional programming interface
 * @export
 */
const OnchainIdentityApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.OnchainIdentityApiAxiosParamCreator)(configuration);
    return {
        /**
         * Obtains onchain identity for an address on a specific network
         * @summary Obtains onchain identity for an address on a specific network
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the identity for
         * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveIdentityByAddress(networkId, addressId, roles, limit, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveIdentityByAddress(networkId, addressId, roles, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['OnchainIdentityApi.resolveIdentityByAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.OnchainIdentityApiFp = OnchainIdentityApiFp;
/**
 * OnchainIdentityApi - factory interface
 * @export
 */
const OnchainIdentityApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.OnchainIdentityApiFp)(configuration);
    return {
        /**
         * Obtains onchain identity for an address on a specific network
         * @summary Obtains onchain identity for an address on a specific network
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the identity for
         * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveIdentityByAddress(networkId, addressId, roles, limit, page, options) {
            return localVarFp.resolveIdentityByAddress(networkId, addressId, roles, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};
exports.OnchainIdentityApiFactory = OnchainIdentityApiFactory;
/**
 * OnchainIdentityApi - object-oriented interface
 * @export
 * @class OnchainIdentityApi
 * @extends {BaseAPI}
 */
class OnchainIdentityApi extends base_1.BaseAPI {
    /**
     * Obtains onchain identity for an address on a specific network
     * @summary Obtains onchain identity for an address on a specific network
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the identity for
     * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnchainIdentityApi
     */
    resolveIdentityByAddress(networkId, addressId, roles, limit, page, options) {
        return (0, exports.OnchainIdentityApiFp)(this.configuration).resolveIdentityByAddress(networkId, addressId, roles, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.OnchainIdentityApi = OnchainIdentityApi;
/**
 * @export
 */
exports.ResolveIdentityByAddressRolesEnum = {
    Managed: 'managed',
    Owned: 'owned'
};
/**
 * ReputationApi - axios parameter creator
 * @export
 */
const ReputationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get the onchain reputation of an external address
         * @summary Get the onchain reputation of an external address
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} addressId The ID of the address to fetch the reputation for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressReputation: async (networkId, addressId, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('getAddressReputation', 'networkId', networkId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('getAddressReputation', 'addressId', addressId);
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/reputation`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ReputationApiAxiosParamCreator = ReputationApiAxiosParamCreator;
/**
 * ReputationApi - functional programming interface
 * @export
 */
const ReputationApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ReputationApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get the onchain reputation of an external address
         * @summary Get the onchain reputation of an external address
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} addressId The ID of the address to fetch the reputation for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressReputation(networkId, addressId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressReputation(networkId, addressId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ReputationApi.getAddressReputation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.ReputationApiFp = ReputationApiFp;
/**
 * ReputationApi - factory interface
 * @export
 */
const ReputationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ReputationApiFp)(configuration);
    return {
        /**
         * Get the onchain reputation of an external address
         * @summary Get the onchain reputation of an external address
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} addressId The ID of the address to fetch the reputation for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressReputation(networkId, addressId, options) {
            return localVarFp.getAddressReputation(networkId, addressId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ReputationApiFactory = ReputationApiFactory;
/**
 * ReputationApi - object-oriented interface
 * @export
 * @class ReputationApi
 * @extends {BaseAPI}
 */
class ReputationApi extends base_1.BaseAPI {
    /**
     * Get the onchain reputation of an external address
     * @summary Get the onchain reputation of an external address
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} addressId The ID of the address to fetch the reputation for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReputationApi
     */
    getAddressReputation(networkId, addressId, options) {
        return (0, exports.ReputationApiFp)(this.configuration).getAddressReputation(networkId, addressId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ReputationApi = ReputationApi;
/**
 * ServerSignersApi - axios parameter creator
 * @export
 */
const ServerSignersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new Server-Signer
         * @summary Create a new Server-Signer
         * @param {CreateServerSignerRequest} [createServerSignerRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServerSigner: async (createServerSignerRequest, options = {}) => {
            const localVarPath = `/v1/server_signers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createServerSignerRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a server signer by ID
         * @summary Get a server signer by ID
         * @param {string} serverSignerId The ID of the server signer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerSigner: async (serverSignerId, options = {}) => {
            // verify required parameter 'serverSignerId' is not null or undefined
            (0, common_1.assertParamExists)('getServerSigner', 'serverSignerId', serverSignerId);
            const localVarPath = `/v1/server_signers/{server_signer_id}`
                .replace(`{${"server_signer_id"}}`, encodeURIComponent(String(serverSignerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List events for a server signer
         * @summary List events for a server signer
         * @param {string} serverSignerId The ID of the server signer to fetch events for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listServerSignerEvents: async (serverSignerId, limit, page, options = {}) => {
            // verify required parameter 'serverSignerId' is not null or undefined
            (0, common_1.assertParamExists)('listServerSignerEvents', 'serverSignerId', serverSignerId);
            const localVarPath = `/v1/server_signers/{server_signer_id}/events`
                .replace(`{${"server_signer_id"}}`, encodeURIComponent(String(serverSignerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List server signers for the current project
         * @summary List server signers for the current project
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerSigners: async (limit, page, options = {}) => {
            const localVarPath = `/v1/server_signers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit the result of a server signer event
         * @summary Submit the result of a server signer event
         * @param {string} serverSignerId The ID of the server signer to submit the event result for
         * @param {SeedCreationEventResult} [seedCreationEventResult]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitServerSignerSeedEventResult: async (serverSignerId, seedCreationEventResult, options = {}) => {
            // verify required parameter 'serverSignerId' is not null or undefined
            (0, common_1.assertParamExists)('submitServerSignerSeedEventResult', 'serverSignerId', serverSignerId);
            const localVarPath = `/v1/server_signers/{server_signer_id}/seed_event_result`
                .replace(`{${"server_signer_id"}}`, encodeURIComponent(String(serverSignerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(seedCreationEventResult, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit the result of a server signer event
         * @summary Submit the result of a server signer event
         * @param {string} serverSignerId The ID of the server signer to submit the event result for
         * @param {SignatureCreationEventResult} [signatureCreationEventResult]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitServerSignerSignatureEventResult: async (serverSignerId, signatureCreationEventResult, options = {}) => {
            // verify required parameter 'serverSignerId' is not null or undefined
            (0, common_1.assertParamExists)('submitServerSignerSignatureEventResult', 'serverSignerId', serverSignerId);
            const localVarPath = `/v1/server_signers/{server_signer_id}/signature_event_result`
                .replace(`{${"server_signer_id"}}`, encodeURIComponent(String(serverSignerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(signatureCreationEventResult, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ServerSignersApiAxiosParamCreator = ServerSignersApiAxiosParamCreator;
/**
 * ServerSignersApi - functional programming interface
 * @export
 */
const ServerSignersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ServerSignersApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a new Server-Signer
         * @summary Create a new Server-Signer
         * @param {CreateServerSignerRequest} [createServerSignerRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServerSigner(createServerSignerRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServerSigner(createServerSignerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.createServerSigner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a server signer by ID
         * @summary Get a server signer by ID
         * @param {string} serverSignerId The ID of the server signer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerSigner(serverSignerId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerSigner(serverSignerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.getServerSigner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List events for a server signer
         * @summary List events for a server signer
         * @param {string} serverSignerId The ID of the server signer to fetch events for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async listServerSignerEvents(serverSignerId, limit, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerSignerEvents(serverSignerId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.listServerSignerEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List server signers for the current project
         * @summary List server signers for the current project
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServerSigners(limit, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerSigners(limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.listServerSigners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit the result of a server signer event
         * @summary Submit the result of a server signer event
         * @param {string} serverSignerId The ID of the server signer to submit the event result for
         * @param {SeedCreationEventResult} [seedCreationEventResult]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.submitServerSignerSeedEventResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit the result of a server signer event
         * @summary Submit the result of a server signer event
         * @param {string} serverSignerId The ID of the server signer to submit the event result for
         * @param {SignatureCreationEventResult} [signatureCreationEventResult]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.submitServerSignerSignatureEventResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.ServerSignersApiFp = ServerSignersApiFp;
/**
 * ServerSignersApi - factory interface
 * @export
 */
const ServerSignersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ServerSignersApiFp)(configuration);
    return {
        /**
         * Create a new Server-Signer
         * @summary Create a new Server-Signer
         * @param {CreateServerSignerRequest} [createServerSignerRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServerSigner(createServerSignerRequest, options) {
            return localVarFp.createServerSigner(createServerSignerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a server signer by ID
         * @summary Get a server signer by ID
         * @param {string} serverSignerId The ID of the server signer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerSigner(serverSignerId, options) {
            return localVarFp.getServerSigner(serverSignerId, options).then((request) => request(axios, basePath));
        },
        /**
         * List events for a server signer
         * @summary List events for a server signer
         * @param {string} serverSignerId The ID of the server signer to fetch events for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listServerSignerEvents(serverSignerId, limit, page, options) {
            return localVarFp.listServerSignerEvents(serverSignerId, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * List server signers for the current project
         * @summary List server signers for the current project
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServerSigners(limit, page, options) {
            return localVarFp.listServerSigners(limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit the result of a server signer event
         * @summary Submit the result of a server signer event
         * @param {string} serverSignerId The ID of the server signer to submit the event result for
         * @param {SeedCreationEventResult} [seedCreationEventResult]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options) {
            return localVarFp.submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit the result of a server signer event
         * @summary Submit the result of a server signer event
         * @param {string} serverSignerId The ID of the server signer to submit the event result for
         * @param {SignatureCreationEventResult} [signatureCreationEventResult]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options) {
            return localVarFp.submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ServerSignersApiFactory = ServerSignersApiFactory;
/**
 * ServerSignersApi - object-oriented interface
 * @export
 * @class ServerSignersApi
 * @extends {BaseAPI}
 */
class ServerSignersApi extends base_1.BaseAPI {
    /**
     * Create a new Server-Signer
     * @summary Create a new Server-Signer
     * @param {CreateServerSignerRequest} [createServerSignerRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    createServerSigner(createServerSignerRequest, options) {
        return (0, exports.ServerSignersApiFp)(this.configuration).createServerSigner(createServerSignerRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a server signer by ID
     * @summary Get a server signer by ID
     * @param {string} serverSignerId The ID of the server signer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    getServerSigner(serverSignerId, options) {
        return (0, exports.ServerSignersApiFp)(this.configuration).getServerSigner(serverSignerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List events for a server signer
     * @summary List events for a server signer
     * @param {string} serverSignerId The ID of the server signer to fetch events for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    listServerSignerEvents(serverSignerId, limit, page, options) {
        return (0, exports.ServerSignersApiFp)(this.configuration).listServerSignerEvents(serverSignerId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List server signers for the current project
     * @summary List server signers for the current project
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    listServerSigners(limit, page, options) {
        return (0, exports.ServerSignersApiFp)(this.configuration).listServerSigners(limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SeedCreationEventResult} [seedCreationEventResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options) {
        return (0, exports.ServerSignersApiFp)(this.configuration).submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SignatureCreationEventResult} [signatureCreationEventResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options) {
        return (0, exports.ServerSignersApiFp)(this.configuration).submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ServerSignersApi = ServerSignersApi;
/**
 * SmartContractsApi - axios parameter creator
 * @export
 */
const SmartContractsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Compile a smart contract
         * @summary Compile a smart contract
         * @param {CompileSmartContractRequest} compileSmartContractRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compileSmartContract: async (compileSmartContractRequest, options = {}) => {
            // verify required parameter 'compileSmartContractRequest' is not null or undefined
            (0, common_1.assertParamExists)('compileSmartContract', 'compileSmartContractRequest', compileSmartContractRequest);
            const localVarPath = `/v1/smart_contracts/compile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(compileSmartContractRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new smart contract
         * @summary Create a new smart contract
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to deploy the smart contract from.
         * @param {CreateSmartContractRequest} createSmartContractRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSmartContract: async (walletId, addressId, createSmartContractRequest, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('createSmartContract', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('createSmartContract', 'addressId', addressId);
            // verify required parameter 'createSmartContractRequest' is not null or undefined
            (0, common_1.assertParamExists)('createSmartContract', 'createSmartContractRequest', createSmartContractRequest);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/smart_contracts`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createSmartContractRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploys a smart contract, by broadcasting the transaction to the network.
         * @summary Deploy a smart contract
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to broadcast the transaction from.
         * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.
         * @param {DeploySmartContractRequest} deploySmartContractRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploySmartContract: async (walletId, addressId, smartContractId, deploySmartContractRequest, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('deploySmartContract', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('deploySmartContract', 'addressId', addressId);
            // verify required parameter 'smartContractId' is not null or undefined
            (0, common_1.assertParamExists)('deploySmartContract', 'smartContractId', smartContractId);
            // verify required parameter 'deploySmartContractRequest' is not null or undefined
            (0, common_1.assertParamExists)('deploySmartContract', 'deploySmartContractRequest', deploySmartContractRequest);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/smart_contracts/{smart_contract_id}/deploy`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"smart_contract_id"}}`, encodeURIComponent(String(smartContractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(deploySmartContractRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific smart contract deployed by address.
         * @summary Get a specific smart contract deployed by address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to fetch the smart contract for.
         * @param {string} smartContractId The UUID of the smart contract to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSmartContract: async (walletId, addressId, smartContractId, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('getSmartContract', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('getSmartContract', 'addressId', addressId);
            // verify required parameter 'smartContractId' is not null or undefined
            (0, common_1.assertParamExists)('getSmartContract', 'smartContractId', smartContractId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/smart_contracts/{smart_contract_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"smart_contract_id"}}`, encodeURIComponent(String(smartContractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List smart contracts
         * @summary List smart contracts
         * @param {string} [page] Pagination token for retrieving the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSmartContracts: async (page, options = {}) => {
            const localVarPath = `/v1/smart_contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a read operation on a smart contract without creating a transaction
         * @summary Read data from a smart contract
         * @param {string} networkId
         * @param {string} contractAddress
         * @param {ReadContractRequest} readContractRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readContract: async (networkId, contractAddress, readContractRequest, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('readContract', 'networkId', networkId);
            // verify required parameter 'contractAddress' is not null or undefined
            (0, common_1.assertParamExists)('readContract', 'contractAddress', contractAddress);
            // verify required parameter 'readContractRequest' is not null or undefined
            (0, common_1.assertParamExists)('readContract', 'readContractRequest', readContractRequest);
            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}/read`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(readContractRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a smart contract
         * @summary Register a smart contract
         * @param {string} networkId The ID of the network to fetch.
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {RegisterSmartContractRequest} [registerSmartContractRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSmartContract: async (networkId, contractAddress, registerSmartContractRequest, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('registerSmartContract', 'networkId', networkId);
            // verify required parameter 'contractAddress' is not null or undefined
            (0, common_1.assertParamExists)('registerSmartContract', 'contractAddress', contractAddress);
            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}/register`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(registerSmartContractRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a smart contract
         * @summary Update a smart contract
         * @param {string} networkId The ID of the network to fetch.
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {UpdateSmartContractRequest} [updateSmartContractRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSmartContract: async (networkId, contractAddress, updateSmartContractRequest, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('updateSmartContract', 'networkId', networkId);
            // verify required parameter 'contractAddress' is not null or undefined
            (0, common_1.assertParamExists)('updateSmartContract', 'contractAddress', contractAddress);
            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"contract_address"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateSmartContractRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.SmartContractsApiAxiosParamCreator = SmartContractsApiAxiosParamCreator;
/**
 * SmartContractsApi - functional programming interface
 * @export
 */
const SmartContractsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SmartContractsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Compile a smart contract
         * @summary Compile a smart contract
         * @param {CompileSmartContractRequest} compileSmartContractRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compileSmartContract(compileSmartContractRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compileSmartContract(compileSmartContractRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.compileSmartContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new smart contract
         * @summary Create a new smart contract
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to deploy the smart contract from.
         * @param {CreateSmartContractRequest} createSmartContractRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSmartContract(walletId, addressId, createSmartContractRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSmartContract(walletId, addressId, createSmartContractRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.createSmartContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deploys a smart contract, by broadcasting the transaction to the network.
         * @summary Deploy a smart contract
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to broadcast the transaction from.
         * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.
         * @param {DeploySmartContractRequest} deploySmartContractRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.deploySmartContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific smart contract deployed by address.
         * @summary Get a specific smart contract deployed by address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to fetch the smart contract for.
         * @param {string} smartContractId The UUID of the smart contract to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSmartContract(walletId, addressId, smartContractId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSmartContract(walletId, addressId, smartContractId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.getSmartContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List smart contracts
         * @summary List smart contracts
         * @param {string} [page] Pagination token for retrieving the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSmartContracts(page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSmartContracts(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.listSmartContracts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Perform a read operation on a smart contract without creating a transaction
         * @summary Read data from a smart contract
         * @param {string} networkId
         * @param {string} contractAddress
         * @param {ReadContractRequest} readContractRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readContract(networkId, contractAddress, readContractRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readContract(networkId, contractAddress, readContractRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.readContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a smart contract
         * @summary Register a smart contract
         * @param {string} networkId The ID of the network to fetch.
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {RegisterSmartContractRequest} [registerSmartContractRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.registerSmartContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a smart contract
         * @summary Update a smart contract
         * @param {string} networkId The ID of the network to fetch.
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {UpdateSmartContractRequest} [updateSmartContractRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.updateSmartContract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.SmartContractsApiFp = SmartContractsApiFp;
/**
 * SmartContractsApi - factory interface
 * @export
 */
const SmartContractsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SmartContractsApiFp)(configuration);
    return {
        /**
         * Compile a smart contract
         * @summary Compile a smart contract
         * @param {CompileSmartContractRequest} compileSmartContractRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compileSmartContract(compileSmartContractRequest, options) {
            return localVarFp.compileSmartContract(compileSmartContractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new smart contract
         * @summary Create a new smart contract
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to deploy the smart contract from.
         * @param {CreateSmartContractRequest} createSmartContractRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSmartContract(walletId, addressId, createSmartContractRequest, options) {
            return localVarFp.createSmartContract(walletId, addressId, createSmartContractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploys a smart contract, by broadcasting the transaction to the network.
         * @summary Deploy a smart contract
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to broadcast the transaction from.
         * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.
         * @param {DeploySmartContractRequest} deploySmartContractRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options) {
            return localVarFp.deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific smart contract deployed by address.
         * @summary Get a specific smart contract deployed by address
         * @param {string} walletId The ID of the wallet the address belongs to.
         * @param {string} addressId The ID of the address to fetch the smart contract for.
         * @param {string} smartContractId The UUID of the smart contract to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSmartContract(walletId, addressId, smartContractId, options) {
            return localVarFp.getSmartContract(walletId, addressId, smartContractId, options).then((request) => request(axios, basePath));
        },
        /**
         * List smart contracts
         * @summary List smart contracts
         * @param {string} [page] Pagination token for retrieving the next set of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSmartContracts(page, options) {
            return localVarFp.listSmartContracts(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a read operation on a smart contract without creating a transaction
         * @summary Read data from a smart contract
         * @param {string} networkId
         * @param {string} contractAddress
         * @param {ReadContractRequest} readContractRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readContract(networkId, contractAddress, readContractRequest, options) {
            return localVarFp.readContract(networkId, contractAddress, readContractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a smart contract
         * @summary Register a smart contract
         * @param {string} networkId The ID of the network to fetch.
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {RegisterSmartContractRequest} [registerSmartContractRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options) {
            return localVarFp.registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a smart contract
         * @summary Update a smart contract
         * @param {string} networkId The ID of the network to fetch.
         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
         * @param {UpdateSmartContractRequest} [updateSmartContractRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options) {
            return localVarFp.updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SmartContractsApiFactory = SmartContractsApiFactory;
/**
 * SmartContractsApi - object-oriented interface
 * @export
 * @class SmartContractsApi
 * @extends {BaseAPI}
 */
class SmartContractsApi extends base_1.BaseAPI {
    /**
     * Compile a smart contract
     * @summary Compile a smart contract
     * @param {CompileSmartContractRequest} compileSmartContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    compileSmartContract(compileSmartContractRequest, options) {
        return (0, exports.SmartContractsApiFp)(this.configuration).compileSmartContract(compileSmartContractRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new smart contract
     * @summary Create a new smart contract
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to deploy the smart contract from.
     * @param {CreateSmartContractRequest} createSmartContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    createSmartContract(walletId, addressId, createSmartContractRequest, options) {
        return (0, exports.SmartContractsApiFp)(this.configuration).createSmartContract(walletId, addressId, createSmartContractRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deploys a smart contract, by broadcasting the transaction to the network.
     * @summary Deploy a smart contract
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to broadcast the transaction from.
     * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.
     * @param {DeploySmartContractRequest} deploySmartContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options) {
        return (0, exports.SmartContractsApiFp)(this.configuration).deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a specific smart contract deployed by address.
     * @summary Get a specific smart contract deployed by address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to fetch the smart contract for.
     * @param {string} smartContractId The UUID of the smart contract to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    getSmartContract(walletId, addressId, smartContractId, options) {
        return (0, exports.SmartContractsApiFp)(this.configuration).getSmartContract(walletId, addressId, smartContractId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List smart contracts
     * @summary List smart contracts
     * @param {string} [page] Pagination token for retrieving the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    listSmartContracts(page, options) {
        return (0, exports.SmartContractsApiFp)(this.configuration).listSmartContracts(page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Perform a read operation on a smart contract without creating a transaction
     * @summary Read data from a smart contract
     * @param {string} networkId
     * @param {string} contractAddress
     * @param {ReadContractRequest} readContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    readContract(networkId, contractAddress, readContractRequest, options) {
        return (0, exports.SmartContractsApiFp)(this.configuration).readContract(networkId, contractAddress, readContractRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Register a smart contract
     * @summary Register a smart contract
     * @param {string} networkId The ID of the network to fetch.
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {RegisterSmartContractRequest} [registerSmartContractRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options) {
        return (0, exports.SmartContractsApiFp)(this.configuration).registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a smart contract
     * @summary Update a smart contract
     * @param {string} networkId The ID of the network to fetch.
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {UpdateSmartContractRequest} [updateSmartContractRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options) {
        return (0, exports.SmartContractsApiFp)(this.configuration).updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SmartContractsApi = SmartContractsApi;
/**
 * StakeApi - axios parameter creator
 * @export
 */
const StakeApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Build a new staking operation
         * @summary Build a new staking operation
         * @param {BuildStakingOperationRequest} buildStakingOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildStakingOperation: async (buildStakingOperationRequest, options = {}) => {
            // verify required parameter 'buildStakingOperationRequest' is not null or undefined
            (0, common_1.assertParamExists)('buildStakingOperation', 'buildStakingOperationRequest', buildStakingOperationRequest);
            const localVarPath = `/v1/stake/build`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(buildStakingOperationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch historical staking balances for given address.
         * @summary Fetch historical staking balances
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.
         * @param {string} addressId The onchain address for which the historical staking balances are being fetched.
         * @param {string} startTime The start time of this historical staking balance period.
         * @param {string} endTime The end time of this historical staking balance period.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchHistoricalStakingBalances: async (networkId, assetId, addressId, startTime, endTime, limit, page, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'networkId', networkId);
            // verify required parameter 'assetId' is not null or undefined
            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'assetId', assetId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'addressId', addressId);
            // verify required parameter 'startTime' is not null or undefined
            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'startTime', startTime);
            // verify required parameter 'endTime' is not null or undefined
            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'endTime', endTime);
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/stake/balances`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = assetId;
            }
            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime instanceof Date) ?
                    startTime.toISOString() :
                    startTime;
            }
            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime instanceof Date) ?
                    endTime.toISOString() :
                    endTime;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch staking rewards for a list of addresses
         * @summary Fetch staking rewards
         * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchStakingRewards: async (fetchStakingRewardsRequest, limit, page, options = {}) => {
            // verify required parameter 'fetchStakingRewardsRequest' is not null or undefined
            (0, common_1.assertParamExists)('fetchStakingRewards', 'fetchStakingRewardsRequest', fetchStakingRewardsRequest);
            const localVarPath = `/v1/stake/rewards/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(fetchStakingRewardsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the latest state of a staking operation
         * @summary Get the latest state of a staking operation
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the staking operation for
         * @param {string} stakingOperationId The ID of the staking operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalStakingOperation: async (networkId, addressId, stakingOperationId, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('getExternalStakingOperation', 'networkId', networkId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('getExternalStakingOperation', 'addressId', addressId);
            // verify required parameter 'stakingOperationId' is not null or undefined
            (0, common_1.assertParamExists)('getExternalStakingOperation', 'stakingOperationId', stakingOperationId);
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/staking_operations/{staking_operation_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"staking_operation_id"}}`, encodeURIComponent(String(stakingOperationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get staking context for an address
         * @summary Get staking context
         * @param {GetStakingContextRequest} getStakingContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingContext: async (getStakingContextRequest, options = {}) => {
            // verify required parameter 'getStakingContextRequest' is not null or undefined
            (0, common_1.assertParamExists)('getStakingContext', 'getStakingContextRequest', getStakingContextRequest);
            const localVarPath = `/v1/stake/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(getStakingContextRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a validator belonging to the user for a given network, asset and id.
         * @summary Get a validator belonging to the CDP project
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The symbol of the asset to get the validator for.
         * @param {string} validatorId The unique id of the validator to fetch details for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidator: async (networkId, assetId, validatorId, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('getValidator', 'networkId', networkId);
            // verify required parameter 'assetId' is not null or undefined
            (0, common_1.assertParamExists)('getValidator', 'assetId', assetId);
            // verify required parameter 'validatorId' is not null or undefined
            (0, common_1.assertParamExists)('getValidator', 'validatorId', validatorId);
            const localVarPath = `/v1/networks/{network_id}/assets/{asset_id}/validators/{validator_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"validator_id"}}`, encodeURIComponent(String(validatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List validators belonging to the user for a given network and asset.
         * @summary List validators belonging to the CDP project
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The symbol of the asset to get the validators for.
         * @param {ValidatorStatus} [status] A filter to list validators based on a status.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listValidators: async (networkId, assetId, status, limit, page, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('listValidators', 'networkId', networkId);
            // verify required parameter 'assetId' is not null or undefined
            (0, common_1.assertParamExists)('listValidators', 'assetId', assetId);
            const localVarPath = `/v1/networks/{network_id}/assets/{asset_id}/validators`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.StakeApiAxiosParamCreator = StakeApiAxiosParamCreator;
/**
 * StakeApi - functional programming interface
 * @export
 */
const StakeApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.StakeApiAxiosParamCreator)(configuration);
    return {
        /**
         * Build a new staking operation
         * @summary Build a new staking operation
         * @param {BuildStakingOperationRequest} buildStakingOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildStakingOperation(buildStakingOperationRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildStakingOperation(buildStakingOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.buildStakingOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch historical staking balances for given address.
         * @summary Fetch historical staking balances
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.
         * @param {string} addressId The onchain address for which the historical staking balances are being fetched.
         * @param {string} startTime The start time of this historical staking balance period.
         * @param {string} endTime The end time of this historical staking balance period.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.fetchHistoricalStakingBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch staking rewards for a list of addresses
         * @summary Fetch staking rewards
         * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.fetchStakingRewards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the latest state of a staking operation
         * @summary Get the latest state of a staking operation
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the staking operation for
         * @param {string} stakingOperationId The ID of the staking operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalStakingOperation(networkId, addressId, stakingOperationId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalStakingOperation(networkId, addressId, stakingOperationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.getExternalStakingOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get staking context for an address
         * @summary Get staking context
         * @param {GetStakingContextRequest} getStakingContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStakingContext(getStakingContextRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakingContext(getStakingContextRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.getStakingContext']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a validator belonging to the user for a given network, asset and id.
         * @summary Get a validator belonging to the CDP project
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The symbol of the asset to get the validator for.
         * @param {string} validatorId The unique id of the validator to fetch details for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidator(networkId, assetId, validatorId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidator(networkId, assetId, validatorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.getValidator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List validators belonging to the user for a given network and asset.
         * @summary List validators belonging to the CDP project
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The symbol of the asset to get the validators for.
         * @param {ValidatorStatus} [status] A filter to list validators based on a status.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listValidators(networkId, assetId, status, limit, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listValidators(networkId, assetId, status, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.listValidators']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.StakeApiFp = StakeApiFp;
/**
 * StakeApi - factory interface
 * @export
 */
const StakeApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.StakeApiFp)(configuration);
    return {
        /**
         * Build a new staking operation
         * @summary Build a new staking operation
         * @param {BuildStakingOperationRequest} buildStakingOperationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildStakingOperation(buildStakingOperationRequest, options) {
            return localVarFp.buildStakingOperation(buildStakingOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch historical staking balances for given address.
         * @summary Fetch historical staking balances
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.
         * @param {string} addressId The onchain address for which the historical staking balances are being fetched.
         * @param {string} startTime The start time of this historical staking balance period.
         * @param {string} endTime The end time of this historical staking balance period.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options) {
            return localVarFp.fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch staking rewards for a list of addresses
         * @summary Fetch staking rewards
         * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options) {
            return localVarFp.fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the latest state of a staking operation
         * @summary Get the latest state of a staking operation
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the staking operation for
         * @param {string} stakingOperationId The ID of the staking operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalStakingOperation(networkId, addressId, stakingOperationId, options) {
            return localVarFp.getExternalStakingOperation(networkId, addressId, stakingOperationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get staking context for an address
         * @summary Get staking context
         * @param {GetStakingContextRequest} getStakingContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakingContext(getStakingContextRequest, options) {
            return localVarFp.getStakingContext(getStakingContextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a validator belonging to the user for a given network, asset and id.
         * @summary Get a validator belonging to the CDP project
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The symbol of the asset to get the validator for.
         * @param {string} validatorId The unique id of the validator to fetch details for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidator(networkId, assetId, validatorId, options) {
            return localVarFp.getValidator(networkId, assetId, validatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * List validators belonging to the user for a given network and asset.
         * @summary List validators belonging to the CDP project
         * @param {string} networkId The ID of the blockchain network.
         * @param {string} assetId The symbol of the asset to get the validators for.
         * @param {ValidatorStatus} [status] A filter to list validators based on a status.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listValidators(networkId, assetId, status, limit, page, options) {
            return localVarFp.listValidators(networkId, assetId, status, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};
exports.StakeApiFactory = StakeApiFactory;
/**
 * StakeApi - object-oriented interface
 * @export
 * @class StakeApi
 * @extends {BaseAPI}
 */
class StakeApi extends base_1.BaseAPI {
    /**
     * Build a new staking operation
     * @summary Build a new staking operation
     * @param {BuildStakingOperationRequest} buildStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    buildStakingOperation(buildStakingOperationRequest, options) {
        return (0, exports.StakeApiFp)(this.configuration).buildStakingOperation(buildStakingOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch historical staking balances for given address.
     * @summary Fetch historical staking balances
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.
     * @param {string} addressId The onchain address for which the historical staking balances are being fetched.
     * @param {string} startTime The start time of this historical staking balance period.
     * @param {string} endTime The end time of this historical staking balance period.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options) {
        return (0, exports.StakeApiFp)(this.configuration).fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch staking rewards for a list of addresses
     * @summary Fetch staking rewards
     * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options) {
        return (0, exports.StakeApiFp)(this.configuration).fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the latest state of a staking operation
     * @summary Get the latest state of a staking operation
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the staking operation for
     * @param {string} stakingOperationId The ID of the staking operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    getExternalStakingOperation(networkId, addressId, stakingOperationId, options) {
        return (0, exports.StakeApiFp)(this.configuration).getExternalStakingOperation(networkId, addressId, stakingOperationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get staking context for an address
     * @summary Get staking context
     * @param {GetStakingContextRequest} getStakingContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    getStakingContext(getStakingContextRequest, options) {
        return (0, exports.StakeApiFp)(this.configuration).getStakingContext(getStakingContextRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a validator belonging to the user for a given network, asset and id.
     * @summary Get a validator belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validator for.
     * @param {string} validatorId The unique id of the validator to fetch details for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    getValidator(networkId, assetId, validatorId, options) {
        return (0, exports.StakeApiFp)(this.configuration).getValidator(networkId, assetId, validatorId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List validators belonging to the user for a given network and asset.
     * @summary List validators belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validators for.
     * @param {ValidatorStatus} [status] A filter to list validators based on a status.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    listValidators(networkId, assetId, status, limit, page, options) {
        return (0, exports.StakeApiFp)(this.configuration).listValidators(networkId, assetId, status, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.StakeApi = StakeApi;
/**
 * TradesApi - axios parameter creator
 * @export
 */
const TradesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Broadcast a trade
         * @summary Broadcast a trade
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the trade belongs to
         * @param {string} tradeId The ID of the trade to broadcast
         * @param {BroadcastTradeRequest} broadcastTradeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTrade: async (walletId, addressId, tradeId, broadcastTradeRequest, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('broadcastTrade', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('broadcastTrade', 'addressId', addressId);
            // verify required parameter 'tradeId' is not null or undefined
            (0, common_1.assertParamExists)('broadcastTrade', 'tradeId', tradeId);
            // verify required parameter 'broadcastTradeRequest' is not null or undefined
            (0, common_1.assertParamExists)('broadcastTrade', 'broadcastTradeRequest', broadcastTradeRequest);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades/{trade_id}/broadcast`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"trade_id"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastTradeRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new trade
         * @summary Create a new trade for an address
         * @param {string} walletId The ID of the wallet the source address belongs to
         * @param {string} addressId The ID of the address to conduct the trade from
         * @param {CreateTradeRequest} createTradeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrade: async (walletId, addressId, createTradeRequest, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('createTrade', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('createTrade', 'addressId', addressId);
            // verify required parameter 'createTradeRequest' is not null or undefined
            (0, common_1.assertParamExists)('createTrade', 'createTradeRequest', createTradeRequest);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createTradeRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a trade by ID
         * @summary Get a trade by ID
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the trade belongs to
         * @param {string} tradeId The ID of the trade to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade: async (walletId, addressId, tradeId, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('getTrade', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('getTrade', 'addressId', addressId);
            // verify required parameter 'tradeId' is not null or undefined
            (0, common_1.assertParamExists)('getTrade', 'tradeId', tradeId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades/{trade_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"trade_id"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List trades for an address.
         * @summary List trades for an address.
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to list trades for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades: async (walletId, addressId, limit, page, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('listTrades', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('listTrades', 'addressId', addressId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TradesApiAxiosParamCreator = TradesApiAxiosParamCreator;
/**
 * TradesApi - functional programming interface
 * @export
 */
const TradesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TradesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Broadcast a trade
         * @summary Broadcast a trade
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the trade belongs to
         * @param {string} tradeId The ID of the trade to broadcast
         * @param {BroadcastTradeRequest} broadcastTradeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TradesApi.broadcastTrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new trade
         * @summary Create a new trade for an address
         * @param {string} walletId The ID of the wallet the source address belongs to
         * @param {string} addressId The ID of the address to conduct the trade from
         * @param {CreateTradeRequest} createTradeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTrade(walletId, addressId, createTradeRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrade(walletId, addressId, createTradeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TradesApi.createTrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a trade by ID
         * @summary Get a trade by ID
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the trade belongs to
         * @param {string} tradeId The ID of the trade to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrade(walletId, addressId, tradeId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrade(walletId, addressId, tradeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TradesApi.getTrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List trades for an address.
         * @summary List trades for an address.
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to list trades for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTrades(walletId, addressId, limit, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrades(walletId, addressId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TradesApi.listTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.TradesApiFp = TradesApiFp;
/**
 * TradesApi - factory interface
 * @export
 */
const TradesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TradesApiFp)(configuration);
    return {
        /**
         * Broadcast a trade
         * @summary Broadcast a trade
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the trade belongs to
         * @param {string} tradeId The ID of the trade to broadcast
         * @param {BroadcastTradeRequest} broadcastTradeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options) {
            return localVarFp.broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new trade
         * @summary Create a new trade for an address
         * @param {string} walletId The ID of the wallet the source address belongs to
         * @param {string} addressId The ID of the address to conduct the trade from
         * @param {CreateTradeRequest} createTradeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrade(walletId, addressId, createTradeRequest, options) {
            return localVarFp.createTrade(walletId, addressId, createTradeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a trade by ID
         * @summary Get a trade by ID
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the trade belongs to
         * @param {string} tradeId The ID of the trade to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrade(walletId, addressId, tradeId, options) {
            return localVarFp.getTrade(walletId, addressId, tradeId, options).then((request) => request(axios, basePath));
        },
        /**
         * List trades for an address.
         * @summary List trades for an address.
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to list trades for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTrades(walletId, addressId, limit, page, options) {
            return localVarFp.listTrades(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TradesApiFactory = TradesApiFactory;
/**
 * TradesApi - object-oriented interface
 * @export
 * @class TradesApi
 * @extends {BaseAPI}
 */
class TradesApi extends base_1.BaseAPI {
    /**
     * Broadcast a trade
     * @summary Broadcast a trade
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to broadcast
     * @param {BroadcastTradeRequest} broadcastTradeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options) {
        return (0, exports.TradesApiFp)(this.configuration).broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new trade
     * @summary Create a new trade for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to conduct the trade from
     * @param {CreateTradeRequest} createTradeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    createTrade(walletId, addressId, createTradeRequest, options) {
        return (0, exports.TradesApiFp)(this.configuration).createTrade(walletId, addressId, createTradeRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a trade by ID
     * @summary Get a trade by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    getTrade(walletId, addressId, tradeId, options) {
        return (0, exports.TradesApiFp)(this.configuration).getTrade(walletId, addressId, tradeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List trades for an address.
     * @summary List trades for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list trades for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    listTrades(walletId, addressId, limit, page, options) {
        return (0, exports.TradesApiFp)(this.configuration).listTrades(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TradesApi = TradesApi;
/**
 * TransactionHistoryApi - axios parameter creator
 * @export
 */
const TransactionHistoryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List all transactions that interact with the address.
         * @summary List transactions for an address.
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the transactions for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressTransactions: async (networkId, addressId, limit, page, options = {}) => {
            // verify required parameter 'networkId' is not null or undefined
            (0, common_1.assertParamExists)('listAddressTransactions', 'networkId', networkId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('listAddressTransactions', 'addressId', addressId);
            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transactions`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TransactionHistoryApiAxiosParamCreator = TransactionHistoryApiAxiosParamCreator;
/**
 * TransactionHistoryApi - functional programming interface
 * @export
 */
const TransactionHistoryApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TransactionHistoryApiAxiosParamCreator)(configuration);
    return {
        /**
         * List all transactions that interact with the address.
         * @summary List transactions for an address.
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the transactions for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAddressTransactions(networkId, addressId, limit, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressTransactions(networkId, addressId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TransactionHistoryApi.listAddressTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.TransactionHistoryApiFp = TransactionHistoryApiFp;
/**
 * TransactionHistoryApi - factory interface
 * @export
 */
const TransactionHistoryApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TransactionHistoryApiFp)(configuration);
    return {
        /**
         * List all transactions that interact with the address.
         * @summary List transactions for an address.
         * @param {string} networkId The ID of the blockchain network
         * @param {string} addressId The ID of the address to fetch the transactions for.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddressTransactions(networkId, addressId, limit, page, options) {
            return localVarFp.listAddressTransactions(networkId, addressId, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TransactionHistoryApiFactory = TransactionHistoryApiFactory;
/**
 * TransactionHistoryApi - object-oriented interface
 * @export
 * @class TransactionHistoryApi
 * @extends {BaseAPI}
 */
class TransactionHistoryApi extends base_1.BaseAPI {
    /**
     * List all transactions that interact with the address.
     * @summary List transactions for an address.
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the transactions for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionHistoryApi
     */
    listAddressTransactions(networkId, addressId, limit, page, options) {
        return (0, exports.TransactionHistoryApiFp)(this.configuration).listAddressTransactions(networkId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TransactionHistoryApi = TransactionHistoryApi;
/**
 * TransfersApi - axios parameter creator
 * @export
 */
const TransfersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Broadcast a transfer
         * @summary Broadcast a transfer
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to broadcast
         * @param {BroadcastTransferRequest} broadcastTransferRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTransfer: async (walletId, addressId, transferId, broadcastTransferRequest, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('broadcastTransfer', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('broadcastTransfer', 'addressId', addressId);
            // verify required parameter 'transferId' is not null or undefined
            (0, common_1.assertParamExists)('broadcastTransfer', 'transferId', transferId);
            // verify required parameter 'broadcastTransferRequest' is not null or undefined
            (0, common_1.assertParamExists)('broadcastTransfer', 'broadcastTransferRequest', broadcastTransferRequest);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers/{transfer_id}/broadcast`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"transfer_id"}}`, encodeURIComponent(String(transferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastTransferRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new transfer
         * @summary Create a new transfer for an address
         * @param {string} walletId The ID of the wallet the source address belongs to
         * @param {string} addressId The ID of the address to transfer from
         * @param {CreateTransferRequest} createTransferRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer: async (walletId, addressId, createTransferRequest, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('createTransfer', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('createTransfer', 'addressId', addressId);
            // verify required parameter 'createTransferRequest' is not null or undefined
            (0, common_1.assertParamExists)('createTransfer', 'createTransferRequest', createTransferRequest);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createTransferRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a transfer by ID
         * @summary Get a transfer by ID
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer: async (walletId, addressId, transferId, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('getTransfer', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('getTransfer', 'addressId', addressId);
            // verify required parameter 'transferId' is not null or undefined
            (0, common_1.assertParamExists)('getTransfer', 'transferId', transferId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers/{transfer_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)))
                .replace(`{${"transfer_id"}}`, encodeURIComponent(String(transferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List transfers for an address.
         * @summary List transfers for an address.
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to list transfers for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransfers: async (walletId, addressId, limit, page, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('listTransfers', 'walletId', walletId);
            // verify required parameter 'addressId' is not null or undefined
            (0, common_1.assertParamExists)('listTransfers', 'addressId', addressId);
            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"address_id"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TransfersApiAxiosParamCreator = TransfersApiAxiosParamCreator;
/**
 * TransfersApi - functional programming interface
 * @export
 */
const TransfersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TransfersApiAxiosParamCreator)(configuration);
    return {
        /**
         * Broadcast a transfer
         * @summary Broadcast a transfer
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to broadcast
         * @param {BroadcastTransferRequest} broadcastTransferRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TransfersApi.broadcastTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new transfer
         * @summary Create a new transfer for an address
         * @param {string} walletId The ID of the wallet the source address belongs to
         * @param {string} addressId The ID of the address to transfer from
         * @param {CreateTransferRequest} createTransferRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransfer(walletId, addressId, createTransferRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransfer(walletId, addressId, createTransferRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TransfersApi.createTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a transfer by ID
         * @summary Get a transfer by ID
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransfer(walletId, addressId, transferId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransfer(walletId, addressId, transferId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TransfersApi.getTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List transfers for an address.
         * @summary List transfers for an address.
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to list transfers for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransfers(walletId, addressId, limit, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransfers(walletId, addressId, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TransfersApi.listTransfers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.TransfersApiFp = TransfersApiFp;
/**
 * TransfersApi - factory interface
 * @export
 */
const TransfersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TransfersApiFp)(configuration);
    return {
        /**
         * Broadcast a transfer
         * @summary Broadcast a transfer
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to broadcast
         * @param {BroadcastTransferRequest} broadcastTransferRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options) {
            return localVarFp.broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new transfer
         * @summary Create a new transfer for an address
         * @param {string} walletId The ID of the wallet the source address belongs to
         * @param {string} addressId The ID of the address to transfer from
         * @param {CreateTransferRequest} createTransferRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer(walletId, addressId, createTransferRequest, options) {
            return localVarFp.createTransfer(walletId, addressId, createTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a transfer by ID
         * @summary Get a transfer by ID
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address the transfer belongs to
         * @param {string} transferId The ID of the transfer to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer(walletId, addressId, transferId, options) {
            return localVarFp.getTransfer(walletId, addressId, transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * List transfers for an address.
         * @summary List transfers for an address.
         * @param {string} walletId The ID of the wallet the address belongs to
         * @param {string} addressId The ID of the address to list transfers for
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransfers(walletId, addressId, limit, page, options) {
            return localVarFp.listTransfers(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TransfersApiFactory = TransfersApiFactory;
/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
class TransfersApi extends base_1.BaseAPI {
    /**
     * Broadcast a transfer
     * @summary Broadcast a transfer
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastTransferRequest} broadcastTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options) {
        return (0, exports.TransfersApiFp)(this.configuration).broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new transfer
     * @summary Create a new transfer for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateTransferRequest} createTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    createTransfer(walletId, addressId, createTransferRequest, options) {
        return (0, exports.TransfersApiFp)(this.configuration).createTransfer(walletId, addressId, createTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a transfer by ID
     * @summary Get a transfer by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    getTransfer(walletId, addressId, transferId, options) {
        return (0, exports.TransfersApiFp)(this.configuration).getTransfer(walletId, addressId, transferId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List transfers for an address.
     * @summary List transfers for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list transfers for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    listTransfers(walletId, addressId, limit, page, options) {
        return (0, exports.TransfersApiFp)(this.configuration).listTransfers(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TransfersApi = TransfersApi;
/**
 * UsersApi - axios parameter creator
 * @export
 */
const UsersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get current user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options = {}) => {
            const localVarPath = `/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.UsersApiAxiosParamCreator = UsersApiAxiosParamCreator;
/**
 * UsersApi - functional programming interface
 * @export
 */
const UsersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UsersApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get current user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.UsersApiFp = UsersApiFp;
/**
 * UsersApi - factory interface
 * @export
 */
const UsersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UsersApiFp)(configuration);
    return {
        /**
         * Get current user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options) {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
    };
};
exports.UsersApiFactory = UsersApiFactory;
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
class UsersApi extends base_1.BaseAPI {
    /**
     * Get current user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getCurrentUser(options) {
        return (0, exports.UsersApiFp)(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UsersApi = UsersApi;
/**
 * WalletsApi - axios parameter creator
 * @export
 */
const WalletsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new wallet scoped to the user.
         * @summary Create a new wallet
         * @param {CreateWalletRequest} [createWalletRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWallet: async (createWalletRequest, options = {}) => {
            const localVarPath = `/v1/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWalletRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get wallet
         * @summary Get wallet by ID
         * @param {string} walletId The ID of the wallet to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet: async (walletId, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('getWallet', 'walletId', walletId);
            const localVarPath = `/v1/wallets/{wallet_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the aggregated balance of an asset across all of the addresses in the wallet.
         * @summary Get the balance of an asset in the wallet
         * @param {string} walletId The ID of the wallet to fetch the balance for
         * @param {string} assetId The symbol of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletBalance: async (walletId, assetId, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('getWalletBalance', 'walletId', walletId);
            // verify required parameter 'assetId' is not null or undefined
            (0, common_1.assertParamExists)('getWalletBalance', 'assetId', assetId);
            const localVarPath = `/v1/wallets/{wallet_id}/balances/{asset_id}`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the balances of all of the addresses in the wallet aggregated by asset.
         * @summary List wallet balances
         * @param {string} walletId The ID of the wallet to fetch the balances for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWalletBalances: async (walletId, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('listWalletBalances', 'walletId', walletId);
            const localVarPath = `/v1/wallets/{wallet_id}/balances`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List wallets belonging to the user.
         * @summary List wallets
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWallets: async (limit, page, options = {}) => {
            const localVarPath = `/v1/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.WalletsApiAxiosParamCreator = WalletsApiAxiosParamCreator;
/**
 * WalletsApi - functional programming interface
 * @export
 */
const WalletsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.WalletsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a new wallet scoped to the user.
         * @summary Create a new wallet
         * @param {CreateWalletRequest} [createWalletRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWallet(createWalletRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWallet(createWalletRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.createWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get wallet
         * @summary Get wallet by ID
         * @param {string} walletId The ID of the wallet to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWallet(walletId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWallet(walletId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.getWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the aggregated balance of an asset across all of the addresses in the wallet.
         * @summary Get the balance of an asset in the wallet
         * @param {string} walletId The ID of the wallet to fetch the balance for
         * @param {string} assetId The symbol of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWalletBalance(walletId, assetId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletBalance(walletId, assetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.getWalletBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the balances of all of the addresses in the wallet aggregated by asset.
         * @summary List wallet balances
         * @param {string} walletId The ID of the wallet to fetch the balances for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWalletBalances(walletId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWalletBalances(walletId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.listWalletBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List wallets belonging to the user.
         * @summary List wallets
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWallets(limit, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWallets(limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.listWallets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.WalletsApiFp = WalletsApiFp;
/**
 * WalletsApi - factory interface
 * @export
 */
const WalletsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.WalletsApiFp)(configuration);
    return {
        /**
         * Create a new wallet scoped to the user.
         * @summary Create a new wallet
         * @param {CreateWalletRequest} [createWalletRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWallet(createWalletRequest, options) {
            return localVarFp.createWallet(createWalletRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get wallet
         * @summary Get wallet by ID
         * @param {string} walletId The ID of the wallet to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet(walletId, options) {
            return localVarFp.getWallet(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the aggregated balance of an asset across all of the addresses in the wallet.
         * @summary Get the balance of an asset in the wallet
         * @param {string} walletId The ID of the wallet to fetch the balance for
         * @param {string} assetId The symbol of the asset to fetch the balance for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletBalance(walletId, assetId, options) {
            return localVarFp.getWalletBalance(walletId, assetId, options).then((request) => request(axios, basePath));
        },
        /**
         * List the balances of all of the addresses in the wallet aggregated by asset.
         * @summary List wallet balances
         * @param {string} walletId The ID of the wallet to fetch the balances for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWalletBalances(walletId, options) {
            return localVarFp.listWalletBalances(walletId, options).then((request) => request(axios, basePath));
        },
        /**
         * List wallets belonging to the user.
         * @summary List wallets
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWallets(limit, page, options) {
            return localVarFp.listWallets(limit, page, options).then((request) => request(axios, basePath));
        },
    };
};
exports.WalletsApiFactory = WalletsApiFactory;
/**
 * WalletsApi - object-oriented interface
 * @export
 * @class WalletsApi
 * @extends {BaseAPI}
 */
class WalletsApi extends base_1.BaseAPI {
    /**
     * Create a new wallet scoped to the user.
     * @summary Create a new wallet
     * @param {CreateWalletRequest} [createWalletRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    createWallet(createWalletRequest, options) {
        return (0, exports.WalletsApiFp)(this.configuration).createWallet(createWalletRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get wallet
     * @summary Get wallet by ID
     * @param {string} walletId The ID of the wallet to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    getWallet(walletId, options) {
        return (0, exports.WalletsApiFp)(this.configuration).getWallet(walletId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the aggregated balance of an asset across all of the addresses in the wallet.
     * @summary Get the balance of an asset in the wallet
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    getWalletBalance(walletId, assetId, options) {
        return (0, exports.WalletsApiFp)(this.configuration).getWalletBalance(walletId, assetId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List the balances of all of the addresses in the wallet aggregated by asset.
     * @summary List wallet balances
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    listWalletBalances(walletId, options) {
        return (0, exports.WalletsApiFp)(this.configuration).listWalletBalances(walletId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List wallets belonging to the user.
     * @summary List wallets
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    listWallets(limit, page, options) {
        return (0, exports.WalletsApiFp)(this.configuration).listWallets(limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WalletsApi = WalletsApi;
/**
 * WebhooksApi - axios parameter creator
 * @export
 */
const WebhooksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new webhook scoped to a wallet
         * @summary Create a new webhook scoped to a wallet
         * @param {string} walletId The ID of the wallet to create the webhook for.
         * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWebhook: async (walletId, createWalletWebhookRequest, options = {}) => {
            // verify required parameter 'walletId' is not null or undefined
            (0, common_1.assertParamExists)('createWalletWebhook', 'walletId', walletId);
            const localVarPath = `/v1/wallets/{wallet_id}/webhooks`
                .replace(`{${"wallet_id"}}`, encodeURIComponent(String(walletId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWalletWebhookRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new webhook
         * @summary Create a new webhook
         * @param {CreateWebhookRequest} [createWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (createWebhookRequest, options = {}) => {
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWebhookRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook
         * @summary Delete a webhook
         * @param {string} webhookId The Webhook uuid that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (webhookId, options = {}) => {
            // verify required parameter 'webhookId' is not null or undefined
            (0, common_1.assertParamExists)('deleteWebhook', 'webhookId', webhookId);
            const localVarPath = `/v1/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List webhooks, optionally filtered by event type.
         * @summary List webhooks
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks: async (limit, page, options = {}) => {
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a webhook
         * @summary Update a webhook
         * @param {string} webhookId The Webhook id that needs to be updated
         * @param {UpdateWebhookRequest} [updateWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (webhookId, updateWebhookRequest, options = {}) => {
            // verify required parameter 'webhookId' is not null or undefined
            (0, common_1.assertParamExists)('updateWebhook', 'webhookId', webhookId);
            const localVarPath = `/v1/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication apiKey required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            // authentication session required
            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Jwt", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateWebhookRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.WebhooksApiAxiosParamCreator = WebhooksApiAxiosParamCreator;
/**
 * WebhooksApi - functional programming interface
 * @export
 */
const WebhooksApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.WebhooksApiAxiosParamCreator)(configuration);
    return {
        /**
         * Create a new webhook scoped to a wallet
         * @summary Create a new webhook scoped to a wallet
         * @param {string} walletId The ID of the wallet to create the webhook for.
         * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWalletWebhook(walletId, createWalletWebhookRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWalletWebhook(walletId, createWalletWebhookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.createWalletWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new webhook
         * @summary Create a new webhook
         * @param {CreateWebhookRequest} [createWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(createWebhookRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(createWebhookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.createWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a webhook
         * @summary Delete a webhook
         * @param {string} webhookId The Webhook uuid that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(webhookId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.deleteWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List webhooks, optionally filtered by event type.
         * @summary List webhooks
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebhooks(limit, page, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhooks(limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.listWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a webhook
         * @summary Update a webhook
         * @param {string} webhookId The Webhook id that needs to be updated
         * @param {UpdateWebhookRequest} [updateWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(webhookId, updateWebhookRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(webhookId, updateWebhookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.updateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.WebhooksApiFp = WebhooksApiFp;
/**
 * WebhooksApi - factory interface
 * @export
 */
const WebhooksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.WebhooksApiFp)(configuration);
    return {
        /**
         * Create a new webhook scoped to a wallet
         * @summary Create a new webhook scoped to a wallet
         * @param {string} walletId The ID of the wallet to create the webhook for.
         * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletWebhook(walletId, createWalletWebhookRequest, options) {
            return localVarFp.createWalletWebhook(walletId, createWalletWebhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new webhook
         * @summary Create a new webhook
         * @param {CreateWebhookRequest} [createWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(createWebhookRequest, options) {
            return localVarFp.createWebhook(createWebhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a webhook
         * @summary Delete a webhook
         * @param {string} webhookId The Webhook uuid that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId, options) {
            return localVarFp.deleteWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * List webhooks, optionally filtered by event type.
         * @summary List webhooks
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(limit, page, options) {
            return localVarFp.listWebhooks(limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a webhook
         * @summary Update a webhook
         * @param {string} webhookId The Webhook id that needs to be updated
         * @param {UpdateWebhookRequest} [updateWebhookRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId, updateWebhookRequest, options) {
            return localVarFp.updateWebhook(webhookId, updateWebhookRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.WebhooksApiFactory = WebhooksApiFactory;
/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
class WebhooksApi extends base_1.BaseAPI {
    /**
     * Create a new webhook scoped to a wallet
     * @summary Create a new webhook scoped to a wallet
     * @param {string} walletId The ID of the wallet to create the webhook for.
     * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    createWalletWebhook(walletId, createWalletWebhookRequest, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).createWalletWebhook(walletId, createWalletWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new webhook
     * @summary Create a new webhook
     * @param {CreateWebhookRequest} [createWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    createWebhook(createWebhookRequest, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).createWebhook(createWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a webhook
     * @summary Delete a webhook
     * @param {string} webhookId The Webhook uuid that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    deleteWebhook(webhookId, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).deleteWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List webhooks, optionally filtered by event type.
     * @summary List webhooks
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    listWebhooks(limit, page, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).listWebhooks(limit, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a webhook
     * @summary Update a webhook
     * @param {string} webhookId The Webhook id that needs to be updated
     * @param {UpdateWebhookRequest} [updateWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    updateWebhook(webhookId, updateWebhookRequest, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).updateWebhook(webhookId, updateWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WebhooksApi = WebhooksApi;
