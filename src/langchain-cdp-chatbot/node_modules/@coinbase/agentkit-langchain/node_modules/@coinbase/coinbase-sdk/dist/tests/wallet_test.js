"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const crypto_1 = __importStar(require("crypto"));
const decimal_js_1 = __importDefault(require("decimal.js"));
const ethers_1 = require("ethers");
const api_error_1 = require("../coinbase/api_error");
const coinbase_1 = require("../coinbase/coinbase");
const errors_1 = require("../coinbase/errors");
const wallet_1 = require("../coinbase/wallet");
const transfer_1 = require("../coinbase/transfer");
const faucet_transaction_1 = require("../coinbase/faucet_transaction");
const types_1 = require("../coinbase/types");
const client_1 = require("./../client");
const utils_1 = require("./utils");
const trade_1 = require("../coinbase/trade");
const wallet_address_1 = require("../coinbase/address/wallet_address");
const staking_operation_1 = require("../coinbase/staking_operation");
const payload_signature_1 = require("../coinbase/payload_signature");
const contract_invocation_1 = require("../coinbase/contract_invocation");
const smart_contract_1 = require("../coinbase/smart_contract");
const webhook_1 = require("../coinbase/webhook");
describe("Wallet Class", () => {
    let wallet;
    let walletModel;
    let walletId;
    const apiResponses = {};
    const existingSeed = "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f";
    beforeAll(async () => {
        const { address1 } = (0, utils_1.generateWalletFromSeed)(existingSeed, 1);
        jest.spyOn(ethers_1.ethers.Wallet, "createRandom").mockReturnValue({
            privateKey: `0x${existingSeed}`,
        });
        walletId = crypto_1.default.randomUUID();
        // Mock the API calls
        coinbase_1.Coinbase.apiClients.wallet = utils_1.walletsApiMock;
        coinbase_1.Coinbase.apiClients.address = utils_1.addressesApiMock;
        coinbase_1.Coinbase.apiClients.wallet.createWallet = (0, utils_1.mockFn)(request => {
            const { network_id } = request.wallet;
            apiResponses[walletId] = {
                id: walletId,
                network_id,
                default_address: (0, utils_1.newAddressModel)(walletId),
            };
            return { data: apiResponses[walletId] };
        });
        coinbase_1.Coinbase.apiClients.wallet.getWallet = (0, utils_1.mockFn)(walletId => {
            walletModel = apiResponses[walletId];
            walletModel.default_address.address_id = address1;
            return { data: apiResponses[walletId] };
        });
        coinbase_1.Coinbase.apiClients.address.createAddress = (0, utils_1.mockFn)(walletId => {
            return { data: apiResponses[walletId].default_address };
        });
        wallet = await wallet_1.Wallet.create();
    });
    beforeEach(async () => {
        coinbase_1.Coinbase.useServerSigner = false;
    });
    describe("#stakingOperation", () => {
        let walletModel;
        const addressID = "0xdeadbeef";
        const STAKING_OPERATION_MODEL = {
            id: (0, crypto_1.randomUUID)(),
            network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
            address_id: addressID,
            status: client_1.StakingOperationStatusEnum.Complete,
            transactions: [
                {
                    from_address_id: addressID,
                    network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                    status: "pending",
                    unsigned_payload: "7b2274797065223a22307832222c22636861696e4964223a22307834323638222c226e6f" +
                        "6e6365223a2230783137222c22746f223a22307861353534313664653564653631613061" +
                        "633161613839373061323830653034333838623164653462222c22676173223a22307833" +
                        "30643430222c226761735072696365223a6e756c6c2c226d61785072696f726974794665" +
                        "65506572476173223a223078323534306265343030222c226d6178466565506572476173" +
                        "223a223078326437313162383430222c2276616c7565223a223078356166333130376134" +
                        "303030222c22696e707574223a2230783361346236366631222c226163636573734c6973" +
                        "74223a5b5d2c2276223a22307830222c2272223a22307830222c2273223a22307830222c" +
                        "2279506172697479223a22307830222c2268617368223a22307839613034353830343332" +
                        "646630666334656139646164653561343836353433623831666239333833316430646239" +
                        "386263356436373834393339343866333432227d",
                },
            ],
        };
        const STAKING_CONTEXT_MODEL = {
            context: {
                stakeable_balance: {
                    amount: "3000000000000000000",
                    asset: {
                        asset_id: coinbase_1.Coinbase.assets.Eth,
                        network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                        decimals: 18,
                        contract_address: "0x",
                    },
                },
                unstakeable_balance: {
                    amount: "2000000000000000000",
                    asset: {
                        asset_id: coinbase_1.Coinbase.assets.Eth,
                        network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                        decimals: 18,
                        contract_address: "0x",
                    },
                },
                claimable_balance: {
                    amount: "1000000000000000000",
                    asset: {
                        asset_id: coinbase_1.Coinbase.assets.Eth,
                        network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                        decimals: 18,
                        contract_address: "0x",
                    },
                },
            },
        };
        const STAKING_REWARD_RESPONSE = {
            data: [
                {
                    address_id: addressID,
                    date: "2024-05-01",
                    amount: "361",
                    state: client_1.StakingRewardStateEnum.Pending,
                    format: client_1.StakingRewardFormat.Usd,
                    usd_value: {
                        amount: "361",
                        conversion_price: "3000",
                        conversion_time: "2024-05-01T00:00:00Z",
                    },
                },
                {
                    address_id: addressID,
                    date: "2024-05-02",
                    amount: "203",
                    state: client_1.StakingRewardStateEnum.Pending,
                    format: client_1.StakingRewardFormat.Usd,
                    usd_value: {
                        amount: "203",
                        conversion_price: "3000",
                        conversion_time: "2024-05-02T00:00:00Z",
                    },
                },
                {
                    address_id: addressID,
                    date: "2024-05-03",
                    amount: "226",
                    state: client_1.StakingRewardStateEnum.Pending,
                    format: client_1.StakingRewardFormat.Usd,
                    usd_value: {
                        amount: "226",
                        conversion_price: "3000",
                        conversion_time: "2024-05-03T00:00:00Z",
                    },
                },
            ],
            has_more: false,
            next_page: "",
        };
        const HISTORICAL_STAKING_BALANCES_RESPONSE = {
            data: [
                {
                    address: addressID,
                    date: "2024-05-01",
                    bonded_stake: {
                        amount: "32000000000000000000",
                        asset: {
                            asset_id: coinbase_1.Coinbase.assets.Eth,
                            network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                            decimals: 18,
                        },
                    },
                    unbonded_balance: {
                        amount: "2000000000000000000",
                        asset: {
                            asset_id: coinbase_1.Coinbase.assets.Eth,
                            network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                            decimals: 18,
                        },
                    },
                    participant_type: "validator",
                },
                {
                    address: addressID,
                    date: "2024-05-02",
                    bonded_stake: {
                        amount: "32000000000000000000",
                        asset: {
                            asset_id: coinbase_1.Coinbase.assets.Eth,
                            network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                            decimals: 18,
                        },
                    },
                    unbonded_balance: {
                        amount: "2000000000000000000",
                        asset: {
                            asset_id: coinbase_1.Coinbase.assets.Eth,
                            network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                            decimals: 18,
                        },
                    },
                    participant_type: "validator",
                },
            ],
            has_more: false,
            next_page: "",
        };
        beforeAll(() => {
            coinbase_1.Coinbase.apiClients.stake = utils_1.stakeApiMock;
            coinbase_1.Coinbase.apiClients.walletStake = utils_1.walletStakeApiMock;
            coinbase_1.Coinbase.apiClients.asset = utils_1.assetsApiMock;
        });
        beforeEach(() => {
            jest.clearAllMocks();
        });
        describe(".createStake", () => {
            it("should create a staking operation from the default address", async () => {
                const wallet = await wallet_1.Wallet.create({ networkId: coinbase_1.Coinbase.networks.EthereumHolesky });
                STAKING_OPERATION_MODEL.wallet_id = wallet.getId();
                coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
                coinbase_1.Coinbase.apiClients.stake.getStakingContext = (0, utils_1.mockReturnValue)(STAKING_CONTEXT_MODEL);
                coinbase_1.Coinbase.apiClients.walletStake.createStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                coinbase_1.Coinbase.apiClients.walletStake.broadcastStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                STAKING_OPERATION_MODEL.status = client_1.StakingOperationStatusEnum.Complete;
                coinbase_1.Coinbase.apiClients.walletStake.getStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                const op = await wallet.createStake(0.001, coinbase_1.Coinbase.assets.Eth);
                expect(op).toBeInstanceOf(staking_operation_1.StakingOperation);
            });
            it("should throw an error when wait is called on wallet address based staking operation", async () => {
                const wallet = await wallet_1.Wallet.create({ networkId: coinbase_1.Coinbase.networks.EthereumHolesky });
                const op = await wallet.createStake(0.001, coinbase_1.Coinbase.assets.Eth);
                expect(op).toBeInstanceOf(staking_operation_1.StakingOperation);
                await expect(async () => await op.wait()).rejects.toThrow(Error);
            });
            it("should fail when reloading without a wallet id", async () => {
                const stakingOperation = new staking_operation_1.StakingOperation(STAKING_OPERATION_MODEL);
                STAKING_OPERATION_MODEL.wallet_id = undefined;
                await expect(async () => await stakingOperation.reload()).rejects.toThrow(Error);
            });
        });
        describe(".createUnstake", () => {
            it("should create a staking operation from the default address", async () => {
                const wallet = await wallet_1.Wallet.create({ networkId: coinbase_1.Coinbase.networks.EthereumHolesky });
                STAKING_OPERATION_MODEL.wallet_id = wallet.getId();
                coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
                coinbase_1.Coinbase.apiClients.stake.getStakingContext = (0, utils_1.mockReturnValue)(STAKING_CONTEXT_MODEL);
                coinbase_1.Coinbase.apiClients.walletStake.createStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                coinbase_1.Coinbase.apiClients.walletStake.broadcastStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                STAKING_OPERATION_MODEL.status = client_1.StakingOperationStatusEnum.Complete;
                coinbase_1.Coinbase.apiClients.walletStake.getStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                const op = await wallet.createUnstake(0.001, coinbase_1.Coinbase.assets.Eth);
                expect(op).toBeInstanceOf(staking_operation_1.StakingOperation);
            });
        });
        describe(".createClaimStake", () => {
            it("should create a staking operation from the default address", async () => {
                const wallet = await wallet_1.Wallet.create({ networkId: coinbase_1.Coinbase.networks.EthereumHolesky });
                STAKING_OPERATION_MODEL.wallet_id = wallet.getId();
                coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
                coinbase_1.Coinbase.apiClients.stake.getStakingContext = (0, utils_1.mockReturnValue)(STAKING_CONTEXT_MODEL);
                coinbase_1.Coinbase.apiClients.walletStake.createStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                coinbase_1.Coinbase.apiClients.walletStake.broadcastStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                STAKING_OPERATION_MODEL.status = client_1.StakingOperationStatusEnum.Complete;
                coinbase_1.Coinbase.apiClients.walletStake.getStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                const op = await wallet.createClaimStake(0.001, coinbase_1.Coinbase.assets.Eth);
                expect(op).toBeInstanceOf(staking_operation_1.StakingOperation);
            });
        });
        describe(".stakeableBalance", () => {
            it("should return the stakeable balance successfully with default params", async () => {
                //const wallet = await Wallet.create({ networkId: Coinbase.networks.EthereumHolesky });
                coinbase_1.Coinbase.apiClients.stake.getStakingContext = (0, utils_1.mockReturnValue)(STAKING_CONTEXT_MODEL);
                const stakeableBalance = await wallet.stakeableBalance(coinbase_1.Coinbase.assets.Eth);
                expect(stakeableBalance).toEqual(new decimal_js_1.default("3"));
            });
        });
        describe(".unstakeableBalance", () => {
            it("should return the unstakeableBalance balance successfully with default params", async () => {
                const wallet = await wallet_1.Wallet.create({ networkId: coinbase_1.Coinbase.networks.EthereumHolesky });
                coinbase_1.Coinbase.apiClients.stake.getStakingContext = (0, utils_1.mockReturnValue)(STAKING_CONTEXT_MODEL);
                const stakeableBalance = await wallet.unstakeableBalance(coinbase_1.Coinbase.assets.Eth);
                expect(stakeableBalance).toEqual(new decimal_js_1.default("2"));
            });
        });
        describe(".claimableBalance", () => {
            it("should return the claimableBalance balance successfully with default params", async () => {
                const wallet = await wallet_1.Wallet.create({ networkId: coinbase_1.Coinbase.networks.EthereumHolesky });
                coinbase_1.Coinbase.apiClients.stake.getStakingContext = (0, utils_1.mockReturnValue)(STAKING_CONTEXT_MODEL);
                const stakeableBalance = await wallet.claimableBalance(coinbase_1.Coinbase.assets.Eth);
                expect(stakeableBalance).toEqual(new decimal_js_1.default("1"));
            });
        });
        describe(".stakingRewards", () => {
            it("should successfully return staking rewards", async () => {
                const wallet = await wallet_1.Wallet.create({ networkId: coinbase_1.Coinbase.networks.EthereumHolesky });
                coinbase_1.Coinbase.apiClients.stake.fetchStakingRewards = (0, utils_1.mockReturnValue)(STAKING_REWARD_RESPONSE);
                coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
                const response = await wallet.stakingRewards(coinbase_1.Coinbase.assets.Eth);
                expect(response).toBeInstanceOf((Array));
            });
        });
        describe(".historicalStakingBalances", () => {
            it("should successfully return historical staking balances", async () => {
                const wallet = await wallet_1.Wallet.create({ networkId: coinbase_1.Coinbase.networks.EthereumHolesky });
                coinbase_1.Coinbase.apiClients.stake.fetchHistoricalStakingBalances = (0, utils_1.mockReturnValue)(HISTORICAL_STAKING_BALANCES_RESPONSE);
                coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
                const response = await wallet.historicalStakingBalances(coinbase_1.Coinbase.assets.Eth);
                expect(response).toBeInstanceOf((Array));
                expect(response.length).toEqual(2);
                expect(response[0].bondedStake().amount).toEqual(new decimal_js_1.default("32"));
                expect(response[0].bondedStake().asset?.assetId).toEqual("eth");
                expect(response[0].bondedStake().asset?.decimals).toEqual(18);
                expect(response[0].bondedStake().asset?.networkId).toEqual(coinbase_1.Coinbase.networks.EthereumHolesky);
                expect(response[0].unbondedBalance().amount).toEqual(new decimal_js_1.default("2"));
                expect(response[0].unbondedBalance().asset?.assetId).toEqual("eth");
                expect(response[0].unbondedBalance().asset?.decimals).toEqual(18);
                expect(response[0].unbondedBalance().asset?.networkId).toEqual(coinbase_1.Coinbase.networks.EthereumHolesky);
            });
        });
    });
    describe(".listHistoricalBalances", () => {
        beforeEach(() => {
            const mockHistoricalBalanceResponse = {
                data: [
                    {
                        amount: "1000000",
                        block_hash: "0x0dadd465fb063ceb78babbb30abbc6bfc0730d0c57a53e8f6dc778dafcea568f",
                        block_height: "12345",
                        asset: {
                            asset_id: "usdc",
                            network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                            decimals: 6,
                        },
                    },
                    {
                        amount: "5000000",
                        block_hash: "0x5c05a37dcb4910b22a775fc9480f8422d9d615ad7a6a0aa9d8778ff8cc300986",
                        block_height: "67890",
                        asset: {
                            asset_id: "usdc",
                            network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                            decimals: 6,
                        },
                    },
                ],
                has_more: false,
                next_page: "",
            };
            coinbase_1.Coinbase.apiClients.balanceHistory = utils_1.balanceHistoryApiMock;
            coinbase_1.Coinbase.apiClients.balanceHistory.listAddressHistoricalBalance = (0, utils_1.mockReturnValue)(mockHistoricalBalanceResponse);
        });
        it("should successfully return historical balances", async () => {
            const wallet = await wallet_1.Wallet.create({ networkId: coinbase_1.Coinbase.networks.EthereumHolesky });
            coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
            const response = await wallet.listHistoricalBalances(coinbase_1.Coinbase.assets.Usdc);
            expect(response.data.length).toEqual(2);
            expect(response.data[0].amount).toEqual(new decimal_js_1.default(1));
            expect(response.data[1].amount).toEqual(new decimal_js_1.default(5));
            expect(response.nextPage).toBe(undefined);
        });
    });
    describe(".createTransfer", () => {
        let weiAmount, destination;
        let balanceModel;
        beforeEach(() => {
            jest.clearAllMocks();
            const key = ethers_1.ethers.Wallet.createRandom();
            weiAmount = new decimal_js_1.default("5");
            destination = new wallet_address_1.WalletAddress(utils_1.VALID_ADDRESS_MODEL, key);
            coinbase_1.Coinbase.apiClients.externalAddress = utils_1.externalAddressApiMock;
            coinbase_1.Coinbase.apiClients.asset = utils_1.assetsApiMock;
            coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
            coinbase_1.Coinbase.apiClients.externalAddress.getExternalAddressBalance = (0, utils_1.mockFn)(request => {
                const { asset_id } = request;
                balanceModel = {
                    amount: "5000000000000000000",
                    asset: {
                        network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                        asset_id,
                        decimals: 18,
                        contract_address: "0x",
                    },
                };
                return { data: balanceModel };
            });
            coinbase_1.Coinbase.apiClients.transfer = utils_1.transfersApiMock;
        });
        it("should successfully create a transfer", async () => {
            coinbase_1.Coinbase.apiClients.transfer.createTransfer = (0, utils_1.mockReturnValue)(utils_1.VALID_TRANSFER_MODEL);
            coinbase_1.Coinbase.apiClients.transfer.broadcastTransfer = (0, utils_1.mockReturnValue)({
                transaction_hash: "0x6c087c1676e8269dd81e0777244584d0cbfd39b6997b3477242a008fa9349e11",
                ...utils_1.VALID_TRANSFER_MODEL,
            });
            const transfer = await wallet.createTransfer({
                amount: weiAmount,
                assetId: coinbase_1.Coinbase.assets.Wei,
                destination,
            });
            expect(coinbase_1.Coinbase.apiClients.transfer.createTransfer).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.transfer.broadcastTransfer).toHaveBeenCalledTimes(1);
            expect(transfer).toBeInstanceOf(transfer_1.Transfer);
            expect(transfer.getId()).toBe(utils_1.VALID_TRANSFER_MODEL.transfer_id);
        });
        // TODO: Returns the transfer.
        it("should throw an APIError if the createTransfer API call fails", async () => {
            coinbase_1.Coinbase.apiClients.transfer.createTransfer = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError("Failed to create transfer"));
            await expect(wallet.createTransfer({
                amount: weiAmount,
                assetId: coinbase_1.Coinbase.assets.Wei,
                destination,
            })).rejects.toThrow(api_error_1.APIError);
        });
        it("should throw an APIError if the broadcastTransfer API call fails", async () => {
            coinbase_1.Coinbase.apiClients.transfer.createTransfer = (0, utils_1.mockReturnValue)(utils_1.VALID_TRANSFER_MODEL);
            coinbase_1.Coinbase.apiClients.transfer.broadcastTransfer = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError("Failed to broadcast transfer"));
            await expect(wallet.createTransfer({
                amount: weiAmount,
                assetId: coinbase_1.Coinbase.assets.Wei,
                destination,
            })).rejects.toThrow(api_error_1.APIError);
        });
        it("should throw an ArgumentError if there are insufficient funds", async () => {
            const insufficientAmount = new decimal_js_1.default("10000000000000000000");
            await expect(wallet.createTransfer({
                amount: insufficientAmount,
                assetId: coinbase_1.Coinbase.assets.Wei,
                destination,
            })).rejects.toThrow(errors_1.ArgumentError);
        });
        it("should successfully create a transfer when using server signer", async () => {
            coinbase_1.Coinbase.useServerSigner = true;
            coinbase_1.Coinbase.apiClients.transfer.createTransfer = (0, utils_1.mockReturnValue)(utils_1.VALID_TRANSFER_MODEL);
            const transfer = await wallet.createTransfer({
                amount: weiAmount,
                assetId: coinbase_1.Coinbase.assets.Wei,
                destination,
            });
            expect(coinbase_1.Coinbase.apiClients.transfer.createTransfer).toHaveBeenCalledTimes(1);
            expect(transfer).toBeInstanceOf(transfer_1.Transfer);
            expect(transfer.getId()).toBe(utils_1.VALID_TRANSFER_MODEL.transfer_id);
        });
        afterEach(() => {
            jest.restoreAllMocks();
        });
    });
    describe("#invokeContract", () => {
        let expectedInvocation;
        let options = {
            abi: utils_1.MINT_NFT_ABI,
            args: utils_1.MINT_NFT_ARGS,
            method: utils_1.VALID_SIGNED_CONTRACT_INVOCATION_MODEL.method,
            contractAddress: utils_1.VALID_SIGNED_CONTRACT_INVOCATION_MODEL.contract_address,
        };
        beforeEach(async () => {
            expectedInvocation = contract_invocation_1.ContractInvocation.fromModel(utils_1.VALID_SIGNED_CONTRACT_INVOCATION_MODEL);
            (await wallet.getDefaultAddress()).invokeContract = jest
                .fn()
                .mockResolvedValue(expectedInvocation);
        });
        it("successfully invokes a contract on the default address", async () => {
            const contractInvocation = await wallet.invokeContract(options);
            expect((await wallet.getDefaultAddress()).invokeContract).toHaveBeenCalledTimes(1);
            expect((await wallet.getDefaultAddress()).invokeContract).toHaveBeenCalledWith(options);
            expect(contractInvocation).toBeInstanceOf(contract_invocation_1.ContractInvocation);
            expect(contractInvocation).toEqual(expectedInvocation);
        });
    });
    describe("#faucet", () => {
        let expectedFaucetTx;
        beforeEach(async () => {
            expectedFaucetTx = new faucet_transaction_1.FaucetTransaction(utils_1.VALID_FAUCET_TRANSACTION_MODEL);
            (await wallet.getDefaultAddress()).faucet = jest.fn().mockResolvedValue(expectedFaucetTx);
        });
        it("successfully requests faucet funds", async () => {
            const faucetTx = await wallet.faucet();
            expect((await wallet.getDefaultAddress()).faucet).toHaveBeenCalledTimes(1);
            expect((await wallet.getDefaultAddress()).faucet).toHaveBeenCalledWith(undefined);
            expect(faucetTx).toBeInstanceOf(faucet_transaction_1.FaucetTransaction);
            expect(faucetTx).toEqual(expectedFaucetTx);
        });
        it("successfully requests faucet funds with an asset specified", async () => {
            const faucetTx = await wallet.faucet("usdc");
            expect((await wallet.getDefaultAddress()).faucet).toHaveBeenCalledTimes(1);
            expect((await wallet.getDefaultAddress()).faucet).toHaveBeenCalledWith("usdc");
            expect(faucetTx).toBeInstanceOf(faucet_transaction_1.FaucetTransaction);
            expect(faucetTx).toEqual(expectedFaucetTx);
        });
    });
    describe("#deployToken", () => {
        let expectedSmartContract;
        let options = {
            name: utils_1.ERC20_NAME,
            symbol: utils_1.ERC20_SYMBOL,
            totalSupply: utils_1.ERC20_TOTAL_SUPPLY,
        };
        beforeEach(async () => {
            expectedSmartContract = smart_contract_1.SmartContract.fromModel(utils_1.VALID_SMART_CONTRACT_ERC20_MODEL);
            (await wallet.getDefaultAddress()).deployToken = jest
                .fn()
                .mockResolvedValue(expectedSmartContract);
        });
        it("successfully deploys an ERC20 contract on the default address", async () => {
            const smartContract = await wallet.deployToken(options);
            expect((await wallet.getDefaultAddress()).deployToken).toHaveBeenCalledTimes(1);
            expect((await wallet.getDefaultAddress()).deployToken).toHaveBeenCalledWith(options);
            expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
            expect(smartContract).toEqual(expectedSmartContract);
        });
    });
    describe("#deployNFT", () => {
        let expectedSmartContract;
        let options = {
            name: utils_1.ERC721_NAME,
            symbol: utils_1.ERC721_SYMBOL,
            baseURI: utils_1.ERC721_BASE_URI,
        };
        beforeEach(async () => {
            expectedSmartContract = smart_contract_1.SmartContract.fromModel(utils_1.VALID_SMART_CONTRACT_ERC721_MODEL);
            (await wallet.getDefaultAddress()).deployNFT = jest
                .fn()
                .mockResolvedValue(expectedSmartContract);
        });
        it("successfully deploys an ERC721 contract on the default address", async () => {
            const smartContract = await wallet.deployNFT(options);
            expect((await wallet.getDefaultAddress()).deployNFT).toHaveBeenCalledTimes(1);
            expect((await wallet.getDefaultAddress()).deployNFT).toHaveBeenCalledWith(options);
            expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
            expect(smartContract).toEqual(expectedSmartContract);
        });
    });
    describe("#deployMultiToken", () => {
        let expectedSmartContract;
        let options = {
            uri: "https://example.com/metadata",
        };
        beforeEach(async () => {
            expectedSmartContract = smart_contract_1.SmartContract.fromModel(utils_1.VALID_SMART_CONTRACT_ERC1155_MODEL);
            (await wallet.getDefaultAddress()).deployMultiToken = jest
                .fn()
                .mockResolvedValue(expectedSmartContract);
        });
        it("successfully deploys an ERC1155 contract on the default address", async () => {
            const smartContract = await wallet.deployMultiToken(options);
            expect((await wallet.getDefaultAddress()).deployMultiToken).toHaveBeenCalledTimes(1);
            expect((await wallet.getDefaultAddress()).deployMultiToken).toHaveBeenCalledWith(options);
            expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
            expect(smartContract).toEqual(expectedSmartContract);
        });
    });
    describe("#deployContract", () => {
        let expectedSmartContract;
        let options = {
            solidityVersion: "0.8.0",
            solidityInputJson: "{}",
            contractName: "TestContract",
            constructorArgs: ["arg1", "arg2"],
        };
        beforeEach(async () => {
            expectedSmartContract = smart_contract_1.SmartContract.fromModel(utils_1.VALID_SMART_CONTRACT_CUSTOM_MODEL);
            (await wallet.getDefaultAddress()).deployContract = jest
                .fn()
                .mockResolvedValue(expectedSmartContract);
        });
        it("successfully deploys a custom contract on the default address", async () => {
            const smartContract = await wallet.deployContract(options);
            expect((await wallet.getDefaultAddress()).deployContract).toHaveBeenCalledTimes(1);
            expect((await wallet.getDefaultAddress()).deployContract).toHaveBeenCalledWith(options);
            expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
            expect(smartContract).toEqual(expectedSmartContract);
        });
    });
    describe("#createPayloadSignature", () => {
        let unsignedPayload = utils_1.VALID_SIGNED_PAYLOAD_SIGNATURE_MODEL.unsigned_payload;
        let signature = "0xa4e14b28d86dfd7bae739d724ba2ffb13b4458d040930b805eea0a4bc2f5251e7901110677d1ef2ec23ef810c755d0bc72cc6472a4cfb3c53ef242c6ba9fa60a1b";
        beforeAll(() => {
            coinbase_1.Coinbase.apiClients.address = utils_1.addressesApiMock;
        });
        beforeEach(() => {
            jest.clearAllMocks();
        });
        it("should successfully create a payload signature", async () => {
            coinbase_1.Coinbase.apiClients.address.createPayloadSignature = (0, utils_1.mockReturnValue)(utils_1.VALID_SIGNED_PAYLOAD_SIGNATURE_MODEL);
            const payloadSignature = await wallet.createPayloadSignature(unsignedPayload);
            expect(coinbase_1.Coinbase.apiClients.address.createPayloadSignature).toHaveBeenCalledWith(wallet.getId(), (await wallet.getDefaultAddress()).getId(), {
                unsigned_payload: unsignedPayload,
                signature,
            });
            expect(coinbase_1.Coinbase.apiClients.address.createPayloadSignature).toHaveBeenCalledTimes(1);
            expect(payloadSignature).toBeInstanceOf(payload_signature_1.PayloadSignature);
        });
        it("should throw an APIError when the API call to create a payload signature fails", async () => {
            coinbase_1.Coinbase.apiClients.address.createPayloadSignature = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError("Failed to create payload signature"));
            expect(async () => {
                await wallet.createPayloadSignature(unsignedPayload);
            }).rejects.toThrow(Error);
            expect(coinbase_1.Coinbase.apiClients.address.createPayloadSignature).toHaveBeenCalledWith(wallet.getId(), (await wallet.getDefaultAddress()).getId(), {
                unsigned_payload: unsignedPayload,
                signature,
            });
            expect(coinbase_1.Coinbase.apiClients.address.createPayloadSignature).toHaveBeenCalledTimes(1);
        });
    });
    describe(".create", () => {
        beforeEach(() => { });
        it("should return a Wallet instance", async () => {
            expect(wallet).toBeInstanceOf(wallet_1.Wallet);
        });
        describe("#getId", () => {
            it("should return the correct wallet ID", async () => {
                expect(wallet.getId()).toBe(walletModel.id);
            });
        });
        describe("#getNetworkId", () => {
            let wallet;
            let network_id;
            let createWalletParams;
            beforeEach(async () => {
                coinbase_1.Coinbase.apiClients.wallet = utils_1.walletsApiMock;
                coinbase_1.Coinbase.apiClients.address = utils_1.addressesApiMock;
                coinbase_1.Coinbase.apiClients.wallet.createWallet = (0, utils_1.mockReturnValue)({
                    ...utils_1.VALID_WALLET_MODEL,
                    network_id,
                    server_signer_status: types_1.ServerSignerStatus.PENDING,
                });
                coinbase_1.Coinbase.apiClients.wallet.getWallet = (0, utils_1.mockReturnValue)({
                    ...utils_1.VALID_WALLET_MODEL,
                    network_id,
                    server_signer_status: types_1.ServerSignerStatus.ACTIVE,
                });
                coinbase_1.Coinbase.apiClients.address.createAddress = (0, utils_1.mockReturnValue)((0, utils_1.newAddressModel)(walletId));
                wallet = await wallet_1.Wallet.create(createWalletParams);
            });
            describe("when a network is specified", () => {
                beforeAll(() => {
                    network_id = coinbase_1.Coinbase.networks.BaseMainnet;
                    createWalletParams = { networkId: network_id };
                });
                it("it creates a wallet scoped to the specified network", () => {
                    expect(wallet.getNetworkId()).toBe(coinbase_1.Coinbase.networks.BaseMainnet);
                });
            });
            describe("when no network is specified", () => {
                beforeAll(() => {
                    network_id = coinbase_1.Coinbase.networks.BaseSepolia;
                    createWalletParams = {};
                });
                it("it creates a wallet scoped to the default network", () => {
                    expect(wallet.getNetworkId()).toBe(coinbase_1.Coinbase.networks.BaseSepolia);
                });
            });
        });
        describe("#getDefaultAddress", () => {
            it("should return the correct default address", async () => {
                expect((await wallet.getDefaultAddress()).getId()).toBe(walletModel.default_address.address_id);
            });
        });
        it("should return true for canSign when the wallet is initialized without a seed", async () => {
            expect(wallet.canSign()).toBe(true);
        });
        it("should throw Error if derived key is not valid", async () => {
            coinbase_1.Coinbase.apiClients.address.listAddresses = (0, utils_1.mockFn)(() => {
                return {
                    data: {
                        data: [utils_1.VALID_ADDRESS_MODEL],
                        has_more: false,
                        next_page: "",
                        total_count: 1,
                    },
                };
            });
            await expect(wallet.listAddresses()).rejects.toThrow(Error);
        });
        it("should create new address and update the existing address list", async () => {
            const [addressList0] = (0, utils_1.mockListAddress)(existingSeed, 1);
            let addresses = await wallet.listAddresses();
            expect(addresses.length).toBe(1);
            coinbase_1.Coinbase.apiClients.address.createAddress = (0, utils_1.mockReturnValue)(addressList0);
            const newAddress = await wallet.createAddress();
            expect(newAddress).toBeInstanceOf(wallet_address_1.WalletAddress);
            (0, utils_1.mockListAddress)(existingSeed, 2);
            addresses = await wallet.listAddresses();
            expect(addresses.length).toBe(2);
            expect((await wallet.getAddress(newAddress.getId())).getId()).toBe(newAddress.getId());
            expect(coinbase_1.Coinbase.apiClients.address.createAddress).toHaveBeenCalledTimes(1);
        });
        describe("when using a server signer", () => {
            const walletId = crypto_1.default.randomUUID();
            let wallet;
            beforeEach(async () => {
                jest.clearAllMocks();
                coinbase_1.Coinbase.useServerSigner = true;
            });
            it("should return a Wallet instance", async () => {
                coinbase_1.Coinbase.apiClients.wallet.createWallet = (0, utils_1.mockReturnValue)({
                    ...utils_1.VALID_WALLET_MODEL,
                    server_signer_status: types_1.ServerSignerStatus.PENDING,
                });
                coinbase_1.Coinbase.apiClients.wallet.getWallet = (0, utils_1.mockReturnValue)({
                    ...utils_1.VALID_WALLET_MODEL,
                    server_signer_status: types_1.ServerSignerStatus.ACTIVE,
                });
                coinbase_1.Coinbase.apiClients.address.createAddress = (0, utils_1.mockReturnValue)((0, utils_1.newAddressModel)(walletId));
                wallet = await wallet_1.Wallet.create();
                expect(wallet).toBeInstanceOf(wallet_1.Wallet);
                expect(wallet.getServerSignerStatus()).toBe(types_1.ServerSignerStatus.ACTIVE);
                expect(coinbase_1.Coinbase.apiClients.wallet.createWallet).toHaveBeenCalledTimes(1);
                expect(coinbase_1.Coinbase.apiClients.wallet.getWallet).toHaveBeenCalledTimes(2);
                expect(coinbase_1.Coinbase.apiClients.address.createAddress).toHaveBeenCalledTimes(1);
            });
            it("should throw an Error if the Wallet times out waiting on a not active server signer", async () => {
                const intervalSeconds = 0.000002;
                const timeoutSeconds = 0.000002;
                coinbase_1.Coinbase.apiClients.wallet.getWallet = (0, utils_1.mockReturnValue)({
                    ...utils_1.VALID_WALLET_MODEL,
                    server_signer_status: types_1.ServerSignerStatus.PENDING,
                });
                await expect(wallet_1.Wallet.create({ timeoutSeconds, intervalSeconds })).rejects.toThrow("Wallet creation timed out. Check status of your Server-Signer");
                expect(coinbase_1.Coinbase.apiClients.wallet.createWallet).toHaveBeenCalledTimes(1);
                expect(coinbase_1.Coinbase.apiClients.wallet.getWallet).toHaveBeenCalled();
            });
        });
    });
    describe(".init", () => {
        let wallet;
        let addressList;
        let walletModel;
        const existingSeed = "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f";
        const { address1, address2, address3, wallet1PrivateKey, wallet2PrivateKey } = (0, utils_1.generateWalletFromSeed)(existingSeed, 3);
        beforeEach(async () => {
            jest.clearAllMocks();
            addressList = [
                {
                    address_id: address1,
                    network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                    public_key: wallet1PrivateKey,
                    wallet_id: walletId,
                    index: 0,
                },
                {
                    address_id: address2,
                    network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                    public_key: wallet2PrivateKey,
                    wallet_id: walletId,
                    index: 1,
                },
            ];
            walletModel = {
                id: walletId,
                network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                default_address: addressList[0],
                feature_set: {},
            };
            wallet = wallet_1.Wallet.init(walletModel, existingSeed);
            coinbase_1.Coinbase.apiClients.address.createAddress = (0, utils_1.mockFn)(walletId => {
                return {
                    data: {
                        id: walletId,
                        network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                        default_address: (0, utils_1.newAddressModel)(walletId),
                    },
                };
            });
            coinbase_1.Coinbase.apiClients.address.listAddresses = (0, utils_1.mockFn)(() => {
                return {
                    data: {
                        data: addressList,
                    },
                };
            });
        });
        it("should return a Wallet instance", async () => {
            expect(wallet).toBeInstanceOf(wallet_1.Wallet);
        });
        it("should return the correct wallet ID", async () => {
            expect(wallet.getId()).toBe(walletModel.id);
        });
        it("should return the correct network ID", async () => {
            expect(wallet.getNetworkId()).toBe(coinbase_1.Coinbase.networks.BaseSepolia);
        });
        it("should derive the correct number of addresses", async () => {
            const addresses = await wallet.listAddresses();
            expect(addresses.length).toBe(2);
        });
        it("should create new address and update the existing address list", async () => {
            (0, utils_1.mockListAddress)(existingSeed, 2);
            let addresses = await wallet.listAddresses();
            expect(addresses.length).toBe(2);
            const [, , lastAddress] = (0, utils_1.mockListAddress)(existingSeed, 3);
            coinbase_1.Coinbase.apiClients.address.createAddress = (0, utils_1.mockReturnValue)(lastAddress);
            const newAddress = await wallet.createAddress();
            expect(newAddress).toBeInstanceOf(wallet_address_1.WalletAddress);
            addresses = await wallet.listAddresses();
            expect(addresses.length).toBe(3);
            expect((await wallet.getAddress(newAddress.getId())).getId()).toBe(newAddress.getId());
        });
        it("should return the correct string representation", async () => {
            expect(wallet.toString()).toBe(`Wallet{id: '${walletModel.id}', networkId: '${coinbase_1.Coinbase.networks.BaseSepolia}'}`);
        });
        it("should raise an error when the seed is invalid", async () => {
            const newWallet = wallet_1.Wallet.init(walletModel, "");
            expect(() => newWallet.setSeed(``)).toThrow(errors_1.ArgumentError);
            expect(() => newWallet.setSeed(`invalid-seed`)).toThrow(errors_1.ArgumentError);
        });
    });
    describe("#export", () => {
        let walletId;
        let addressModel;
        let walletModel;
        let seedWallet;
        const seed = "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f";
        beforeAll(async () => {
            walletId = crypto_1.default.randomUUID();
            addressModel = (0, utils_1.newAddressModel)(walletId);
            walletModel = {
                id: walletId,
                network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                default_address: addressModel,
                feature_set: {},
            };
            coinbase_1.Coinbase.apiClients.address = utils_1.addressesApiMock;
            coinbase_1.Coinbase.apiClients.address.getAddress = (0, utils_1.mockFn)(() => {
                return { data: addressModel };
            });
            seedWallet = wallet_1.Wallet.init(walletModel, seed);
        });
        it("exports the Wallet data", () => {
            const walletData = seedWallet.export();
            expect(walletData.walletId).toBe(seedWallet.getId());
            expect(walletData.seed).toBe(seed);
        });
        it("allows for re-creation of a Wallet", async () => {
            const walletData = seedWallet.export();
            const newWallet = wallet_1.Wallet.init(walletModel, walletData.seed);
            expect(newWallet).toBeInstanceOf(wallet_1.Wallet);
        });
        it("throws an error when the Wallet is seedless", async () => {
            const seedlessWallet = wallet_1.Wallet.init(walletModel, "");
            expect(() => seedlessWallet.export()).toThrow(Error);
        });
        it("should return true for canSign when the wallet is initialized with a seed", () => {
            expect(wallet.canSign()).toBe(true);
        });
        it("should be able to be imported", async () => {
            const walletData = seedWallet.export();
            const importedWallet = await wallet_1.Wallet.import(walletData);
            expect(importedWallet).toBeInstanceOf(wallet_1.Wallet);
            expect(coinbase_1.Coinbase.apiClients.address.listAddresses).toHaveBeenCalledTimes(1);
        });
        it("should throw an error when walletId is not provided", async () => {
            const walletData = seedWallet.export();
            walletData.walletId = "";
            await expect(async () => await wallet_1.Wallet.import(walletData)).rejects.toThrow("Wallet ID must be provided");
        });
        it("should throw an error when seed is not provided", async () => {
            const walletData = seedWallet.export();
            walletData.seed = "";
            await expect(async () => await wallet_1.Wallet.import(walletData)).rejects.toThrow("Seed must be provided");
        });
        it("should throw an error when both walletId and wallet_id are provided", async () => {
            const walletData = seedWallet.export();
            walletData.wallet_id = walletData.walletId;
            await expect(async () => await wallet_1.Wallet.import(walletData)).rejects.toThrow("Invalid import data format");
        });
        it("should throw an error when wallet data format is invalid", async () => {
            const invalidWalletData = {
                foo: "bar",
                bar: 123,
            };
            await expect(async () => await wallet_1.Wallet.import(invalidWalletData)).rejects.toThrow("Invalid import data format");
        });
    });
    describe("#importFromMnemonicSeedPhrase", () => {
        const validMnemonic = "crouch cereal notice one canyon kiss tape employ ghost column vanish despair eight razor laptop keen rally gaze riot regret assault jacket risk curve";
        const address0 = "0x43A0477E658C6e05136e81C576CF02daCEa067bB";
        const publicKey = "0x037e6cbdd1d949f60f41d5db7ffa9b3ddce0b77eab35ef7affd3f64cbfd9e33a91";
        const addressModel = {
            ...utils_1.VALID_ADDRESS_MODEL,
            address_id: address0,
            public_key: publicKey,
        };
        beforeEach(() => {
            jest.clearAllMocks();
            coinbase_1.Coinbase.apiClients.wallet = utils_1.walletsApiMock;
            coinbase_1.Coinbase.apiClients.address = utils_1.addressesApiMock;
            coinbase_1.Coinbase.apiClients.wallet.createWallet = (0, utils_1.mockFn)(request => {
                const { network_id } = request.wallet;
                apiResponses[walletId] = {
                    id: walletId,
                    network_id,
                    default_address: addressModel,
                };
                return { data: apiResponses[walletId] };
            });
            coinbase_1.Coinbase.apiClients.wallet.getWallet = (0, utils_1.mockFn)(walletId => {
                walletModel = apiResponses[walletId];
                walletModel.default_address.address_id = address0;
                return { data: apiResponses[walletId] };
            });
            coinbase_1.Coinbase.apiClients.address.createAddress = (0, utils_1.mockReturnValue)(addressModel);
            coinbase_1.Coinbase.apiClients.address.listAddresses = (0, utils_1.mockFn)(() => {
                return {
                    data: {
                        data: [addressModel],
                        has_more: false,
                        next_page: "",
                        total_count: 1,
                    },
                };
            });
        });
        it("successfully imports a wallet from a valid 24-word mnemonic", async () => {
            const wallet = await wallet_1.Wallet.import({ mnemonicPhrase: validMnemonic });
            expect(wallet).toBeInstanceOf(wallet_1.Wallet);
            expect(coinbase_1.Coinbase.apiClients.wallet.createWallet).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.address.createAddress).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.address.listAddresses).toHaveBeenCalledTimes(1);
        });
        it("successfully imports a wallet from a valid 24-word mnemonic on base-mainnet", async () => {
            const wallet = await wallet_1.Wallet.import({ mnemonicPhrase: validMnemonic }, coinbase_1.Coinbase.networks.BaseMainnet);
            expect(wallet).toBeInstanceOf(wallet_1.Wallet);
            expect(wallet.getNetworkId()).toEqual(coinbase_1.Coinbase.networks.BaseMainnet);
            expect(coinbase_1.Coinbase.apiClients.wallet.createWallet).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.address.createAddress).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.address.listAddresses).toHaveBeenCalledTimes(1);
        });
        it("throws an error when mnemonic is empty", async () => {
            await expect(wallet_1.Wallet.import({ mnemonicPhrase: "" })).rejects.toThrow("BIP-39 mnemonic seed phrase must be provided");
            expect(coinbase_1.Coinbase.apiClients.wallet.createWallet).not.toHaveBeenCalled();
        });
        it("throws an error when mnemonic is invalid", async () => {
            await expect(wallet_1.Wallet.import({ mnemonicPhrase: "invalid mnemonic phrase" })).rejects.toThrow("Invalid BIP-39 mnemonic seed phrase");
            expect(coinbase_1.Coinbase.apiClients.wallet.createWallet).not.toHaveBeenCalled();
        });
    });
    describe("#listBalances", () => {
        beforeEach(() => {
            jest.clearAllMocks();
            const mockBalanceResponse = {
                data: [
                    {
                        amount: "1000000000000000000",
                        asset: {
                            asset_id: coinbase_1.Coinbase.assets.Eth,
                            network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                            decimals: 18,
                        },
                    },
                    {
                        amount: "5000000",
                        asset: {
                            asset_id: "usdc",
                            network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                            decimals: 6,
                        },
                    },
                ],
                has_more: false,
                next_page: "",
                total_count: 2,
            };
            coinbase_1.Coinbase.apiClients.wallet.listWalletBalances = (0, utils_1.mockReturnValue)(mockBalanceResponse);
        });
        it("should return a hash with an ETH and USDC balance", async () => {
            (0, utils_1.mockListAddress)(existingSeed, 3);
            const balanceMap = await wallet.listBalances();
            expect(balanceMap.get("eth")).toEqual(new decimal_js_1.default(1));
            expect(balanceMap.get("usdc")).toEqual(new decimal_js_1.default(5));
            expect(coinbase_1.Coinbase.apiClients.wallet.listWalletBalances).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.wallet.listWalletBalances).toHaveBeenCalledWith(wallet.getId());
        });
    });
    describe("#getBalance", () => {
        beforeEach(() => {
            const mockWalletBalance = {
                amount: "5000000000000000000",
                asset: {
                    asset_id: coinbase_1.Coinbase.assets.Eth,
                    network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                    decimals: 18,
                },
            };
            coinbase_1.Coinbase.apiClients.wallet.getWalletBalance = (0, utils_1.mockReturnValue)(mockWalletBalance);
        });
        it("should return the correct ETH balance", async () => {
            const balanceMap = await wallet.getBalance(coinbase_1.Coinbase.assets.Eth);
            expect(balanceMap).toEqual(new decimal_js_1.default(5));
            expect(coinbase_1.Coinbase.apiClients.wallet.getWalletBalance).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.wallet.getWalletBalance).toHaveBeenCalledWith(wallet.getId(), coinbase_1.Coinbase.assets.Eth);
        });
        it("should return the correct GWEI balance", async () => {
            const balance = await wallet.getBalance(coinbase_1.Coinbase.assets.Gwei);
            expect(balance).toEqual(new decimal_js_1.default(5000000000));
            expect(coinbase_1.Coinbase.apiClients.wallet.getWalletBalance).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.wallet.getWalletBalance).toHaveBeenCalledWith(wallet.getId(), coinbase_1.Coinbase.assets.Eth);
        });
        it("should return the correct WEI balance", async () => {
            const balance = await wallet.getBalance(coinbase_1.Coinbase.assets.Wei);
            expect(balance).toEqual(new decimal_js_1.default(5000000000000000000));
            expect(coinbase_1.Coinbase.apiClients.wallet.getWalletBalance).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.wallet.getWalletBalance).toHaveBeenCalledWith(wallet.getId(), coinbase_1.Coinbase.assets.Eth);
        });
        it("should return 0 when the balance is not found", async () => {
            coinbase_1.Coinbase.apiClients.wallet.getWalletBalance = (0, utils_1.mockReturnValue)({});
            const balance = await wallet.getBalance(coinbase_1.Coinbase.assets.Wei);
            expect(balance).toEqual(new decimal_js_1.default(0));
            expect(coinbase_1.Coinbase.apiClients.wallet.getWalletBalance).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.wallet.getWalletBalance).toHaveBeenCalledWith(wallet.getId(), coinbase_1.Coinbase.assets.Eth);
        });
    });
    describe("#canSign", () => {
        let wallet;
        beforeAll(async () => {
            const mockAddressModel = (0, utils_1.newAddressModel)(walletId);
            const mockWalletModel = {
                id: walletId,
                default_address: mockAddressModel,
                network_id: coinbase_1.Coinbase.networks.BaseSepolia,
            };
            coinbase_1.Coinbase.apiClients.wallet = utils_1.walletsApiMock;
            coinbase_1.Coinbase.apiClients.address = utils_1.addressesApiMock;
            coinbase_1.Coinbase.apiClients.wallet.createWallet = (0, utils_1.mockReturnValue)(mockWalletModel);
            coinbase_1.Coinbase.apiClients.wallet.getWallet = (0, utils_1.mockReturnValue)(mockWalletModel);
            coinbase_1.Coinbase.apiClients.address.createAddress = (0, utils_1.mockReturnValue)(mockAddressModel);
            wallet = await wallet_1.Wallet.create();
        });
        it("should return true when the wallet initialized", () => {
            expect(wallet.canSign()).toBe(true);
        });
    });
    describe("should change the network ID", () => {
        let wallet;
        beforeAll(async () => {
            coinbase_1.Coinbase.apiClients.wallet = utils_1.walletsApiMock;
            coinbase_1.Coinbase.apiClients.address = utils_1.addressesApiMock;
            coinbase_1.Coinbase.apiClients.wallet.createWallet = (0, utils_1.mockReturnValue)({
                ...utils_1.VALID_WALLET_MODEL,
                network_id: coinbase_1.Coinbase.networks.BaseMainnet,
                server_signer_status: types_1.ServerSignerStatus.PENDING,
            });
            coinbase_1.Coinbase.apiClients.wallet.getWallet = (0, utils_1.mockReturnValue)({
                ...utils_1.VALID_WALLET_MODEL,
                network_id: coinbase_1.Coinbase.networks.BaseMainnet,
                server_signer_status: types_1.ServerSignerStatus.ACTIVE,
            });
            coinbase_1.Coinbase.apiClients.address.createAddress = (0, utils_1.mockReturnValue)((0, utils_1.newAddressModel)(walletId));
            wallet = await wallet_1.Wallet.create({
                networkId: coinbase_1.Coinbase.networks.BaseMainnet,
            });
        });
        it("should return true when the wallet initialized", () => {
            expect(wallet.getNetworkId()).toBe(coinbase_1.Coinbase.networks.BaseMainnet);
        });
    });
    describe("#saveSeed", () => {
        const seed = "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f";
        let apiPrivateKey;
        const filePath = "seeds.json";
        let seedWallet;
        beforeEach(async () => {
            apiPrivateKey = coinbase_1.Coinbase.apiKeyPrivateKey;
            coinbase_1.Coinbase.apiKeyPrivateKey = crypto_1.default.generateKeyPairSync("ec", {
                namedCurve: "prime256v1",
                privateKeyEncoding: { type: "pkcs8", format: "pem" },
                publicKeyEncoding: { type: "spki", format: "pem" },
            }).privateKey;
            fs.writeFileSync(filePath, JSON.stringify({}), "utf8");
            seedWallet = wallet_1.Wallet.init(walletModel, seed);
        });
        afterEach(async () => {
            fs.unlinkSync(filePath);
            coinbase_1.Coinbase.apiKeyPrivateKey = apiPrivateKey;
        });
        it("should save the seed when encryption is false", async () => {
            seedWallet.saveSeedToFile(filePath, false);
            const storedSeedData = fs.readFileSync(filePath);
            const walletSeedData = JSON.parse(storedSeedData.toString());
            expect(walletSeedData[walletId].encrypted).toBe(false);
            expect(walletSeedData[walletId].iv).toBe("");
            expect(walletSeedData[walletId].authTag).toBe("");
            expect(walletSeedData[walletId].seed).toBe(seed);
            expect(walletSeedData[walletId].networkId).toBe(seedWallet.getNetworkId());
        });
        it("should save the seed when encryption is true", async () => {
            seedWallet.saveSeedToFile(filePath, true);
            const storedSeedData = fs.readFileSync(filePath);
            const walletSeedData = JSON.parse(storedSeedData.toString());
            expect(walletSeedData[walletId].encrypted).toBe(true);
            expect(walletSeedData[walletId].iv).not.toBe("");
            expect(walletSeedData[walletId].authTag).not.toBe("");
            expect(walletSeedData[walletId].seed).not.toBe(seed);
        });
        it("should throw an error when the wallet is seedless", async () => {
            const seedlessWallet = wallet_1.Wallet.init(walletModel, "");
            expect(() => seedlessWallet.saveSeedToFile(filePath, false)).toThrow(Error);
        });
    });
    describe("#loadSeed", () => {
        const seed = "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f";
        let apiPrivateKey;
        const filePath = "seeds.json";
        let seedWallet;
        let seedlessWallet;
        beforeEach(async () => {
            apiPrivateKey = coinbase_1.Coinbase.apiKeyPrivateKey;
            coinbase_1.Coinbase.apiKeyPrivateKey = crypto_1.default.generateKeyPairSync("ec", {
                namedCurve: "prime256v1",
                privateKeyEncoding: { type: "pkcs8", format: "pem" },
                publicKeyEncoding: { type: "spki", format: "pem" },
            }).privateKey;
            const initialSeedData = {
                [walletId]: {
                    encrypted: false,
                    iv: "",
                    authTag: "",
                    seed,
                },
            };
            fs.writeFileSync(filePath, JSON.stringify(initialSeedData), "utf8");
            seedWallet = wallet_1.Wallet.init(walletModel, seed);
            seedlessWallet = wallet_1.Wallet.init(walletModel, "");
        });
        afterEach(async () => {
            fs.unlinkSync(filePath);
            coinbase_1.Coinbase.apiKeyPrivateKey = apiPrivateKey;
        });
        it("loads the seed from the file", async () => {
            await seedlessWallet.loadSeedFromFile(filePath);
            expect(seedlessWallet.canSign()).toBe(true);
        });
        it("loads the encrypted seed from the file", async () => {
            seedWallet.saveSeedToFile(filePath, true);
            await seedlessWallet.loadSeedFromFile(filePath);
            expect(seedlessWallet.canSign()).toBe(true);
        });
        it("loads the encrypted seed from the file with multiple seeds", async () => {
            seedWallet.saveSeedToFile(filePath, true);
            const otherModel = {
                id: crypto_1.default.randomUUID(),
                network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                feature_set: {},
            };
            const randomSeed = ethers_1.ethers.Wallet.createRandom().privateKey.slice(2);
            const otherWallet = wallet_1.Wallet.init(otherModel, randomSeed);
            otherWallet.saveSeedToFile(filePath, true);
            await seedlessWallet.loadSeedFromFile(filePath);
            expect(seedlessWallet.canSign()).toBe(true);
        });
        it("raises an error if the wallet is already hydrated", async () => {
            await expect(seedWallet.loadSeedFromFile(filePath)).rejects.toThrow(Error);
        });
        it("raises an error when file contains different wallet data", async () => {
            const otherSeedData = {
                [crypto_1.default.randomUUID()]: {
                    encrypted: false,
                    iv: "",
                    authTag: "",
                    seed,
                },
            };
            fs.writeFileSync(filePath, JSON.stringify(otherSeedData), "utf8");
            await expect(seedlessWallet.loadSeedFromFile(filePath)).rejects.toThrow(errors_1.ArgumentError);
        });
        it("raises an error when the file is absent", async () => {
            await expect(seedlessWallet.loadSeedFromFile("non-file.json")).rejects.toThrow(errors_1.ArgumentError);
        });
        it("raises an error when the file is corrupted", async () => {
            fs.writeFileSync(filePath, "corrupted data", "utf8");
            await expect(seedlessWallet.loadSeedFromFile(filePath)).rejects.toThrow(errors_1.ArgumentError);
        });
        it("throws an error when the file is empty", async () => {
            fs.writeFileSync("invalid-file.json", "", "utf8");
            await expect(wallet.loadSeedFromFile("invalid-file.json")).rejects.toThrow(errors_1.ArgumentError);
            fs.unlinkSync("invalid-file.json");
        });
        it("throws an error when the file is not a valid JSON", async () => {
            fs.writeFileSync("invalid-file.json", `{"test":{"authTag":false}}`, "utf8");
            await expect(wallet.loadSeedFromFile("invalid-file.json")).rejects.toThrow(errors_1.ArgumentError);
            fs.unlinkSync("invalid-file.json");
        });
    });
    describe("#createTrade", () => {
        const tradeObject = new trade_1.Trade({
            network_id: coinbase_1.Coinbase.networks.BaseSepolia,
            wallet_id: walletId,
            address_id: utils_1.VALID_ADDRESS_MODEL.address_id,
            trade_id: crypto_1.default.randomUUID(),
            from_amount: "0.01",
            transaction: {
                network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                from_address_id: utils_1.VALID_ADDRESS_MODEL.address_id,
                unsigned_payload: "unsigned_payload",
                status: client_1.TransactionStatusEnum.Pending,
            },
        });
        it("should create a trade from the default address", async () => {
            const trade = Promise.resolve(tradeObject);
            jest.spyOn(wallet_1.Wallet.prototype, "createTrade").mockReturnValue(trade);
            const wallet = await wallet_1.Wallet.create();
            const result = await wallet.createTrade({
                amount: 0.01,
                fromAssetId: "eth",
                toAssetId: "usdc",
            });
            expect(result).toBeInstanceOf(trade_1.Trade);
            expect(result.getAddressId()).toBe(tradeObject.getAddressId());
            expect(result.getWalletId()).toBe(tradeObject.getWalletId());
            expect(result.getId()).toBe(tradeObject.getId());
        });
        it("should list trades for a given address", async () => {
            coinbase_1.Coinbase.apiClients.trade = utils_1.tradeApiMock;
            const listOfTrades = [tradeObject, tradeObject];
            coinbase_1.Coinbase.apiClients.trade.listTrades = (0, utils_1.mockFn)(() => {
                const object = listOfTrades.shift();
                return {
                    data: {
                        data: [object],
                        has_more: listOfTrades.length > 0,
                        next_page: listOfTrades.length > 0 ? "x" : "",
                        total_count: listOfTrades.length,
                    },
                };
            });
            const [address1] = await wallet.listAddresses();
            const tradeWallet = (await wallet.getAddress(address1.getId()));
            const paginationResponse = await tradeWallet.listTrades();
            const trades = paginationResponse.data;
            expect(trades[0]).toBeInstanceOf(trade_1.Trade);
            expect(trades.length).toBe(1);
        });
    });
    describe("#createWebhook", () => {
        let wallet;
        let addressList;
        let walletModel;
        const existingSeed = "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f";
        const { address1, address2, address3, wallet1PrivateKey, wallet2PrivateKey } = (0, utils_1.generateWalletFromSeed)(existingSeed, 3);
        beforeEach(async () => {
            jest.clearAllMocks();
            addressList = [
                {
                    address_id: address1,
                    network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                    public_key: wallet1PrivateKey,
                    wallet_id: "w1",
                    index: 0,
                },
                {
                    address_id: address2,
                    network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                    public_key: wallet2PrivateKey,
                    wallet_id: "w1",
                    index: 1,
                },
            ];
            walletModel = {
                id: "w1",
                network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                default_address: addressList[0],
                feature_set: {},
            };
            wallet = wallet_1.Wallet.init(walletModel, existingSeed);
        });
        const mockModel = {
            id: "test-id",
            network_id: "test-network",
            notification_uri: "https://example.com/callback",
            event_type: "wallet_activity",
            event_type_filter: { addresses: [address1], wallet_id: "w1" },
        };
        coinbase_1.Coinbase.apiClients.webhook = {
            createWalletWebhook: jest.fn().mockResolvedValue({ data: mockModel }),
            createWebhook: jest.fn().mockResolvedValue({ data: mockModel }),
            listWebhooks: jest.fn().mockResolvedValue({
                data: {
                    data: [mockModel],
                    has_more: false,
                    next_page: null,
                },
            }),
            updateWebhook: jest.fn().mockImplementation((id, updateRequest) => {
                return Promise.resolve({
                    data: {
                        ...mockModel,
                        notification_uri: updateRequest.notification_uri,
                    },
                });
            }),
            deleteWebhook: jest.fn().mockResolvedValue({}),
        };
        it("should create a webhook for the default address", async () => {
            const webhookObject = webhook_1.Webhook.init(mockModel);
            const wh = Promise.resolve(webhookObject);
            jest.spyOn(wallet_1.Wallet.prototype, "createWebhook").mockReturnValue(wh);
            const result = await wallet.createWebhook("https://example.com/callback");
            expect(result).toBeInstanceOf(webhook_1.Webhook);
            expect(result.getEventTypeFilter()?.wallet_id).toBe(walletModel.id);
            expect(result.getEventTypeFilter()?.addresses).toStrictEqual([address1]);
            expect(result.getEventType()).toBe("wallet_activity");
        });
    });
});
