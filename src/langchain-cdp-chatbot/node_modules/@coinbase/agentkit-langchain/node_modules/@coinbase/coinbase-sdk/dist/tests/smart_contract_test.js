"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const coinbase_1 = require("../coinbase/coinbase");
const utils_1 = require("./utils");
const smart_contract_1 = require("../coinbase/smart_contract");
const transaction_1 = require("../coinbase/transaction");
const ethers_1 = require("ethers");
const types_1 = require("../coinbase/types");
const api_error_1 = require("../coinbase/api_error");
const errors_1 = require("../coinbase/errors");
describe("SmartContract", () => {
    let erc20Model = utils_1.VALID_SMART_CONTRACT_ERC20_MODEL;
    let erc20ExternalModel = utils_1.VALID_EXTERNAL_SMART_CONTRACT_ERC20_MODEL;
    let erc721Model = utils_1.VALID_SMART_CONTRACT_ERC721_MODEL;
    let erc20SmartContract = smart_contract_1.SmartContract.fromModel(erc20Model);
    let erc20ExternalSmartContract = smart_contract_1.SmartContract.fromModel(erc20ExternalModel);
    let erc721SmartContract = smart_contract_1.SmartContract.fromModel(erc721Model);
    let erc1155Model = utils_1.VALID_SMART_CONTRACT_ERC1155_MODEL;
    let erc1155SmartContract = smart_contract_1.SmartContract.fromModel(erc1155Model);
    let externalModel = utils_1.VALID_SMART_CONTRACT_EXTERNAL_MODEL;
    let externalSmartContract = smart_contract_1.SmartContract.fromModel(externalModel);
    afterEach(() => {
        jest.clearAllMocks();
    });
    describe("Constructor", () => {
        it("initializes a new SmartContract", () => {
            expect(erc20SmartContract).toBeInstanceOf(smart_contract_1.SmartContract);
        });
        it("raises an error when the smartContract model is empty", () => {
            expect(() => smart_contract_1.SmartContract.fromModel(undefined)).toThrow("SmartContract model cannot be empty");
        });
    });
    describe(".register", () => {
        const networkId = erc20ExternalModel.network_id;
        const contractName = erc20ExternalModel.contract_name;
        const contractAddress = erc20ExternalModel.contract_address;
        it("should register a new smart contract", async () => {
            coinbase_1.Coinbase.apiClients.smartContract = utils_1.smartContractApiMock;
            coinbase_1.Coinbase.apiClients.smartContract.registerSmartContract = jest
                .fn()
                .mockResolvedValue({ data: erc20ExternalModel });
            const smartContract = await smart_contract_1.SmartContract.register({
                networkId: networkId,
                contractAddress: contractAddress,
                abi: utils_1.testAllReadTypesABI,
                contractName: contractName,
            });
            expect(coinbase_1.Coinbase.apiClients.smartContract.registerSmartContract).toHaveBeenCalledWith(networkId, contractAddress, {
                abi: JSON.stringify(utils_1.testAllReadTypesABI),
                contract_name: contractName,
            });
            expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
            expect(smartContract.getContractAddress()).toBe(contractAddress);
        });
        it("should throw an error if register fails", async () => {
            coinbase_1.Coinbase.apiClients.smartContract.registerSmartContract = jest
                .fn()
                .mockRejectedValue(new Error("Failed to register the smart contract"));
            await expect(smart_contract_1.SmartContract.register({
                networkId: networkId,
                contractAddress: contractAddress,
                abi: utils_1.testAllReadTypesABI,
                contractName: contractName,
            })).rejects.toThrow("Failed to register the smart contract");
        });
    });
    describe(".update", () => {
        const networkId = erc20ExternalModel.network_id;
        const contractAddress = erc20ExternalModel.contract_address;
        it("should update an existing smart contract", async () => {
            const updatedContract = JSON.parse(JSON.stringify(erc20ExternalModel));
            const updatedAbiJson = { abi: "data2" };
            updatedContract.contract_name = "UpdatedContractName";
            updatedContract.abi = JSON.stringify(updatedAbiJson);
            coinbase_1.Coinbase.apiClients.smartContract = utils_1.smartContractApiMock;
            coinbase_1.Coinbase.apiClients.smartContract.updateSmartContract = jest
                .fn()
                .mockResolvedValue({ data: updatedContract });
            const smartContract = await erc20ExternalSmartContract.update({
                abi: updatedAbiJson,
                contractName: updatedContract.contract_name,
            });
            expect(coinbase_1.Coinbase.apiClients.smartContract.updateSmartContract).toHaveBeenCalledWith(networkId, contractAddress, {
                abi: updatedContract.abi,
                contract_name: updatedContract.contract_name,
            });
            expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
            expect(smartContract.getContractAddress()).toBe(contractAddress);
            expect(smartContract.getAbi()).toEqual(updatedAbiJson);
            expect(smartContract.getContractName()).toEqual(updatedContract.contract_name);
        });
        it("should update an existing smart contract - update contract name only", async () => {
            const updatedContract = JSON.parse(JSON.stringify(erc20ExternalModel));
            updatedContract.contract_name = "UpdatedContractName";
            coinbase_1.Coinbase.apiClients.smartContract = utils_1.smartContractApiMock;
            coinbase_1.Coinbase.apiClients.smartContract.updateSmartContract = jest
                .fn()
                .mockResolvedValue({ data: updatedContract });
            const smartContract = await erc20ExternalSmartContract.update({
                contractName: updatedContract.contract_name,
            });
            expect(coinbase_1.Coinbase.apiClients.smartContract.updateSmartContract).toHaveBeenCalledWith(networkId, contractAddress, {
                contract_name: updatedContract.contract_name,
                abi: undefined,
            });
            expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
            expect(smartContract.getContractAddress()).toBe(contractAddress);
            expect(smartContract.getAbi()).toEqual(erc20ExternalSmartContract.getAbi());
            expect(smartContract.getContractName()).toEqual(updatedContract.contract_name);
        });
        it("should update an existing smart contract - update abi only", async () => {
            const updatedContract = JSON.parse(JSON.stringify(erc20ExternalModel));
            const updatedAbiJson = { abi: "data2" };
            updatedContract.abi = JSON.stringify(updatedAbiJson);
            coinbase_1.Coinbase.apiClients.smartContract = utils_1.smartContractApiMock;
            coinbase_1.Coinbase.apiClients.smartContract.updateSmartContract = jest
                .fn()
                .mockResolvedValue({ data: updatedContract });
            const smartContract = await erc20ExternalSmartContract.update({ abi: updatedAbiJson });
            expect(coinbase_1.Coinbase.apiClients.smartContract.updateSmartContract).toHaveBeenCalledWith(networkId, contractAddress, {
                contract_name: undefined,
                abi: updatedContract.abi,
            });
            expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
            expect(smartContract.getContractAddress()).toBe(contractAddress);
            expect(smartContract.getAbi()).toEqual(updatedAbiJson);
            expect(smartContract.getContractName()).toEqual(erc20ExternalSmartContract.getContractName());
        });
        it("should update an existing smart contract - no update", async () => {
            coinbase_1.Coinbase.apiClients.smartContract = utils_1.smartContractApiMock;
            coinbase_1.Coinbase.apiClients.smartContract.updateSmartContract = jest
                .fn()
                .mockResolvedValue({ data: erc20ExternalModel });
            const smartContract = await erc20ExternalSmartContract.update({});
            expect(coinbase_1.Coinbase.apiClients.smartContract.updateSmartContract).toHaveBeenCalledWith(networkId, contractAddress, {});
            expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
            expect(smartContract.getContractAddress()).toBe(contractAddress);
            expect(smartContract.getAbi()).toEqual(erc20ExternalSmartContract.getAbi());
            expect(smartContract.getContractName()).toEqual(erc20ExternalSmartContract.getContractName());
        });
        it("should throw an error if update fails", async () => {
            coinbase_1.Coinbase.apiClients.smartContract.updateSmartContract = jest
                .fn()
                .mockRejectedValue(new Error("Failed to update the smart contract"));
            await expect(erc20ExternalSmartContract.update({
                abi: utils_1.testAllReadTypesABI,
                contractName: erc20ExternalSmartContract.getContractName(),
            })).rejects.toThrow("Failed to update the smart contract");
        });
    });
    describe(".list", () => {
        it("should list smart contracts", async () => {
            coinbase_1.Coinbase.apiClients.smartContract = utils_1.smartContractApiMock;
            coinbase_1.Coinbase.apiClients.smartContract.listSmartContracts = jest.fn().mockResolvedValue({
                data: {
                    data: [erc20ExternalModel],
                    has_more: true,
                    next_page: null,
                },
            });
            const paginationResponse = await smart_contract_1.SmartContract.list();
            const smartContracts = paginationResponse.data;
            expect(coinbase_1.Coinbase.apiClients.smartContract.listSmartContracts).toHaveBeenCalledWith(undefined);
            expect(smartContracts.length).toBe(1);
            expect(smartContracts[0].getContractAddress()).toBe(erc20ExternalModel.contract_address);
            expect(paginationResponse.hasMore).toBe(true);
            expect(paginationResponse.nextPage).toBe(undefined);
        });
        it("should throw an error if list fails", async () => {
            coinbase_1.Coinbase.apiClients.smartContract.listSmartContracts = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError(""));
            await expect(smart_contract_1.SmartContract.list()).rejects.toThrow(api_error_1.APIError);
        });
    });
    describe("#getId", () => {
        it("returns the smart contract ID", () => {
            expect(erc20SmartContract.getId()).toEqual(utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.smart_contract_id);
        });
    });
    describe("#getNetworkId", () => {
        it("returns the smart contract network ID", () => {
            expect(erc20SmartContract.getNetworkId()).toEqual(utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.network_id);
        });
    });
    describe("#getContractAddress", () => {
        it("returns the smart contract contract address", () => {
            expect(erc20SmartContract.getContractAddress()).toEqual(utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.contract_address);
        });
    });
    describe("#getWalletId", () => {
        it("returns the smart contract wallet ID", () => {
            expect(erc20SmartContract.getWalletId()).toEqual(utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.wallet_id);
        });
        it("returns undefined for external contracts", () => {
            expect(externalSmartContract.getWalletId()).toBeUndefined();
        });
    });
    describe("#getDeployerAddress", () => {
        it("returns the smart contract deployer address", () => {
            expect(erc20SmartContract.getDeployerAddress()).toEqual(utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.deployer_address);
        });
        it("returns undefined for external contracts", () => {
            expect(externalSmartContract.getDeployerAddress()).toBeUndefined();
        });
    });
    describe("#getType", () => {
        it("returns the smart contract type for ERC20", () => {
            expect(erc20SmartContract.getType()).toEqual(utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.type);
        });
        it("returns the smart contract type for ERC721", () => {
            expect(erc721SmartContract.getType()).toEqual(utils_1.VALID_SMART_CONTRACT_ERC721_MODEL.type);
        });
        it("returns the smart contract type for ERC1155", () => {
            expect(erc1155SmartContract.getType()).toEqual(utils_1.VALID_SMART_CONTRACT_ERC1155_MODEL.type);
        });
    });
    describe("#getOptions", () => {
        it("returns the smart contract options for ERC20", () => {
            expect(erc20SmartContract.getOptions()).toEqual({
                name: utils_1.ERC20_NAME,
                symbol: utils_1.ERC20_SYMBOL,
                totalSupply: utils_1.ERC20_TOTAL_SUPPLY.toString(),
            });
        });
        it("returns the smart contract options for ERC721", () => {
            expect(erc721SmartContract.getOptions()).toEqual({
                name: utils_1.ERC721_NAME,
                symbol: utils_1.ERC721_SYMBOL,
                baseURI: utils_1.ERC721_BASE_URI,
            });
        });
        it("returns the smart contract options for ERC1155", () => {
            expect(erc1155SmartContract.getOptions()).toEqual({
                uri: utils_1.ERC1155_URI,
            });
        });
    });
    describe("#getAbi", () => {
        it("returns the smart contract ABI", () => {
            expect(erc20SmartContract.getAbi()).toEqual(JSON.parse(utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.abi));
        });
    });
    describe("#getTransaction", () => {
        it("returns the smart contract transaction", () => {
            expect(erc20SmartContract.getTransaction()).toEqual(new transaction_1.Transaction(utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.transaction));
        });
        it("returns undefined for external contracts", () => {
            expect(externalSmartContract.getTransaction()).toBeUndefined();
        });
    });
    describe("#sign", () => {
        let signingKey = ethers_1.ethers.Wallet.createRandom();
        it("returns the signature", async () => {
            const smartContract = smart_contract_1.SmartContract.fromModel({
                ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL,
                transaction: {
                    ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.transaction,
                    signed_payload: "0xsignedHash",
                },
            });
            const signature = await smartContract.sign(signingKey);
            expect(signature).toEqual(smartContract.getTransaction().getSignature());
        });
        it("throws an error for external contracts", async () => {
            expect(externalSmartContract.sign(signingKey)).rejects.toThrow("Cannot sign an external SmartContract");
        });
    });
    describe("#broadcast", () => {
        let signedPayload = "0xsignedHash";
        beforeEach(() => {
            coinbase_1.Coinbase.apiClients.smartContract = utils_1.smartContractApiMock;
            // Ensure signed payload is present.
            erc20SmartContract = smart_contract_1.SmartContract.fromModel({
                ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL,
                transaction: {
                    ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.transaction,
                    signed_payload: signedPayload,
                },
            });
        });
        describe("when it is successful", () => {
            let broadcastedSmartContract;
            beforeEach(async () => {
                coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract = (0, utils_1.mockReturnValue)({
                    ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL,
                    transaction: {
                        ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.transaction,
                        signed_payload: signedPayload,
                        status: types_1.TransactionStatus.BROADCAST,
                    },
                });
                broadcastedSmartContract = await erc20SmartContract.broadcast();
            });
            it("returns the broadcasted smart contract", async () => {
                expect(broadcastedSmartContract).toBeInstanceOf(smart_contract_1.SmartContract);
                expect(broadcastedSmartContract.getTransaction().getStatus()).toEqual(types_1.TransactionStatus.BROADCAST);
            });
            it("broadcasts the smart contract", async () => {
                expect(coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract).toHaveBeenCalledWith(erc20SmartContract.getWalletId(), erc20SmartContract.getDeployerAddress(), erc20SmartContract.getId(), {
                    signed_payload: signedPayload.slice(2),
                });
                expect(coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract).toHaveBeenCalledTimes(1);
            });
        });
        describe("when the transaction is not signed", () => {
            beforeEach(() => {
                erc20SmartContract = smart_contract_1.SmartContract.fromModel(utils_1.VALID_SMART_CONTRACT_ERC20_MODEL);
            });
            it("throws an error", async () => {
                expect(erc20SmartContract.broadcast()).rejects.toThrow("Cannot broadcast unsigned SmartContract deployment");
            });
        });
        describe("when broadcasting fails", () => {
            beforeEach(() => {
                coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError({
                    response: {
                        status: 400,
                        data: {
                            code: "invalid_signed_payload",
                            message: "failed to broadcast contract invocation: invalid signed payload",
                        },
                    },
                }));
            });
            it("throws an error", async () => {
                expect(erc20SmartContract.broadcast()).rejects.toThrow(api_error_1.APIError);
            });
        });
        describe("when the contract is external", () => {
            it("throws an error", async () => {
                expect(externalSmartContract.broadcast()).rejects.toThrow("Cannot broadcast an external SmartContract");
            });
        });
    });
    describe("#wait", () => {
        describe("when the transaction is complete", () => {
            beforeEach(() => {
                coinbase_1.Coinbase.apiClients.smartContract.getSmartContract = (0, utils_1.mockReturnValue)({
                    ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL,
                    transaction: {
                        ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.transaction,
                        status: types_1.TransactionStatus.COMPLETE,
                    },
                });
            });
            it("successfully waits and returns", async () => {
                const completedSmartContract = await erc20SmartContract.wait();
                expect(completedSmartContract).toBeInstanceOf(smart_contract_1.SmartContract);
                expect(completedSmartContract.getTransaction().getStatus()).toEqual(types_1.TransactionStatus.COMPLETE);
            });
        });
        describe("when the transaction is failed", () => {
            beforeEach(() => {
                coinbase_1.Coinbase.apiClients.smartContract.getSmartContract = (0, utils_1.mockReturnValue)({
                    ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL,
                    transaction: {
                        ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.transaction,
                        status: types_1.TransactionStatus.FAILED,
                    },
                });
            });
            it("successfully waits and returns a failed invocation", async () => {
                const completedSmartContract = await erc20SmartContract.wait();
                expect(completedSmartContract).toBeInstanceOf(smart_contract_1.SmartContract);
                expect(completedSmartContract.getTransaction().getStatus()).toEqual(types_1.TransactionStatus.FAILED);
            });
        });
        describe("when the transaction is pending", () => {
            beforeEach(() => {
                coinbase_1.Coinbase.apiClients.smartContract.getSmartContract = (0, utils_1.mockReturnValue)({
                    ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL,
                    transaction: {
                        ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.transaction,
                        status: types_1.TransactionStatus.PENDING,
                    },
                });
            });
            it("throws a timeout error", async () => {
                expect(erc20SmartContract.wait({ timeoutSeconds: 0.05, intervalSeconds: 0.05 })).rejects.toThrow(new errors_1.TimeoutError("SmartContract deployment timed out"));
            });
        });
        describe("when the contract is external", () => {
            it("throws an error", async () => {
                expect(externalSmartContract.wait()).rejects.toThrow("Cannot wait for an external SmartContract");
            });
        });
    });
    describe("#reload", () => {
        it("returns the updated smart contract", async () => {
            coinbase_1.Coinbase.apiClients.smartContract.getSmartContract = (0, utils_1.mockReturnValue)({
                ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL,
                transaction: {
                    ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.transaction,
                    status: types_1.TransactionStatus.COMPLETE,
                },
            });
            await erc20SmartContract.reload();
            expect(erc20SmartContract.getTransaction().getStatus()).toEqual(types_1.TransactionStatus.COMPLETE);
            expect(coinbase_1.Coinbase.apiClients.smartContract.getSmartContract).toHaveBeenCalledTimes(1);
        });
        it("throws an error when the smart contract is external", async () => {
            expect(externalSmartContract.reload()).rejects.toThrow("Cannot reload an external SmartContract");
        });
    });
    describe("#toString", () => {
        it("returns the same value as toString", () => {
            expect(erc20SmartContract.toString()).toEqual(`SmartContract{id: '${erc20SmartContract.getId()}', networkId: '${erc20SmartContract.getNetworkId()}', ` +
                `contractAddress: '${erc20SmartContract.getContractAddress()}', deployerAddress: '${erc20SmartContract.getDeployerAddress()}', ` +
                `type: '${erc20SmartContract.getType()}'}`);
        });
    });
});
describe("SmartContract.listEvents", () => {
    const networkId = "ethereum-mainnet";
    const protocolName = "uniswap";
    const contractAddress = "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48";
    const contractName = "Pool";
    const eventName = "Transfer";
    const fromBlockHeight = 201782330;
    const toBlockHeight = 201782340;
    const CONTRACT_EVENTS_RESPONSE = {
        data: [
            {
                network_id: networkId,
                protocol_name: protocolName,
                contract_name: contractName,
                event_name: eventName,
                sig: "Transfer(address,address,uint256)",
                four_bytes: "0xddf252ad",
                contract_address: contractAddress,
                block_time: "2023-04-01T12:00:00Z",
                block_height: 201782330,
                tx_hash: "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
                tx_index: 109,
                event_index: 362,
                data: '{"from":"0x1234...","to":"0x5678...","value":"1000000000000000000"}',
            },
            {
                network_id: networkId,
                protocol_name: protocolName,
                contract_name: contractName,
                event_name: eventName,
                sig: "Transfer(address,address,uint256)",
                four_bytes: "0xddf252ad",
                contract_address: contractAddress,
                block_time: "2023-04-01T12:01:00Z",
                block_height: 201782331,
                tx_hash: "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
                tx_index: 110,
                event_index: 363,
                data: '{"from":"0x5678...","to":"0x9012...","value":"2000000000000000000"}',
            },
        ],
        has_more: false,
        next_page: "",
    };
    beforeAll(() => {
        coinbase_1.Coinbase.apiClients.contractEvent = utils_1.contractEventApiMock;
    });
    it("should successfully return contract events", async () => {
        coinbase_1.Coinbase.apiClients.contractEvent.listContractEvents =
            (0, utils_1.mockReturnValue)(CONTRACT_EVENTS_RESPONSE);
        const response = await smart_contract_1.SmartContract.listEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight);
        expect(response).toBeInstanceOf((Array));
        expect(response.length).toEqual(2);
        expect(coinbase_1.Coinbase.apiClients.contractEvent.listContractEvents).toHaveBeenCalledWith(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, undefined);
    });
    it("should successfully return contract events for multiple pages", async () => {
        const pages = ["abc", "def"];
        coinbase_1.Coinbase.apiClients.contractEvent.listContractEvents = (0, utils_1.mockFn)(() => {
            CONTRACT_EVENTS_RESPONSE.next_page = pages.shift();
            CONTRACT_EVENTS_RESPONSE.has_more = !!CONTRACT_EVENTS_RESPONSE.next_page;
            return { data: CONTRACT_EVENTS_RESPONSE };
        });
        const response = await smart_contract_1.SmartContract.listEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight);
        expect(response).toBeInstanceOf((Array));
        expect(response.length).toEqual(6);
        expect(coinbase_1.Coinbase.apiClients.contractEvent.listContractEvents).toHaveBeenCalledWith(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, undefined);
    });
    it("should handle API errors gracefully", async () => {
        coinbase_1.Coinbase.apiClients.contractEvent.listContractEvents = jest
            .fn()
            .mockRejectedValue(new Error("API Error"));
        await expect(smart_contract_1.SmartContract.listEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight)).rejects.toThrow("API Error");
    });
    it("should handle empty response", async () => {
        coinbase_1.Coinbase.apiClients.contractEvent.listContractEvents = (0, utils_1.mockReturnValue)({
            data: [],
            has_more: false,
            next_page: "",
        });
        const response = await smart_contract_1.SmartContract.listEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight);
        expect(response).toBeInstanceOf((Array));
        expect(response.length).toEqual(0);
    });
});
