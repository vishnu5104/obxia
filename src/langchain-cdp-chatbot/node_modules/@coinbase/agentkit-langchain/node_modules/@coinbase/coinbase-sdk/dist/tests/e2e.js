"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const dotenv_1 = __importDefault(require("dotenv"));
const index_1 = require("../index");
const client_1 = require("../client");
const types_1 = require("../coinbase/types");
describe("Coinbase SDK E2E Test", () => {
    beforeAll(() => {
        dotenv_1.default.config();
    });
    beforeEach(() => {
        index_1.Coinbase.configure({
            apiKeyName: process.env.NAME,
            privateKey: process.env.PRIVATE_KEY,
        });
    });
    it("should be able to access environment variables", () => {
        expect(process.env.NAME).toBeDefined();
        expect(process.env.PRIVATE_KEY).toBeDefined();
    });
    it("should have created a dist folder for NPM", () => {
        expect(fs_1.default.existsSync("./dist")).toBe(true);
        expect(fs_1.default.existsSync("./dist/index.js")).toBe(true);
        expect(fs_1.default.existsSync("./dist/client/index.js")).toBe(true);
        expect(fs_1.default.existsSync("./dist/coinbase/coinbase.js")).toBe(true);
    });
    it("should be able to interact with the Coinbase SDK", async () => {
        console.log("Creating new wallet...");
        const wallet = await index_1.Wallet.create();
        expect(wallet.toString()).toBeDefined();
        expect(wallet?.getId()).toBeDefined();
        console.log(`Created new wallet with ID: ${wallet.getId()}, default address: ${wallet.getDefaultAddress()}`);
        console.log("Importing wallet with balance...");
        const seedFile = JSON.parse(process.env.WALLET_DATA || "");
        const walletId = Object.keys(seedFile)[0];
        const seed = seedFile[walletId].seed;
        const importedWallet = await index_1.Wallet.import({
            seed,
            walletId,
            networkId: index_1.Coinbase.networks.BaseSepolia,
        });
        expect(importedWallet).toBeDefined();
        expect(importedWallet.getId()).toBe(walletId);
        console.log(`Imported wallet with ID: ${importedWallet.getId()}, default address: ${importedWallet.getDefaultAddress()}`);
        await importedWallet.saveSeedToFile("test_seed.json");
        try {
            const transaction = await importedWallet.faucet();
            expect(transaction.toString()).toBeDefined();
        }
        catch {
            console.log("Faucet request failed. Skipping...");
        }
        console.log("Listing wallet addresses...");
        const addresses = await importedWallet.listAddresses();
        expect(addresses.length).toBeGreaterThan(0);
        console.log(`Listed addresses: ${addresses.join(", ")}`);
        console.log("Fetching wallet balances...");
        const balances = await importedWallet.listBalances();
        expect(Array.from([...balances.keys()]).length).toBeGreaterThan(0);
        console.log(`Fetched balances: ${balances.toString()}`);
        console.log("Exporting wallet...");
        const exportedWallet = await wallet.export();
        expect(exportedWallet.walletId).toBeDefined();
        expect(exportedWallet.seed).toBeDefined();
        console.log("Saving seed to file...");
        await wallet.saveSeedToFile("test_seed.json");
        expect(fs_1.default.existsSync("test_seed.json")).toBe(true);
        console.log("Saved seed to test_seed.json");
        const unhydratedWallet = await index_1.Wallet.fetch(walletId);
        expect(unhydratedWallet.canSign()).toBe(false);
        await unhydratedWallet.loadSeedFromFile("test_seed.json");
        expect(unhydratedWallet.canSign()).toBe(true);
        expect(unhydratedWallet.getId()).toBe(walletId);
        console.log("Transfering 0.000000001 ETH from default address to second address...");
        const transfer = await unhydratedWallet.createTransfer({
            amount: 0.000000001,
            assetId: index_1.Coinbase.assets.Eth,
            destination: wallet,
        });
        await transfer.wait();
        expect(transfer.toString()).toBeDefined();
        expect(await transfer.getStatus()).toBe(types_1.TransferStatus.COMPLETE);
        console.log(`Transferred 1 Gwei from ${unhydratedWallet} to ${wallet}`);
        console.log("Fetching updated balances...");
        const firstBalance = await unhydratedWallet.listBalances();
        const secondBalance = await wallet.listBalances();
        expect(firstBalance.get(index_1.Coinbase.assets.Eth)).not.toEqual("0");
        expect(secondBalance.get(index_1.Coinbase.assets.Eth)).not.toEqual("0");
        console.log(`First address balances: ${firstBalance}`);
        console.log(`Second address balances: ${secondBalance}`);
        console.log("Fetching address transactions...");
        let result;
        for (let i = 0; i < 5; i++) {
            // Try up to 5 times
            result = await (await unhydratedWallet.getDefaultAddress()).listTransactions({ limit: 1 });
            if (result?.data.length > 0)
                break;
            // Wait 2 seconds between attempts
            console.log(`Waiting for transaction to be processed... (${i + 1} attempts)`);
            await new Promise(resolve => setTimeout(resolve, 2000));
        }
        expect(result?.data.length).toBeGreaterThan(0);
        console.log("Fetching address historical balances...");
        const balance_result = await (await unhydratedWallet.getDefaultAddress()).listHistoricalBalances(index_1.Coinbase.assets.Eth, { limit: 2 });
        expect(balance_result?.data.length).toBeGreaterThan(0);
        console.log(`First eth historical balance: ${balance_result?.data[0].amount.toString()}`);
        const savedSeed = JSON.parse(fs_1.default.readFileSync("test_seed.json", "utf-8"));
        fs_1.default.unlinkSync("test_seed.json");
        expect(exportedWallet.seed.length).toBe(64);
        expect(savedSeed[exportedWallet.walletId]).toEqual({
            seed: exportedWallet.seed,
            encrypted: false,
            authTag: "",
            iv: "",
            networkId: exportedWallet.networkId,
        });
    }, 60000);
});
describe("Coinbase SDK Stake E2E Test", () => {
    const requiredEnvVars = [
        "STAKE_API_KEY_NAME",
        "STAKE_API_PRIVATE_KEY",
        "STAKE_ADDRESS_ID_1",
        "STAKE_ADDRESS_ID_2",
        "STAKE_VALIDATOR_ADDRESS_1",
    ];
    beforeAll(() => {
        dotenv_1.default.config();
        requiredEnvVars.forEach(envVar => {
            if (!process.env[envVar]) {
                throw new Error(`Required environment variable ${envVar} is not set`);
            }
        });
        index_1.Coinbase.configure({
            apiKeyName: process.env.STAKE_API_KEY_NAME,
            privateKey: process.env.STAKE_API_PRIVATE_KEY,
        });
    });
    it("should be able to access environment variables", () => {
        requiredEnvVars.forEach(envVar => {
            expect(process.env[envVar]).toBeDefined();
        });
    });
    describe("Stake: Reward Tests", () => {
        it("should list shared eth staking rewards via StakingReward.list", async () => {
            const networkId = index_1.Coinbase.networks.EthereumMainnet;
            const assetId = index_1.Coinbase.assets.Eth;
            const addressIds = [process.env.STAKE_ADDRESS_ID_1];
            // May 1, 2024 - May 20, 2024
            const startTime = new Date(2024, 4, 1, 0, 0, 0).toISOString();
            const endTime = new Date(2024, 4, 20, 23, 59, 59).toISOString();
            const rewards = await index_1.StakingReward.list(networkId, assetId, addressIds, startTime, endTime);
            expect(rewards).toBeDefined();
            expect(rewards.length).toEqual(20);
        });
        it("should list shared eth staking rewards via ExternalAddress", async () => {
            // May 1, 2024 - May 20, 2024
            const startTime = new Date(2024, 4, 1, 0, 0, 0).toISOString();
            const endTime = new Date(2024, 4, 20, 23, 59, 59).toISOString();
            const address = new index_1.ExternalAddress(index_1.Coinbase.networks.EthereumMainnet, process.env.STAKE_ADDRESS_ID_1);
            const rewards = await address.stakingRewards(index_1.Coinbase.assets.Eth, startTime, endTime);
            expect(rewards).toBeDefined();
            expect(rewards.length).toEqual(20);
        });
    });
    describe("Stake: Balance Tests", () => {
        it("should list shared eth staking balances via StakingBalance.list", async () => {
            const networkId = index_1.Coinbase.networks.EthereumMainnet;
            const assetId = index_1.Coinbase.assets.Eth;
            const addressId = process.env.STAKE_VALIDATOR_ADDRESS_1;
            // Nov 1, 2024 - Nov 20, 2024
            const startTime = new Date(2024, 10, 1, 0, 0, 0).toISOString();
            const endTime = new Date(2024, 10, 20, 23, 59, 59).toISOString();
            const stakingBalances = await index_1.StakingBalance.list(networkId, assetId, addressId, startTime, endTime);
            expect(stakingBalances).toBeDefined();
            expect(stakingBalances.length).toEqual(20);
        });
    });
    describe("Stake: Validator Tests", () => {
        it("should list validators", async () => {
            const networkId = index_1.Coinbase.networks.EthereumMainnet;
            const assetId = index_1.Coinbase.assets.Eth;
            const status = index_1.ValidatorStatus.ACTIVE;
            const validators = await index_1.Validator.list(networkId, assetId, status);
            expect(validators).toBeDefined();
            expect(validators.length).toEqual(1);
            const validator = validators[0];
            expect(validator.getStatus()).toEqual(index_1.ValidatorStatus.ACTIVE);
            expect(validator.getValidatorId()).toEqual(process.env.STAKE_VALIDATOR_ADDRESS_1);
        });
        it("should fetch a validator", async () => {
            const networkId = index_1.Coinbase.networks.EthereumMainnet;
            const assetId = index_1.Coinbase.assets.Eth;
            const validatorId = process.env.STAKE_VALIDATOR_ADDRESS_1;
            const validator = await index_1.Validator.fetch(networkId, assetId, validatorId);
            expect(validator).toBeDefined();
            expect(validator.getStatus()).toEqual(index_1.ValidatorStatus.ACTIVE);
            expect(validator.getValidatorId()).toEqual(validatorId);
        });
    });
    describe("Stake: Context Tests", () => {
        it("should return stakeable balances for shared ETH staking", async () => {
            const address = new index_1.ExternalAddress(index_1.Coinbase.networks.EthereumMainnet, process.env.STAKE_ADDRESS_ID_2);
            const stakeableBalance = await address.stakeableBalance(index_1.Coinbase.assets.Eth, index_1.StakeOptionsMode.PARTIAL);
            expect(stakeableBalance).toBeDefined();
            expect(stakeableBalance.toNumber()).toBeGreaterThanOrEqual(0);
        });
        it("should return unstakeable balances for shared ETH staking", async () => {
            const address = new index_1.ExternalAddress(index_1.Coinbase.networks.EthereumMainnet, process.env.STAKE_ADDRESS_ID_1);
            const stakeableBalance = await address.unstakeableBalance(index_1.Coinbase.assets.Eth, index_1.StakeOptionsMode.PARTIAL);
            expect(stakeableBalance).toBeDefined();
            expect(stakeableBalance.toNumber()).toBeGreaterThanOrEqual(0);
        });
        it("should return claimable balances for shared ETH staking", async () => {
            const address = new index_1.ExternalAddress(index_1.Coinbase.networks.EthereumMainnet, process.env.STAKE_ADDRESS_ID_1);
            const stakeableBalance = await address.claimableBalance(index_1.Coinbase.assets.Eth, index_1.StakeOptionsMode.PARTIAL);
            expect(stakeableBalance).toBeDefined();
            expect(stakeableBalance.toNumber()).toBeGreaterThanOrEqual(0);
        });
        it("should return unstakeable balances for Dedicated ETH staking", async () => {
            // This address is expected to have 1 validator associated with it, thus returning a 32 unstake balance.
            const address = new index_1.ExternalAddress(index_1.Coinbase.networks.EthereumMainnet, process.env.STAKE_ADDRESS_ID_2);
            const stakeableBalance = await address.unstakeableBalance(index_1.Coinbase.assets.Eth, index_1.StakeOptionsMode.NATIVE);
            expect(stakeableBalance).toBeDefined();
            expect(stakeableBalance.toNumber()).toBeGreaterThanOrEqual(32);
        });
    });
    describe("Stake: Build Tests", () => {
        it("should return an unsigned tx for shared ETH staking", async () => {
            const address = new index_1.ExternalAddress(index_1.Coinbase.networks.EthereumMainnet, process.env.STAKE_ADDRESS_ID_2);
            const stakingOperation = await address.buildStakeOperation(0.0001, index_1.Coinbase.assets.Eth, index_1.StakeOptionsMode.PARTIAL);
            await stakingOperation.wait({ timeoutSeconds: 5, intervalSeconds: 1 });
            expect(stakingOperation).toBeDefined();
            expect(stakingOperation.getID()).toBeDefined();
            expect(stakingOperation.getStatus()).toEqual(client_1.StakingOperationStatusEnum.Complete);
            expect(stakingOperation.getAddressID()).toEqual(process.env.STAKE_ADDRESS_ID_2);
            expect(stakingOperation.getNetworkID()).toEqual(index_1.Coinbase.networks.EthereumMainnet);
            expect(stakingOperation.isCompleteState()).toBe(true);
            expect(stakingOperation.getSignedVoluntaryExitMessages()).toEqual([]);
            expect(stakingOperation.getTransactions().length).toEqual(1);
            expect(stakingOperation.getTransactions()[0].isSigned()).toBe(false);
            expect(stakingOperation.getTransactions()[0].getNetworkId()).toEqual(index_1.Coinbase.networks.EthereumMainnet);
            expect(stakingOperation.getTransactions()[0].getUnsignedPayload()).toBeDefined();
            expect(stakingOperation.getTransactions()[0].getStatus()).toEqual(index_1.TransactionStatus.PENDING);
        });
    });
});
