"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-explicit-any */
const crypto = __importStar(require("crypto"));
const crypto_1 = require("crypto");
const ethers_1 = require("ethers");
const faucet_transaction_1 = require("../coinbase/faucet_transaction");
const client_1 = require("../client");
const decimal_js_1 = __importDefault(require("decimal.js"));
const api_error_1 = require("../coinbase/api_error");
const coinbase_1 = require("../coinbase/coinbase");
const errors_1 = require("../coinbase/errors");
const utils_1 = require("./utils");
const transfer_1 = require("../coinbase/transfer");
const types_1 = require("../coinbase/types");
const trade_1 = require("../coinbase/trade");
const transaction_1 = require("../coinbase/transaction");
const wallet_address_1 = require("../coinbase/address/wallet_address");
const wallet_1 = require("../coinbase/wallet");
const staking_operation_1 = require("../coinbase/staking_operation");
const payload_signature_1 = require("../coinbase/payload_signature");
const contract_invocation_1 = require("../coinbase/contract_invocation");
const smart_contract_1 = require("../coinbase/smart_contract");
// Test suite for the WalletAddress class
describe("WalletAddress", () => {
    const transactionHash = (0, utils_1.generateRandomHash)();
    let address;
    let balanceModel;
    let key;
    beforeEach(() => {
        coinbase_1.Coinbase.apiClients.externalAddress = utils_1.externalAddressApiMock;
        coinbase_1.Coinbase.apiClients.asset = utils_1.assetsApiMock;
        coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
        coinbase_1.Coinbase.apiClients.externalAddress.getExternalAddressBalance = (0, utils_1.mockFn)(request => {
            const [, , asset_id] = request;
            balanceModel = {
                amount: "1000000000000000000",
                asset: {
                    asset_id,
                    network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                    decimals: 18,
                    contract_address: "0x",
                },
            };
            return { data: balanceModel };
        });
        coinbase_1.Coinbase.apiClients.externalAddress.listExternalAddressBalances = (0, utils_1.mockFn)(() => {
            return { data: utils_1.VALID_ADDRESS_BALANCE_LIST };
        });
    });
    beforeEach(() => {
        key = ethers_1.ethers.Wallet.createRandom();
        address = new wallet_address_1.WalletAddress(utils_1.VALID_ADDRESS_MODEL, key);
        jest.clearAllMocks();
    });
    it("should initialize a new WalletAddress", () => {
        expect(address).toBeInstanceOf(wallet_address_1.WalletAddress);
    });
    it("should initialize a new WalletAddress that can sign", () => {
        expect(address).toBeInstanceOf(wallet_address_1.WalletAddress);
        expect(address.canSign()).toEqual(true);
    });
    it("should return the address ID", () => {
        expect(address.getId()).toBe(utils_1.VALID_ADDRESS_MODEL.address_id);
    });
    it("should return the network ID", () => {
        expect(address.getNetworkId()).toBe(utils_1.VALID_ADDRESS_MODEL.network_id);
    });
    it("should return the correct list of balances", async () => {
        const balances = await address.listBalances();
        expect(balances.get(coinbase_1.Coinbase.assets.Eth)).toEqual(new decimal_js_1.default(1));
        expect(balances.get("usdc")).toEqual(new decimal_js_1.default(5000));
        expect(balances.get("weth")).toEqual(new decimal_js_1.default(3));
        expect(coinbase_1.Coinbase.apiClients.externalAddress.listExternalAddressBalances).toHaveBeenCalledWith(address.getNetworkId(), address.getId());
        expect(coinbase_1.Coinbase.apiClients.externalAddress.listExternalAddressBalances).toHaveBeenCalledTimes(1);
    });
    it("should return the correct ETH balance", async () => {
        const ethBalance = await address.getBalance(coinbase_1.Coinbase.assets.Eth);
        expect(ethBalance).toBeInstanceOf(decimal_js_1.default);
        expect(ethBalance).toEqual(new decimal_js_1.default(1));
        expect(coinbase_1.Coinbase.apiClients.externalAddress.getExternalAddressBalance).toHaveBeenCalledWith(address.getNetworkId(), address.getId(), coinbase_1.Coinbase.assets.Eth);
        expect(coinbase_1.Coinbase.apiClients.externalAddress.getExternalAddressBalance).toHaveBeenCalledTimes(1);
    });
    it("should return 0 balance when the response is empty", async () => {
        coinbase_1.Coinbase.apiClients.externalAddress.getExternalAddressBalance = (0, utils_1.mockReturnValue)(null);
        const ethBalance = await address.getBalance(coinbase_1.Coinbase.assets.Eth);
        expect(ethBalance).toBeInstanceOf(decimal_js_1.default);
        expect(ethBalance).toEqual(new decimal_js_1.default(0));
    });
    it("should return the correct Gwei balance", async () => {
        const assetId = "gwei";
        const ethBalance = await address.getBalance(assetId);
        expect(ethBalance).toBeInstanceOf(decimal_js_1.default);
        expect(ethBalance).toEqual(new decimal_js_1.default("1000000000"));
        expect(coinbase_1.Coinbase.apiClients.externalAddress.getExternalAddressBalance).toHaveBeenCalledWith(address.getNetworkId(), address.getId(), coinbase_1.Coinbase.assets.Eth);
        expect(coinbase_1.Coinbase.apiClients.externalAddress.getExternalAddressBalance).toHaveBeenCalledTimes(1);
    });
    it("should return the correct Wei balance", async () => {
        const assetId = "wei";
        const ethBalance = await address.getBalance(assetId);
        expect(ethBalance).toBeInstanceOf(decimal_js_1.default);
        expect(ethBalance).toEqual(new decimal_js_1.default("1000000000000000000"));
        expect(coinbase_1.Coinbase.apiClients.externalAddress?.getExternalAddressBalance).toHaveBeenCalledWith(address.getNetworkId(), address.getId(), coinbase_1.Coinbase.assets.Eth);
        expect(coinbase_1.Coinbase.apiClients.externalAddress?.getExternalAddressBalance).toHaveBeenCalledTimes(1);
    });
    it("should return an error for an unsupported asset", async () => {
        const getAddressBalance = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError(""));
        const assetId = "unsupported-asset";
        coinbase_1.Coinbase.apiClients.externalAddress.getExternalAddressBalance = getAddressBalance;
        await expect(address.getBalance(assetId)).rejects.toThrow(api_error_1.APIError);
        expect(getAddressBalance).toHaveBeenCalledWith(address.getNetworkId(), address.getId(), assetId);
        expect(getAddressBalance).toHaveBeenCalledTimes(1);
    });
    it("should return the wallet ID", () => {
        expect(address.getWalletId()).toBe(utils_1.VALID_ADDRESS_MODEL.wallet_id);
    });
    it("should throw an Error when model is not provided", () => {
        expect(() => new wallet_address_1.WalletAddress(null, key)).toThrow(`Address model cannot be empty`);
    });
    describe("#faucet", () => {
        let faucetTransaction;
        beforeEach(() => {
            coinbase_1.Coinbase.apiClients.externalAddress.requestExternalFaucetFunds = (0, utils_1.mockReturnValue)(utils_1.VALID_FAUCET_TRANSACTION_MODEL);
        });
        it("returns the faucet transaction", async () => {
            const faucetTransaction = await address.faucet();
            expect(faucetTransaction).toBeInstanceOf(faucet_transaction_1.FaucetTransaction);
            expect(faucetTransaction.getTransactionHash()).toBe(utils_1.VALID_FAUCET_TRANSACTION_MODEL.transaction.transaction_hash);
            expect(coinbase_1.Coinbase.apiClients.externalAddress.requestExternalFaucetFunds).toHaveBeenCalledWith(address.getNetworkId(), address.getId(), undefined, true);
            expect(coinbase_1.Coinbase.apiClients.externalAddress.requestExternalFaucetFunds).toHaveBeenCalledTimes(1);
        });
        it("returns the faucet transaction when specifying the asset ID", async () => {
            const faucetTransaction = await address.faucet("usdc");
            expect(faucetTransaction.getTransactionHash()).toBe(utils_1.VALID_FAUCET_TRANSACTION_MODEL.transaction.transaction_hash);
            expect(coinbase_1.Coinbase.apiClients.externalAddress.requestExternalFaucetFunds).toHaveBeenCalledWith(address.getNetworkId(), address.getId(), "usdc", true);
            expect(coinbase_1.Coinbase.apiClients.externalAddress.requestExternalFaucetFunds).toHaveBeenCalledTimes(1);
        });
        it("should throw an APIError when the request is unsuccessful", async () => {
            coinbase_1.Coinbase.apiClients.externalAddress.requestExternalFaucetFunds = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError(""));
            await expect(address.faucet()).rejects.toThrow(api_error_1.APIError);
            expect(coinbase_1.Coinbase.apiClients.externalAddress.requestExternalFaucetFunds).toHaveBeenCalledWith(address.getNetworkId(), address.getId(), undefined, true);
            expect(coinbase_1.Coinbase.apiClients.externalAddress.requestExternalFaucetFunds).toHaveBeenCalledTimes(1);
        });
        it("should throw a FaucetLimitReachedError when the faucet limit is reached", async () => {
            coinbase_1.Coinbase.apiClients.externalAddress.requestExternalFaucetFunds = (0, utils_1.mockReturnRejectedValue)(new api_error_1.FaucetLimitReachedError(""));
            await expect(address.faucet()).rejects.toThrow(api_error_1.FaucetLimitReachedError);
            expect(coinbase_1.Coinbase.apiClients.externalAddress.requestExternalFaucetFunds).toHaveBeenCalledTimes(1);
        });
        it("should throw an Error when the request fails unexpectedly", async () => {
            coinbase_1.Coinbase.apiClients.externalAddress.requestExternalFaucetFunds = (0, utils_1.mockReturnRejectedValue)(new Error(""));
            await expect(address.faucet()).rejects.toThrow(Error);
            expect(coinbase_1.Coinbase.apiClients.externalAddress.requestExternalFaucetFunds).toHaveBeenCalledTimes(1);
        });
    });
    it("should return the correct string representation", () => {
        expect(address.toString()).toBe(`WalletAddress{ addressId: '${utils_1.VALID_ADDRESS_MODEL.address_id}', networkId: '${utils_1.VALID_ADDRESS_MODEL.network_id}', walletId: '${utils_1.VALID_ADDRESS_MODEL.wallet_id}' }`);
    });
    describe("#setKey", () => {
        it("should set the key successfully", () => {
            key = ethers_1.ethers.Wallet.createRandom();
            const newAddress = new wallet_address_1.WalletAddress(utils_1.VALID_ADDRESS_MODEL, undefined);
            expect(() => {
                newAddress.setKey(key);
            }).not.toThrow(Error);
        });
        it("should not set the key successfully", () => {
            key = ethers_1.ethers.Wallet.createRandom();
            const newAddress = new wallet_address_1.WalletAddress(utils_1.VALID_ADDRESS_MODEL, key);
            expect(() => {
                newAddress.setKey(key);
            }).toThrow(Error);
        });
    });
    describe("#export", () => {
        it("should get the private key if it is set", () => {
            key = ethers_1.ethers.Wallet.createRandom();
            const newAddress = new wallet_address_1.WalletAddress(utils_1.VALID_ADDRESS_MODEL, key);
            expect(newAddress.export()).toEqual(key.privateKey);
        });
        it("should not get the private key if not set", () => {
            const newAddress = new wallet_address_1.WalletAddress(utils_1.VALID_ADDRESS_MODEL, undefined);
            expect(() => {
                newAddress.export();
            }).toThrow(Error);
        });
    });
    describe("#stakingOperation", () => {
        key = ethers_1.ethers.Wallet.createRandom();
        const newAddress = (0, utils_1.newAddressModel)("", (0, crypto_1.randomUUID)(), coinbase_1.Coinbase.networks.EthereumHolesky);
        const walletAddress = new wallet_address_1.WalletAddress(newAddress, key);
        const STAKING_OPERATION_MODEL = {
            id: (0, crypto_1.randomUUID)(),
            network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
            address_id: newAddress.address_id,
            status: client_1.StakingOperationStatusEnum.Complete,
            transactions: [
                {
                    from_address_id: newAddress.address_id,
                    network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                    status: "pending",
                    unsigned_payload: "7b2274797065223a22307832222c22636861696e4964223a22307834323638222c226e6f" +
                        "6e6365223a2230783137222c22746f223a22307861353534313664653564653631613061" +
                        "633161613839373061323830653034333838623164653462222c22676173223a22307833" +
                        "30643430222c226761735072696365223a6e756c6c2c226d61785072696f726974794665" +
                        "65506572476173223a223078323534306265343030222c226d6178466565506572476173" +
                        "223a223078326437313162383430222c2276616c7565223a223078356166333130376134" +
                        "303030222c22696e707574223a2230783361346236366631222c226163636573734c6973" +
                        "74223a5b5d2c2276223a22307830222c2272223a22307830222c2273223a22307830222c" +
                        "2279506172697479223a22307830222c2268617368223a22307839613034353830343332" +
                        "646630666334656139646164653561343836353433623831666239333833316430646239" +
                        "386263356436373834393339343866333432227d",
                },
            ],
        };
        const STAKING_CONTEXT_MODEL = {
            context: {
                stakeable_balance: {
                    amount: "3000000000000000000",
                    asset: {
                        asset_id: coinbase_1.Coinbase.assets.Eth,
                        network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                        decimals: 18,
                        contract_address: "0x",
                    },
                },
                unstakeable_balance: {
                    amount: "2000000000000000000",
                    asset: {
                        asset_id: coinbase_1.Coinbase.assets.Eth,
                        network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                        decimals: 18,
                        contract_address: "0x",
                    },
                },
                claimable_balance: {
                    amount: "1000000000000000000",
                    asset: {
                        asset_id: coinbase_1.Coinbase.assets.Eth,
                        network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                        decimals: 18,
                        contract_address: "0x",
                    },
                },
            },
        };
        const STAKING_REWARD_RESPONSE = {
            data: [
                {
                    address_id: newAddress.address_id,
                    date: "2024-05-01",
                    amount: "361",
                    state: client_1.StakingRewardStateEnum.Pending,
                    format: client_1.StakingRewardFormat.Usd,
                    usd_value: {
                        amount: "361",
                        conversion_price: "3000",
                        conversion_time: "2024-05-01T00:00:00Z",
                    },
                },
                {
                    address_id: newAddress.address_id,
                    date: "2024-05-02",
                    amount: "203",
                    state: client_1.StakingRewardStateEnum.Pending,
                    format: client_1.StakingRewardFormat.Usd,
                    usd_value: {
                        amount: "203",
                        conversion_price: "3000",
                        conversion_time: "2024-05-02T00:00:00Z",
                    },
                },
                {
                    address_id: newAddress.address_id,
                    date: "2024-05-03",
                    amount: "226",
                    state: client_1.StakingRewardStateEnum.Pending,
                    format: client_1.StakingRewardFormat.Usd,
                    usd_value: {
                        amount: "226",
                        conversion_price: "3000",
                        conversion_time: "2024-05-03T00:00:00Z",
                    },
                },
            ],
            has_more: false,
            next_page: "",
        };
        const HISTORICAL_STAKING_BALANCES_RESPONSE = {
            data: [
                {
                    address: newAddress.address_id,
                    date: "2024-05-01",
                    bonded_stake: {
                        amount: "32000000000000000000",
                        asset: {
                            asset_id: coinbase_1.Coinbase.assets.Eth,
                            network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                            decimals: 18,
                        },
                    },
                    unbonded_balance: {
                        amount: "2000000000000000000",
                        asset: {
                            asset_id: coinbase_1.Coinbase.assets.Eth,
                            network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                            decimals: 18,
                        },
                    },
                    participant_type: "validator",
                },
                {
                    address: newAddress.address_id,
                    date: "2024-05-02",
                    bonded_stake: {
                        amount: "34000000000000000000",
                        asset: {
                            asset_id: coinbase_1.Coinbase.assets.Eth,
                            network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                            decimals: 18,
                        },
                    },
                    unbonded_balance: {
                        amount: "3000000000000000000",
                        asset: {
                            asset_id: coinbase_1.Coinbase.assets.Eth,
                            network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                            decimals: 18,
                        },
                    },
                    participant_type: "validator",
                },
            ],
            has_more: false,
            next_page: "",
        };
        beforeAll(() => {
            coinbase_1.Coinbase.apiClients.externalAddress = utils_1.externalAddressApiMock;
            coinbase_1.Coinbase.apiClients.stake = utils_1.stakeApiMock;
            coinbase_1.Coinbase.apiClients.walletStake = utils_1.walletStakeApiMock;
            coinbase_1.Coinbase.apiClients.asset = utils_1.assetsApiMock;
        });
        beforeEach(() => {
            jest.clearAllMocks();
            STAKING_OPERATION_MODEL.wallet_id = newAddress.wallet_id;
        });
        describe("#createStake", () => {
            it("should create a staking operation from the address", async () => {
                coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
                coinbase_1.Coinbase.apiClients.stake.getStakingContext = (0, utils_1.mockReturnValue)(STAKING_CONTEXT_MODEL);
                coinbase_1.Coinbase.apiClients.walletStake.createStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                coinbase_1.Coinbase.apiClients.walletStake.broadcastStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                STAKING_OPERATION_MODEL.status = client_1.StakingOperationStatusEnum.Complete;
                coinbase_1.Coinbase.apiClients.walletStake.getStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                const op = await walletAddress.createStake(0.001, coinbase_1.Coinbase.assets.Eth);
                expect(op).toBeInstanceOf(staking_operation_1.StakingOperation);
            });
            it("should create a staking operation from the address but in failed status", async () => {
                coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
                coinbase_1.Coinbase.apiClients.stake.getStakingContext = (0, utils_1.mockReturnValue)(STAKING_CONTEXT_MODEL);
                coinbase_1.Coinbase.apiClients.walletStake.createStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                coinbase_1.Coinbase.apiClients.walletStake.broadcastStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                STAKING_OPERATION_MODEL.status = client_1.StakingOperationStatusEnum.Failed;
                coinbase_1.Coinbase.apiClients.walletStake.getStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                const op = await walletAddress.createStake(0.001, coinbase_1.Coinbase.assets.Eth);
                expect(op).toBeInstanceOf(staking_operation_1.StakingOperation);
                expect(op.getStatus()).toEqual(client_1.StakingOperationStatusEnum.Failed);
            });
            it("should not create a staking operation from the address with zero amount", async () => {
                coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
                coinbase_1.Coinbase.apiClients.stake.getStakingContext = (0, utils_1.mockReturnValue)(STAKING_CONTEXT_MODEL);
                await expect(async () => await walletAddress.createStake(0.0, coinbase_1.Coinbase.assets.Eth)).rejects.toThrow(Error);
            });
            it("should create a staking operation from the address when broadcast returns empty transactions", async () => {
                coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
                coinbase_1.Coinbase.apiClients.stake.getStakingContext = (0, utils_1.mockReturnValue)(STAKING_CONTEXT_MODEL);
                coinbase_1.Coinbase.apiClients.walletStake.createStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                coinbase_1.Coinbase.apiClients.walletStake.broadcastStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                STAKING_OPERATION_MODEL.status = client_1.StakingOperationStatusEnum.Complete;
                STAKING_OPERATION_MODEL.transactions = [];
                coinbase_1.Coinbase.apiClients.walletStake.getStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                const op = await walletAddress.createStake(0.001, coinbase_1.Coinbase.assets.Eth);
                expect(op).toBeInstanceOf(staking_operation_1.StakingOperation);
            });
        });
        describe("#createUnstake", () => {
            it("should create a staking operation from the address", async () => {
                coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
                coinbase_1.Coinbase.apiClients.stake.getStakingContext = (0, utils_1.mockReturnValue)(STAKING_CONTEXT_MODEL);
                coinbase_1.Coinbase.apiClients.walletStake.createStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                coinbase_1.Coinbase.apiClients.walletStake.broadcastStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                STAKING_OPERATION_MODEL.status = client_1.StakingOperationStatusEnum.Complete;
                coinbase_1.Coinbase.apiClients.walletStake.getStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                const op = await walletAddress.createUnstake(0.001, coinbase_1.Coinbase.assets.Eth);
                expect(op).toBeInstanceOf(staking_operation_1.StakingOperation);
            });
        });
        describe("#createClaimStake", () => {
            it("should create a staking operation from the address", async () => {
                coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
                coinbase_1.Coinbase.apiClients.stake.getStakingContext = (0, utils_1.mockReturnValue)(STAKING_CONTEXT_MODEL);
                coinbase_1.Coinbase.apiClients.walletStake.createStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                coinbase_1.Coinbase.apiClients.walletStake.broadcastStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                STAKING_OPERATION_MODEL.status = client_1.StakingOperationStatusEnum.Complete;
                coinbase_1.Coinbase.apiClients.walletStake.getStakingOperation =
                    (0, utils_1.mockReturnValue)(STAKING_OPERATION_MODEL);
                const op = await walletAddress.createClaimStake(0.001, coinbase_1.Coinbase.assets.Eth);
                expect(op).toBeInstanceOf(staking_operation_1.StakingOperation);
            });
        });
        describe("#stakeableBalance", () => {
            it("should return the stakeable balance successfully with default params", async () => {
                coinbase_1.Coinbase.apiClients.stake.getStakingContext = (0, utils_1.mockReturnValue)(STAKING_CONTEXT_MODEL);
                const stakeableBalance = await walletAddress.stakeableBalance(coinbase_1.Coinbase.assets.Eth);
                expect(stakeableBalance).toEqual(new decimal_js_1.default("3"));
            });
        });
        describe("#unstakeableBalance", () => {
            it("should return the unstakeableBalance balance successfully with default params", async () => {
                coinbase_1.Coinbase.apiClients.stake.getStakingContext = (0, utils_1.mockReturnValue)(STAKING_CONTEXT_MODEL);
                const stakeableBalance = await walletAddress.unstakeableBalance(coinbase_1.Coinbase.assets.Eth);
                expect(stakeableBalance).toEqual(new decimal_js_1.default("2"));
            });
        });
        describe("#claimableBalance", () => {
            it("should return the claimableBalance balance successfully with default params", async () => {
                coinbase_1.Coinbase.apiClients.stake.getStakingContext = (0, utils_1.mockReturnValue)(STAKING_CONTEXT_MODEL);
                const stakeableBalance = await walletAddress.claimableBalance(coinbase_1.Coinbase.assets.Eth);
                expect(stakeableBalance).toEqual(new decimal_js_1.default("1"));
            });
        });
        describe("#stakingRewards", () => {
            it("should successfully return staking rewards", async () => {
                coinbase_1.Coinbase.apiClients.stake.fetchStakingRewards = (0, utils_1.mockReturnValue)(STAKING_REWARD_RESPONSE);
                coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
                const response = await walletAddress.stakingRewards(coinbase_1.Coinbase.assets.Eth);
                expect(response).toBeInstanceOf((Array));
            });
        });
        describe("#historicalStakingBalances", () => {
            it("should successfully return historical staking balances", async () => {
                coinbase_1.Coinbase.apiClients.stake.fetchHistoricalStakingBalances = (0, utils_1.mockReturnValue)(HISTORICAL_STAKING_BALANCES_RESPONSE);
                coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
                const response = await walletAddress.historicalStakingBalances(coinbase_1.Coinbase.assets.Eth);
                expect(response).toBeInstanceOf((Array));
                expect(response.length).toEqual(2);
                expect(response[0].bondedStake().amount).toEqual(new decimal_js_1.default("32"));
                expect(response[0].bondedStake().asset?.assetId).toEqual(coinbase_1.Coinbase.assets.Eth);
                expect(response[0].bondedStake().asset?.decimals).toEqual(18);
                expect(response[0].bondedStake().asset?.networkId).toEqual(coinbase_1.Coinbase.networks.EthereumHolesky);
                expect(response[0].unbondedBalance().amount).toEqual(new decimal_js_1.default("2"));
                expect(response[0].unbondedBalance().asset?.assetId).toEqual(coinbase_1.Coinbase.assets.Eth);
                expect(response[0].unbondedBalance().asset?.decimals).toEqual(18);
                expect(response[0].unbondedBalance().asset?.networkId).toEqual(coinbase_1.Coinbase.networks.EthereumHolesky);
            });
        });
    });
    describe("#createTransfer", () => {
        let weiAmount, destination;
        let walletId, id;
        beforeEach(() => {
            weiAmount = new decimal_js_1.default("500000000000000000");
            destination = new wallet_address_1.WalletAddress(utils_1.VALID_ADDRESS_MODEL, key);
            walletId = crypto.randomUUID();
            id = crypto.randomUUID();
            coinbase_1.Coinbase.apiClients.externalAddress = utils_1.externalAddressApiMock;
            coinbase_1.Coinbase.apiClients.asset = utils_1.assetsApiMock;
            coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
            coinbase_1.Coinbase.apiClients.externalAddress.getExternalAddressBalance = (0, utils_1.mockFn)((...request) => {
                const [, , asset_id] = request;
                balanceModel = {
                    amount: "1000000000000000000",
                    asset: {
                        asset_id,
                        network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                        decimals: 18,
                        contract_address: "0x",
                    },
                };
                return { data: balanceModel };
            });
            coinbase_1.Coinbase.apiClients.transfer = utils_1.transfersApiMock;
            coinbase_1.Coinbase.useServerSigner = false;
        });
        it("should successfully create the transfer", async () => {
            coinbase_1.Coinbase.apiClients.transfer.createTransfer = (0, utils_1.mockReturnValue)(utils_1.VALID_TRANSFER_MODEL);
            coinbase_1.Coinbase.apiClients.transfer.broadcastTransfer = (0, utils_1.mockReturnValue)({
                transaction_hash: "0x6c087c1676e8269dd81e0777244584d0cbfd39b6997b3477242a008fa9349e11",
                ...utils_1.VALID_TRANSFER_MODEL,
            });
            const transfer = await address.createTransfer({
                amount: weiAmount,
                assetId: coinbase_1.Coinbase.assets.Wei,
                destination,
            });
            expect(coinbase_1.Coinbase.apiClients.transfer.createTransfer).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.transfer.broadcastTransfer).toHaveBeenCalledTimes(1);
            expect(transfer).toBeInstanceOf(transfer_1.Transfer);
            expect(transfer.getId()).toBe(utils_1.VALID_TRANSFER_MODEL.transfer_id);
        });
        it("should default skipBatching to false", async () => {
            coinbase_1.Coinbase.apiClients.transfer.createTransfer = (0, utils_1.mockReturnValue)(utils_1.VALID_TRANSFER_MODEL);
            coinbase_1.Coinbase.apiClients.transfer.broadcastTransfer = (0, utils_1.mockReturnValue)({
                transaction_hash: "0x6c087c1676e8269dd81e0777244584d0cbfd39b6997b3477242a008fa9349e11",
                ...utils_1.VALID_TRANSFER_MODEL,
            });
            await address.createTransfer({
                amount: weiAmount,
                assetId: coinbase_1.Coinbase.assets.Wei,
                destination,
            });
            expect(coinbase_1.Coinbase.apiClients.transfer.createTransfer).toHaveBeenCalledWith(address.getWalletId(), address.getId(), expect.objectContaining({
                skip_batching: false,
            }));
        });
        it("should allow skipBatching to be set to true", async () => {
            coinbase_1.Coinbase.apiClients.transfer.createTransfer = (0, utils_1.mockReturnValue)(utils_1.VALID_TRANSFER_MODEL);
            coinbase_1.Coinbase.apiClients.transfer.broadcastTransfer = (0, utils_1.mockReturnValue)({
                transaction_hash: "0x6c087c1676e8269dd81e0777244584d0cbfd39b6997b3477242a008fa9349e11",
                ...utils_1.VALID_TRANSFER_MODEL,
            });
            await address.createTransfer({
                amount: weiAmount,
                assetId: coinbase_1.Coinbase.assets.Wei,
                destination,
                gasless: true,
                skipBatching: true,
            });
            expect(coinbase_1.Coinbase.apiClients.transfer.createTransfer).toHaveBeenCalledWith(address.getWalletId(), address.getId(), expect.objectContaining({
                skip_batching: true,
            }));
        });
        it("should throw an ArgumentError if skipBatching is true but gasless is false", async () => {
            await expect(address.createTransfer({
                amount: weiAmount,
                assetId: coinbase_1.Coinbase.assets.Wei,
                destination,
                skipBatching: true,
            })).rejects.toThrow(errors_1.ArgumentError);
        });
        it("should successfully construct createTransfer request when using a large number that causes scientific notation", async () => {
            coinbase_1.Coinbase.apiClients.transfer.createTransfer = (0, utils_1.mockReturnValue)(utils_1.VALID_TRANSFER_MODEL);
            coinbase_1.Coinbase.apiClients.transfer.broadcastTransfer = (0, utils_1.mockReturnValue)({
                transaction_hash: "0x6c087c1676e8269dd81e0777244584d0cbfd39b6997b3477242a008fa9349e11",
                ...utils_1.VALID_TRANSFER_MODEL,
            });
            coinbase_1.Coinbase.apiClients.externalAddress.getExternalAddressBalance = (0, utils_1.mockFn)(request => {
                const [, , asset_id] = request;
                balanceModel = {
                    amount: "10000000000000000000000",
                    asset: {
                        asset_id,
                        network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                        decimals: 18,
                        contract_address: "0x",
                    },
                };
                return { data: balanceModel };
            });
            // construct amount of 1000 with 18 decimal places which is large enough to cause scientific notation
            const transfer = await address.createTransfer({
                amount: new decimal_js_1.default("1000000000000000000000"),
                assetId: coinbase_1.Coinbase.assets.Wei,
                destination,
            });
            expect(coinbase_1.Coinbase.apiClients.transfer.broadcastTransfer).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.transfer.createTransfer).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.transfer.createTransfer).toHaveBeenCalledWith(address.getWalletId(), address.getId(), {
                amount: "1000000000000000000000",
                asset_id: coinbase_1.Coinbase.assets.Eth,
                destination: destination.getId(),
                gasless: false,
                network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                skip_batching: false,
            });
            expect(transfer).toBeInstanceOf(transfer_1.Transfer);
            expect(transfer.getId()).toBe(utils_1.VALID_TRANSFER_MODEL.transfer_id);
        });
        it("should throw an APIError if the createTransfer API call fails", async () => {
            coinbase_1.Coinbase.apiClients.transfer.createTransfer = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError("Failed to create transfer"));
            await expect(address.createTransfer({
                amount: weiAmount,
                assetId: coinbase_1.Coinbase.assets.Wei,
                destination,
            })).rejects.toThrow(api_error_1.APIError);
        });
        it("should throw an Error if the address key is not provided", async () => {
            const addressWithoutKey = new wallet_address_1.WalletAddress(utils_1.VALID_ADDRESS_MODEL, null);
            await expect(addressWithoutKey.createTransfer({
                amount: weiAmount,
                assetId: coinbase_1.Coinbase.assets.Wei,
                destination,
            })).rejects.toThrow(Error);
        });
        it("should throw an ArgumentError if the Wallet Network ID does not match the Address Network ID", async () => {
            coinbase_1.Coinbase.apiClients.wallet = utils_1.walletsApiMock;
            coinbase_1.Coinbase.apiClients.address = utils_1.addressesApiMock;
            coinbase_1.Coinbase.apiClients.address.createAddress = (0, utils_1.mockReturnValue)((0, utils_1.newAddressModel)(walletId, id, coinbase_1.Coinbase.networks.BaseMainnet));
            coinbase_1.Coinbase.apiClients.wallet.createWallet = (0, utils_1.mockReturnValue)({
                ...utils_1.VALID_WALLET_MODEL,
                network_id: coinbase_1.Coinbase.networks.BaseMainnet,
            });
            coinbase_1.Coinbase.apiClients.wallet.getWallet = (0, utils_1.mockReturnValue)({
                ...utils_1.VALID_WALLET_MODEL,
                network_id: coinbase_1.Coinbase.networks.BaseMainnet,
            });
            const invalidDestination = await wallet_1.Wallet.create({
                networkId: coinbase_1.Coinbase.networks.BaseMainnet,
            });
            await expect(address.createTransfer({
                amount: weiAmount,
                assetId: coinbase_1.Coinbase.assets.Wei,
                destination: invalidDestination,
            })).rejects.toThrow(errors_1.ArgumentError);
        });
        it("should throw an ArgumentError if the Address Network ID does not match the Wallet Network ID", async () => {
            const invalidDestination = new wallet_address_1.WalletAddress((0, utils_1.newAddressModel)("invalidDestination", "", coinbase_1.Coinbase.networks.BaseMainnet), null);
            await expect(address.createTransfer({
                amount: weiAmount,
                assetId: coinbase_1.Coinbase.assets.Wei,
                destination: invalidDestination,
            })).rejects.toThrow(errors_1.ArgumentError);
        });
        it("should throw an APIError if the broadcastTransfer API call fails", async () => {
            coinbase_1.Coinbase.apiClients.transfer.createTransfer = (0, utils_1.mockReturnValue)(utils_1.VALID_TRANSFER_MODEL);
            coinbase_1.Coinbase.apiClients.transfer.broadcastTransfer = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError("Failed to broadcast transfer"));
            await expect(address.createTransfer({
                amount: weiAmount,
                assetId: coinbase_1.Coinbase.assets.Wei,
                destination,
            })).rejects.toThrow(api_error_1.APIError);
        });
        it("should throw an ArgumentError if there are insufficient funds", async () => {
            const insufficientAmount = new decimal_js_1.default("10000000000000000000");
            await expect(address.createTransfer({
                amount: insufficientAmount,
                assetId: coinbase_1.Coinbase.assets.Wei,
                destination,
            })).rejects.toThrow(errors_1.ArgumentError);
        });
        it("should successfully create a transfer when using server signer", async () => {
            coinbase_1.Coinbase.useServerSigner = true;
            coinbase_1.Coinbase.apiClients.transfer.createTransfer = (0, utils_1.mockReturnValue)(utils_1.VALID_TRANSFER_MODEL);
            await address.createTransfer({
                amount: weiAmount,
                assetId: coinbase_1.Coinbase.assets.Wei,
                destination,
            });
            expect(coinbase_1.Coinbase.apiClients.transfer.createTransfer).toHaveBeenCalledTimes(1);
        });
        afterEach(() => {
            jest.restoreAllMocks();
        });
    });
    describe("#listTransfers", () => {
        beforeEach(() => {
            jest.clearAllMocks();
            const pages = ["abc", "def"];
            const response = {
                data: [utils_1.VALID_TRANSFER_MODEL],
                has_more: false,
                next_page: "",
                total_count: 0,
            };
            coinbase_1.Coinbase.apiClients.transfer.listTransfers = (0, utils_1.mockReturnValue)(response);
        });
        it("should return the list of transfers", async () => {
            const paginationResponse = await address.listTransfers();
            const transfers = paginationResponse.data;
            expect(transfers).toHaveLength(1);
            expect(transfers[0]).toBeInstanceOf(transfer_1.Transfer);
            expect(coinbase_1.Coinbase.apiClients.transfer.listTransfers).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.transfer.listTransfers).toHaveBeenCalledWith(address.getWalletId(), address.getId(), 100, undefined);
        });
        it("should raise an APIError when the API call fails", async () => {
            jest.clearAllMocks();
            coinbase_1.Coinbase.apiClients.transfer.listTransfers = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError(""));
            await expect(address.listTransfers()).rejects.toThrow(api_error_1.APIError);
            expect(coinbase_1.Coinbase.apiClients.transfer.listTransfers).toHaveBeenCalledTimes(1);
        });
    });
    describe("#createTrade", () => {
        let addressId;
        let toAddressId;
        let ethBalanceResponse;
        let usdcBalanceResponse;
        let tradeId;
        let transactionHash;
        let unsignedPayload;
        let signedPayload;
        let broadcastTradeRequest;
        let transaction;
        let approveTransaction;
        let createdTrade;
        let transactionModel;
        let tradeModel;
        let broadcastedTransactionModel;
        let broadcastedTradeModel;
        let broadcastedTrade;
        let fromAssetId;
        let normalizedFromAssetId;
        let toAssetId;
        let balanceResponse;
        let destination;
        let amount;
        let useServerSigner;
        beforeEach(() => {
            addressId = "address_id";
            ethBalanceResponse = {
                amount: "1000000000000000000",
                asset: {
                    asset_id: "eth",
                    decimals: 18,
                    network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                    contract_address: "0x",
                },
            };
            usdcBalanceResponse = {
                amount: "10000000000",
                asset: {
                    asset_id: "usdc",
                    decimals: 6,
                    network_id: coinbase_1.Coinbase.networks.BaseSepolia,
                    contract_address: "0x",
                },
            };
            tradeId = crypto.randomUUID();
            transactionHash = "0xdeadbeef";
            unsignedPayload =
                "7b2274797065223a22307832222c22636861696e4964223a2230783134613334222c226e6f6e63" +
                    "65223a22307830222c22746f223a22307834643965346633663464316138623566346637623166" +
                    "356235633762386436623262336231623062222c22676173223a22307835323038222c22676173" +
                    "5072696365223a6e756c6c2c226d61785072696f72697479466565506572476173223a223078" +
                    "3539363832663030222c226d6178466565506572476173223a2230783539363832663030222c22" +
                    "76616c7565223a2230783536626337356532643633313030303030222c22696e707574223a22" +
                    "3078222c226163636573734c697374223a5b5d2c2276223a22307830222c2272223a2230783022" +
                    "2c2273223a22307830222c2279506172697479223a22307830222c2268617368223a2230783664" +
                    "633334306534643663323633653363396561396135656438646561346332383966613861363966" +
                    "3031653635393462333732386230386138323335333433227d";
            signedPayload =
                "02f87683014a34808459682f008459682f00825208944d9e4f3f4d1a8b5f4f7b1f5b5c7b8d6b2b3b1b0b89056bc75e2d6310000080c001a07ae1f4655628ac1b226d60a6243aed786a2d36241ffc0f306159674755f4bd9ca050cd207fdfa6944e2b165775e2ca625b474d1eb40fda0f03f4ca9e286eae3cbe";
            broadcastTradeRequest = { signed_payload: signedPayload };
            transaction = { sign: jest.fn().mockReturnValue(signedPayload) };
            approveTransaction = null;
            createdTrade = {
                id: tradeId,
                transaction: transaction,
                approve_transaction: approveTransaction,
            };
            transactionModel = {
                trade_id: tradeId,
                status: "pending",
                unsigned_payload: unsignedPayload,
            };
            tradeModel = {
                trade_id: tradeId,
                transaction: transactionModel,
                address_id: addressId,
            };
            broadcastedTransactionModel = {
                trade_id: tradeId,
                status: "broadcast",
                unsigned_payload: unsignedPayload,
                signed_payload: signedPayload,
            };
            broadcastedTradeModel = {
                id: tradeId,
                transaction: broadcastedTransactionModel,
                address_id: addressId,
            };
            broadcastedTrade = {
                transaction: transaction,
                id: tradeId,
            };
            fromAssetId = "eth";
            normalizedFromAssetId = "eth";
            toAssetId = "usdc";
            balanceResponse = ethBalanceResponse;
            destination = toAddressId;
            amount = new decimal_js_1.default(0.5);
            coinbase_1.Coinbase.useServerSigner = false;
        });
        describe("when the trade is successful", () => {
            beforeEach(() => {
                jest.clearAllMocks();
                coinbase_1.Coinbase.apiClients.asset = utils_1.assetsApiMock;
                coinbase_1.Coinbase.apiClients.trade = utils_1.tradeApiMock;
                coinbase_1.Coinbase.apiClients.address = utils_1.addressesApiMock;
                coinbase_1.Coinbase.apiClients.address.getAddressBalance = (0, utils_1.mockReturnValue)(balanceResponse);
                coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
                coinbase_1.Coinbase.apiClients.trade.createTrade = (0, utils_1.mockReturnValue)(tradeModel);
                coinbase_1.Coinbase.apiClients.trade.broadcastTrade = (0, utils_1.mockReturnValue)(broadcastedTradeModel);
                jest.spyOn(key, "signTransaction").mockReturnValue(signedPayload);
            });
            it("should return the broadcasted trade", async () => {
                const result = await address.createTrade({
                    amount: amount,
                    fromAssetId: fromAssetId,
                    toAssetId: toAssetId,
                });
                const transaction = result.getTransaction();
                expect(transaction.getSignedPayload()).toEqual(signedPayload);
                expect(transaction.getStatus()).toEqual(types_1.TransactionStatus.BROADCAST);
                expect(transaction.getUnsignedPayload()).toEqual(unsignedPayload);
                expect(coinbase_1.Coinbase.apiClients.trade.createTrade).toHaveBeenCalledWith(address.getWalletId(), address.getId(), {
                    amount: `500000000000000000`,
                    from_asset_id: normalizedFromAssetId,
                    to_asset_id: toAssetId,
                });
                expect(coinbase_1.Coinbase.apiClients.trade.broadcastTrade).toHaveBeenCalledTimes(1);
            });
            describe("when the asset is Gwei", () => {
                beforeEach(() => {
                    fromAssetId = "gwei";
                    normalizedFromAssetId = "eth";
                    amount = new decimal_js_1.default(500000000);
                });
                it("should return the broadcasted trade", async () => {
                    await address.createTrade({
                        amount: amount,
                        fromAssetId: fromAssetId,
                        toAssetId: toAssetId,
                    });
                    expect(coinbase_1.Coinbase.apiClients.trade.createTrade).toHaveBeenCalledWith(address.getWalletId(), address.getId(), {
                        amount: `500000000000000000`,
                        from_asset_id: normalizedFromAssetId,
                        to_asset_id: toAssetId,
                    });
                    expect(coinbase_1.Coinbase.apiClients.trade.broadcastTrade).toHaveBeenCalledTimes(1);
                });
            });
            describe("when the asset is ETH", () => {
                beforeEach(() => {
                    fromAssetId = "eth";
                    normalizedFromAssetId = "eth";
                    amount = new decimal_js_1.default(0.5);
                });
                it("should return the broadcasted trade", async () => {
                    await address.createTrade({
                        amount: amount,
                        fromAssetId: fromAssetId,
                        toAssetId: toAssetId,
                    });
                    expect(coinbase_1.Coinbase.apiClients.trade.createTrade).toHaveBeenCalledWith(address.getWalletId(), address.getId(), {
                        amount: `500000000000000000`,
                        from_asset_id: normalizedFromAssetId,
                        to_asset_id: toAssetId,
                    });
                    expect(coinbase_1.Coinbase.apiClients.trade.broadcastTrade).toHaveBeenCalledTimes(1);
                });
            });
            describe("when the asset is USDC", () => {
                beforeEach(() => {
                    fromAssetId = "usdc";
                    normalizedFromAssetId = "usdc";
                    amount = new decimal_js_1.default(5);
                    balanceResponse = { amount: "5000000", asset: { asset_id: "usdc", decimals: 6 } };
                    coinbase_1.Coinbase.apiClients.externalAddress.getExternalAddressBalance =
                        (0, utils_1.mockReturnValue)(balanceResponse);
                });
                it("should return the broadcasted trade", async () => {
                    await address.createTrade({
                        amount: amount,
                        fromAssetId: fromAssetId,
                        toAssetId: toAssetId,
                    });
                    expect(coinbase_1.Coinbase.apiClients.trade.createTrade).toHaveBeenCalledWith(address.getWalletId(), address.getId(), {
                        amount: `5000000`,
                        from_asset_id: normalizedFromAssetId,
                        to_asset_id: toAssetId,
                    });
                    expect(coinbase_1.Coinbase.apiClients.trade.broadcastTrade).toHaveBeenCalledTimes(1);
                });
            });
        });
        describe("when using server signer", () => {
            beforeEach(() => {
                jest.clearAllMocks();
                coinbase_1.Coinbase.apiClients.asset = utils_1.assetsApiMock;
                coinbase_1.Coinbase.apiClients.trade = utils_1.tradeApiMock;
                coinbase_1.Coinbase.apiClients.address.getAddressBalance = (0, utils_1.mockReturnValue)(balanceResponse);
                coinbase_1.Coinbase.apiClients.trade.createTrade = (0, utils_1.mockReturnValue)(tradeModel);
                coinbase_1.Coinbase.apiClients.asset.getAsset = (0, utils_1.getAssetMock)();
                coinbase_1.Coinbase.useServerSigner = true;
            });
            it("should successfully create a trade", async () => {
                const trade = await address.createTrade({
                    amount: amount,
                    fromAssetId: fromAssetId,
                    toAssetId: toAssetId,
                });
                expect(coinbase_1.Coinbase.apiClients.trade.createTrade).toHaveBeenCalledTimes(1);
                expect(trade).toBeInstanceOf(trade_1.Trade);
                expect(trade.getId()).toBe(tradeId);
            });
        });
        describe("when the address cannot sign", () => {
            it("should raise an Error", async () => {
                const newAddress = new wallet_address_1.WalletAddress(utils_1.VALID_ADDRESS_MODEL, null);
                await expect(newAddress.createTrade({
                    amount: new decimal_js_1.default(100),
                    fromAssetId: "eth",
                    toAssetId: "usdc",
                })).rejects.toThrow(Error);
            });
        });
        describe("when the to fromAssetId is unsupported", () => {
            it("should raise an ArgumentError", async () => {
                await expect(address.createTrade({ amount: new decimal_js_1.default(100), fromAssetId: "XYZ", toAssetId: "eth" })).rejects.toThrow(Error);
            });
        });
        describe("when the to toAssetId is unsupported", () => {
            it("should raise an ArgumentError", async () => {
                await expect(address.createTrade({ amount: new decimal_js_1.default(100), fromAssetId: "eth", toAssetId: "XYZ" })).rejects.toThrow(Error);
            });
        });
        describe("when the balance is insufficient", () => {
            beforeAll(() => {
                coinbase_1.Coinbase.apiClients.address = utils_1.addressesApiMock;
                coinbase_1.Coinbase.apiClients.address.getAddressBalance = (0, utils_1.mockReturnValue)({ amount: "0" });
            });
            it("should raise an Error", async () => {
                await expect(address.createTrade({ amount: new decimal_js_1.default(100), fromAssetId: "eth", toAssetId: "usdc" })).rejects.toThrow(Error);
            });
        });
    });
    describe("#invokeContract", () => {
        let key = ethers_1.ethers.Wallet.createRandom();
        let addressModel;
        let walletAddress;
        let unsignedPayload = utils_1.VALID_CONTRACT_INVOCATION_MODEL.transaction.unsigned_payload;
        let expectedSignedPayload;
        beforeAll(() => {
            coinbase_1.Coinbase.apiClients.contractInvocation = utils_1.contractInvocationApiMock;
        });
        beforeEach(() => {
            jest.clearAllMocks();
            addressModel = (0, utils_1.newAddressModel)((0, crypto_1.randomUUID)(), (0, crypto_1.randomUUID)(), coinbase_1.Coinbase.networks.BaseSepolia);
        });
        describe("when not using a server-signer", () => {
            beforeEach(async () => {
                coinbase_1.Coinbase.useServerSigner = false;
                walletAddress = new wallet_address_1.WalletAddress(addressModel, key);
                const tx = new transaction_1.Transaction(utils_1.VALID_CONTRACT_INVOCATION_MODEL.transaction);
                expectedSignedPayload = await tx.sign(key);
            });
            describe("when it is successful", () => {
                let contractInvocation;
                beforeEach(async () => {
                    coinbase_1.Coinbase.apiClients.contractInvocation.createContractInvocation = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_CONTRACT_INVOCATION_MODEL,
                        address_id: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    coinbase_1.Coinbase.apiClients.contractInvocation.broadcastContractInvocation = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SIGNED_CONTRACT_INVOCATION_MODEL,
                        address_id: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    contractInvocation = await walletAddress.invokeContract({
                        abi: utils_1.MINT_NFT_ABI,
                        args: utils_1.MINT_NFT_ARGS,
                        method: utils_1.VALID_CONTRACT_INVOCATION_MODEL.method,
                        contractAddress: utils_1.VALID_CONTRACT_INVOCATION_MODEL.contract_address,
                    });
                });
                it("returns a contract invocation", async () => {
                    expect(contractInvocation).toBeInstanceOf(contract_invocation_1.ContractInvocation);
                    expect(contractInvocation.getId()).toBe(utils_1.VALID_CONTRACT_INVOCATION_MODEL.contract_invocation_id);
                });
                it("creates the contract invocation", async () => {
                    expect(coinbase_1.Coinbase.apiClients.contractInvocation.createContractInvocation).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                        abi: utils_1.VALID_CONTRACT_INVOCATION_MODEL.abi,
                        args: utils_1.VALID_CONTRACT_INVOCATION_MODEL.args,
                        method: utils_1.VALID_CONTRACT_INVOCATION_MODEL.method,
                        contract_address: utils_1.VALID_CONTRACT_INVOCATION_MODEL.contract_address,
                    });
                    expect(coinbase_1.Coinbase.apiClients.contractInvocation.createContractInvocation).toHaveBeenCalledTimes(1);
                });
                it("broadcasts the contract invocation", async () => {
                    expect(coinbase_1.Coinbase.apiClients.contractInvocation.broadcastContractInvocation).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), utils_1.VALID_CONTRACT_INVOCATION_MODEL.contract_invocation_id, {
                        signed_payload: expectedSignedPayload,
                    });
                    expect(coinbase_1.Coinbase.apiClients.contractInvocation.broadcastContractInvocation).toHaveBeenCalledTimes(1);
                });
            });
            describe("when it is successful invoking a payable contract method", () => {
                let contractInvocation;
                let amount = new decimal_js_1.default("1000");
                let balanceResponse = { amount: "5000000", asset: { asset_id: "eth", decimals: 18 } };
                beforeEach(async () => {
                    coinbase_1.Coinbase.apiClients.contractInvocation.createContractInvocation = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_CONTRACT_INVOCATION_MODEL,
                        address_id: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                        amount,
                    });
                    coinbase_1.Coinbase.apiClients.contractInvocation.broadcastContractInvocation = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SIGNED_CONTRACT_INVOCATION_MODEL,
                        address_id: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                        amount,
                    });
                    coinbase_1.Coinbase.apiClients.externalAddress.getExternalAddressBalance =
                        (0, utils_1.mockReturnValue)(balanceResponse);
                    contractInvocation = await walletAddress.invokeContract({
                        abi: utils_1.MINT_NFT_ABI,
                        args: utils_1.MINT_NFT_ARGS,
                        method: utils_1.VALID_CONTRACT_INVOCATION_MODEL.method,
                        contractAddress: utils_1.VALID_CONTRACT_INVOCATION_MODEL.contract_address,
                        amount,
                        assetId: coinbase_1.Coinbase.assets.Wei,
                    });
                });
                it("returns a contract invocation", async () => {
                    expect(contractInvocation).toBeInstanceOf(contract_invocation_1.ContractInvocation);
                    expect(contractInvocation.getId()).toBe(utils_1.VALID_CONTRACT_INVOCATION_MODEL.contract_invocation_id);
                    expect(contractInvocation.getAmount().toString()).toBe(amount.toString());
                });
                it("creates the contract invocation", async () => {
                    expect(coinbase_1.Coinbase.apiClients.contractInvocation.createContractInvocation).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                        abi: utils_1.VALID_CONTRACT_INVOCATION_MODEL.abi,
                        args: utils_1.VALID_CONTRACT_INVOCATION_MODEL.args,
                        method: utils_1.VALID_CONTRACT_INVOCATION_MODEL.method,
                        contract_address: utils_1.VALID_CONTRACT_INVOCATION_MODEL.contract_address,
                        amount: amount.toString(),
                    });
                    expect(coinbase_1.Coinbase.apiClients.contractInvocation.createContractInvocation).toHaveBeenCalledTimes(1);
                });
                it("broadcasts the contract invocation", async () => {
                    expect(coinbase_1.Coinbase.apiClients.contractInvocation.broadcastContractInvocation).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), utils_1.VALID_CONTRACT_INVOCATION_MODEL.contract_invocation_id, {
                        signed_payload: expectedSignedPayload,
                    });
                    expect(coinbase_1.Coinbase.apiClients.contractInvocation.broadcastContractInvocation).toHaveBeenCalledTimes(1);
                });
                it("checks for sufficient balance", async () => {
                    expect(coinbase_1.Coinbase.apiClients.externalAddress.getExternalAddressBalance).toHaveBeenCalledWith(walletAddress.getNetworkId(), walletAddress.getId(), coinbase_1.Coinbase.assets.Eth);
                    expect(coinbase_1.Coinbase.apiClients.externalAddress.getExternalAddressBalance).toHaveBeenCalledTimes(1);
                });
            });
            describe("when it is fails to invoke a payable contract method", () => {
                let amount = new decimal_js_1.default("1000");
                it("throws an error for invalid input", async () => {
                    await expect(walletAddress.invokeContract({
                        abi: utils_1.MINT_NFT_ABI,
                        args: utils_1.MINT_NFT_ARGS,
                        method: utils_1.VALID_CONTRACT_INVOCATION_MODEL.method,
                        contractAddress: utils_1.VALID_CONTRACT_INVOCATION_MODEL.contract_address,
                        amount,
                    })).rejects.toThrow(Error);
                });
            });
            describe("when no key is loaded", () => {
                beforeEach(() => {
                    walletAddress = new wallet_address_1.WalletAddress(addressModel);
                });
                it("throws an error", async () => {
                    await expect(walletAddress.invokeContract({
                        abi: utils_1.MINT_NFT_ABI,
                        args: utils_1.MINT_NFT_ARGS,
                        method: utils_1.VALID_CONTRACT_INVOCATION_MODEL.method,
                        contractAddress: utils_1.VALID_CONTRACT_INVOCATION_MODEL.contract_address,
                    })).rejects.toThrow(Error);
                });
            });
            describe("when it fails to create a contract invocation", () => {
                beforeEach(() => {
                    coinbase_1.Coinbase.apiClients.contractInvocation.createContractInvocation =
                        (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError({
                            response: {
                                status: 400,
                                data: {
                                    code: "malformed_request",
                                    message: "failed to create contract invocation: invalid abi",
                                },
                            },
                        }));
                });
                it("throws an error", async () => {
                    await expect(walletAddress.invokeContract({
                        abi: { invalid_abi: "abi" },
                        args: utils_1.MINT_NFT_ARGS,
                        method: utils_1.VALID_CONTRACT_INVOCATION_MODEL.method,
                        contractAddress: utils_1.VALID_CONTRACT_INVOCATION_MODEL.contract_address,
                    })).rejects.toThrow(api_error_1.APIError);
                });
            });
            describe("when it fails to broadcast a contract invocation", () => {
                beforeEach(() => {
                    coinbase_1.Coinbase.apiClients.contractInvocation.createContractInvocation = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_CONTRACT_INVOCATION_MODEL,
                        address_id: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    coinbase_1.Coinbase.apiClients.contractInvocation.broadcastContractInvocation =
                        (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError({
                            response: {
                                status: 400,
                                data: {
                                    code: "invalid_signed_payload",
                                    message: "failed to broadcast contract invocation: invalid signed payload",
                                },
                            },
                        }));
                });
                it("throws an error", async () => {
                    await expect(walletAddress.invokeContract({
                        abi: utils_1.MINT_NFT_ABI,
                        args: utils_1.MINT_NFT_ARGS,
                        method: utils_1.VALID_CONTRACT_INVOCATION_MODEL.method,
                        contractAddress: utils_1.VALID_CONTRACT_INVOCATION_MODEL.contract_address,
                    })).rejects.toThrow(api_error_1.APIError);
                });
            });
        });
        describe("when using a server-signer", () => {
            let contractInvocation;
            beforeEach(async () => {
                coinbase_1.Coinbase.useServerSigner = true;
                walletAddress = new wallet_address_1.WalletAddress(addressModel);
            });
            describe("when it is successful", () => {
                beforeEach(async () => {
                    coinbase_1.Coinbase.apiClients.contractInvocation.createContractInvocation = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_CONTRACT_INVOCATION_MODEL,
                        address_id: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    contractInvocation = await walletAddress.invokeContract({
                        abi: utils_1.MINT_NFT_ABI,
                        args: utils_1.MINT_NFT_ARGS,
                        method: utils_1.VALID_CONTRACT_INVOCATION_MODEL.method,
                        contractAddress: utils_1.VALID_CONTRACT_INVOCATION_MODEL.contract_address,
                    });
                });
                it("returns a pending contract invocation", async () => {
                    expect(contractInvocation).toBeInstanceOf(contract_invocation_1.ContractInvocation);
                    expect(contractInvocation.getId()).toBe(utils_1.VALID_CONTRACT_INVOCATION_MODEL.contract_invocation_id);
                    expect(contractInvocation.getStatus()).toBe(types_1.TransactionStatus.PENDING);
                });
                it("creates a contract invocation", async () => {
                    expect(coinbase_1.Coinbase.apiClients.contractInvocation.createContractInvocation).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                        abi: utils_1.VALID_CONTRACT_INVOCATION_MODEL.abi,
                        args: utils_1.VALID_CONTRACT_INVOCATION_MODEL.args,
                        method: utils_1.VALID_CONTRACT_INVOCATION_MODEL.method,
                        contract_address: utils_1.VALID_CONTRACT_INVOCATION_MODEL.contract_address,
                    });
                    expect(coinbase_1.Coinbase.apiClients.contractInvocation.createContractInvocation).toHaveBeenCalledTimes(1);
                });
            });
            describe("when creating a contract invocation fails", () => {
                beforeEach(() => {
                    coinbase_1.Coinbase.apiClients.contractInvocation.createContractInvocation =
                        (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError({
                            response: {
                                status: 400,
                                data: {
                                    code: "malformed_request",
                                    message: "failed to create contract invocation: invalid abi",
                                },
                            },
                        }));
                });
                it("throws an error", async () => {
                    await expect(walletAddress.invokeContract({
                        abi: { invalid_abi: "abi" },
                        args: utils_1.MINT_NFT_ARGS,
                        method: utils_1.VALID_CONTRACT_INVOCATION_MODEL.method,
                        contractAddress: utils_1.VALID_CONTRACT_INVOCATION_MODEL.contract_address,
                    })).rejects.toThrow(api_error_1.APIError);
                });
            });
        });
    });
    describe("#deployToken", () => {
        let key = ethers_1.ethers.Wallet.createRandom();
        let addressModel;
        let walletAddress;
        let expectedSignedPayload;
        beforeAll(() => {
            coinbase_1.Coinbase.apiClients.smartContract = utils_1.smartContractApiMock;
        });
        beforeEach(() => {
            jest.clearAllMocks();
            addressModel = (0, utils_1.newAddressModel)((0, crypto_1.randomUUID)(), (0, crypto_1.randomUUID)(), coinbase_1.Coinbase.networks.BaseSepolia);
        });
        describe("when not using a server-signer", () => {
            beforeEach(async () => {
                coinbase_1.Coinbase.useServerSigner = false;
                walletAddress = new wallet_address_1.WalletAddress(addressModel, key);
                const tx = new transaction_1.Transaction(utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.transaction);
                expectedSignedPayload = await tx.sign(key);
            });
            describe("when it is successful", () => {
                let smartContract;
                beforeEach(async () => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL,
                        deployer_address: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL,
                        address_id: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    smartContract = await walletAddress.deployToken({
                        name: utils_1.ERC20_NAME,
                        symbol: utils_1.ERC20_SYMBOL,
                        totalSupply: utils_1.ERC20_TOTAL_SUPPLY,
                    });
                });
                it("returns a smart contract", async () => {
                    expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
                    expect(smartContract.getId()).toBe(utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.smart_contract_id);
                });
                it("creates the smart contract", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                        type: client_1.SmartContractType.Erc20,
                        options: {
                            name: utils_1.ERC20_NAME,
                            symbol: utils_1.ERC20_SYMBOL,
                            total_supply: utils_1.ERC20_TOTAL_SUPPLY.toString(),
                        },
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledTimes(1);
                });
                it("broadcasts the smart contract", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.smart_contract_id, {
                        signed_payload: expectedSignedPayload,
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract).toHaveBeenCalledTimes(1);
                });
            });
            describe("when it is successful deploying a smart contract", () => {
                let smartContract;
                beforeEach(async () => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL,
                        deployer_address: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL,
                        deployer_address: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    coinbase_1.Coinbase.apiClients.smartContract.getSmartContract = (0, utils_1.mockReturnValue)(utils_1.VALID_SMART_CONTRACT_ERC20_MODEL);
                    smartContract = await walletAddress.deployToken({
                        name: utils_1.ERC20_NAME,
                        symbol: utils_1.ERC20_SYMBOL,
                        totalSupply: utils_1.ERC20_TOTAL_SUPPLY,
                    });
                });
                it("returns a smart contract", async () => {
                    expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
                    expect(smartContract.getId()).toBe(utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.smart_contract_id);
                });
                it("creates the smart contract", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                        type: client_1.SmartContractType.Erc20,
                        options: {
                            name: utils_1.ERC20_NAME,
                            symbol: utils_1.ERC20_SYMBOL,
                            total_supply: utils_1.ERC20_TOTAL_SUPPLY.toString(),
                        },
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledTimes(1);
                });
                it("broadcasts the smart contract", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.smart_contract_id, {
                        signed_payload: expectedSignedPayload,
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract).toHaveBeenCalledTimes(1);
                });
            });
            describe("when no key is loaded", () => {
                beforeEach(() => {
                    walletAddress = new wallet_address_1.WalletAddress(addressModel);
                });
                it("throws an error", async () => {
                    await expect(walletAddress.deployToken({
                        name: utils_1.ERC20_NAME,
                        symbol: utils_1.ERC20_SYMBOL,
                        totalSupply: utils_1.ERC20_TOTAL_SUPPLY,
                    })).rejects.toThrow(Error);
                });
            });
            describe("when it fails to create a smart contract", () => {
                beforeEach(() => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError({
                        response: {
                            status: 400,
                            data: {
                                code: "malformed_request",
                                message: "failed to create smart contract: invalid abi",
                            },
                        },
                    }));
                });
                it("throws an error", async () => {
                    await expect(walletAddress.deployToken({
                        name: utils_1.ERC20_NAME,
                        symbol: utils_1.ERC20_SYMBOL,
                        totalSupply: utils_1.ERC20_TOTAL_SUPPLY,
                    })).rejects.toThrow(api_error_1.APIError);
                });
            });
            describe("when it fails to broadcast a smart contract", () => {
                beforeEach(() => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_CONTRACT_INVOCATION_MODEL,
                        address_id: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError({
                        response: {
                            status: 400,
                            data: {
                                code: "invalid_signed_payload",
                                message: "failed to broadcast smart contract: invalid signed payload",
                            },
                        },
                    }));
                });
                it("throws an error", async () => {
                    await expect(walletAddress.deployToken({
                        name: utils_1.ERC20_NAME,
                        symbol: utils_1.ERC20_SYMBOL,
                        totalSupply: utils_1.ERC20_TOTAL_SUPPLY,
                    })).rejects.toThrow(api_error_1.APIError);
                });
            });
        });
        describe("when using a server-signer", () => {
            let smartContract;
            beforeEach(async () => {
                coinbase_1.Coinbase.useServerSigner = true;
                walletAddress = new wallet_address_1.WalletAddress(addressModel);
            });
            describe("when it is successful", () => {
                beforeEach(async () => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_ERC20_MODEL,
                        address_id: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    smartContract = await walletAddress.deployToken({
                        name: utils_1.ERC20_NAME,
                        symbol: utils_1.ERC20_SYMBOL,
                        totalSupply: utils_1.ERC20_TOTAL_SUPPLY,
                    });
                });
                it("returns a pending contract invocation", async () => {
                    expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
                    expect(smartContract.getId()).toBe(utils_1.VALID_SMART_CONTRACT_ERC20_MODEL.smart_contract_id);
                    expect(smartContract.getTransaction().getStatus()).toBe(types_1.TransactionStatus.PENDING);
                });
                it("creates a contract invocation", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                        type: client_1.SmartContractType.Erc20,
                        options: {
                            name: utils_1.ERC20_NAME,
                            symbol: utils_1.ERC20_SYMBOL,
                            total_supply: utils_1.ERC20_TOTAL_SUPPLY.toString(),
                        },
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledTimes(1);
                });
            });
            describe("when creating a contract invocation fails", () => {
                beforeEach(() => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError({
                        response: {
                            status: 400,
                            data: {
                                code: "malformed_request",
                                message: "failed to create contract invocation: invalid abi",
                            },
                        },
                    }));
                });
                it("throws an error", async () => {
                    await expect(walletAddress.deployToken({
                        name: utils_1.ERC20_NAME,
                        symbol: utils_1.ERC20_SYMBOL,
                        totalSupply: utils_1.ERC20_TOTAL_SUPPLY,
                    })).rejects.toThrow(api_error_1.APIError);
                });
            });
        });
    });
    describe("#deployNFT", () => {
        let key = ethers_1.ethers.Wallet.createRandom();
        let addressModel;
        let walletAddress;
        let expectedSignedPayload;
        beforeAll(() => {
            coinbase_1.Coinbase.apiClients.smartContract = utils_1.smartContractApiMock;
        });
        beforeEach(() => {
            jest.clearAllMocks();
            addressModel = (0, utils_1.newAddressModel)((0, crypto_1.randomUUID)(), (0, crypto_1.randomUUID)(), coinbase_1.Coinbase.networks.BaseSepolia);
        });
        describe("when not using a server-signer", () => {
            beforeEach(async () => {
                coinbase_1.Coinbase.useServerSigner = false;
                walletAddress = new wallet_address_1.WalletAddress(addressModel, key);
                const tx = new transaction_1.Transaction(utils_1.VALID_SMART_CONTRACT_ERC721_MODEL.transaction);
                expectedSignedPayload = await tx.sign(key);
            });
            describe("when it is successful", () => {
                let smartContract;
                beforeEach(async () => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_ERC721_MODEL,
                        deployer_address: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_ERC721_MODEL,
                        address_id: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    smartContract = await walletAddress.deployNFT({
                        name: utils_1.ERC721_NAME,
                        symbol: utils_1.ERC721_SYMBOL,
                        baseURI: utils_1.ERC721_BASE_URI,
                    });
                });
                it("returns a smart contract", async () => {
                    expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
                    expect(smartContract.getId()).toBe(utils_1.VALID_SMART_CONTRACT_ERC721_MODEL.smart_contract_id);
                });
                it("creates the smart contract", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                        type: client_1.SmartContractType.Erc721,
                        options: {
                            name: utils_1.ERC721_NAME,
                            symbol: utils_1.ERC721_SYMBOL,
                            base_uri: utils_1.ERC721_BASE_URI,
                        },
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledTimes(1);
                });
                it("broadcasts the smart contract", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), utils_1.VALID_SMART_CONTRACT_ERC721_MODEL.smart_contract_id, {
                        signed_payload: expectedSignedPayload,
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract).toHaveBeenCalledTimes(1);
                });
            });
            describe("when it is successful deploying a smart contract", () => {
                let smartContract;
                beforeEach(async () => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_ERC721_MODEL,
                        deployer_address: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_ERC721_MODEL,
                        deployer_address: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    coinbase_1.Coinbase.apiClients.smartContract.getSmartContract = (0, utils_1.mockReturnValue)(utils_1.VALID_SMART_CONTRACT_ERC721_MODEL);
                    smartContract = await walletAddress.deployNFT({
                        name: utils_1.ERC721_NAME,
                        symbol: utils_1.ERC721_SYMBOL,
                        baseURI: utils_1.ERC721_BASE_URI,
                    });
                });
                it("returns a smart contract", async () => {
                    expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
                    expect(smartContract.getId()).toBe(utils_1.VALID_SMART_CONTRACT_ERC721_MODEL.smart_contract_id);
                });
                it("creates the smart contract", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                        type: client_1.SmartContractType.Erc721,
                        options: {
                            name: utils_1.ERC721_NAME,
                            symbol: utils_1.ERC721_SYMBOL,
                            base_uri: utils_1.ERC721_BASE_URI,
                        },
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledTimes(1);
                });
                it("broadcasts the smart contract", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), utils_1.VALID_SMART_CONTRACT_ERC721_MODEL.smart_contract_id, {
                        signed_payload: expectedSignedPayload,
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract).toHaveBeenCalledTimes(1);
                });
            });
            describe("when no key is loaded", () => {
                beforeEach(() => {
                    walletAddress = new wallet_address_1.WalletAddress(addressModel);
                });
                it("throws an error", async () => {
                    await expect(walletAddress.deployNFT({
                        name: utils_1.ERC721_NAME,
                        symbol: utils_1.ERC721_SYMBOL,
                        baseURI: utils_1.ERC721_BASE_URI,
                    })).rejects.toThrow(Error);
                });
            });
            describe("when it fails to create a smart contract", () => {
                beforeEach(() => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError({
                        response: {
                            status: 400,
                            data: {
                                code: "malformed_request",
                                message: "failed to create smart contract: invalid abi",
                            },
                        },
                    }));
                });
                it("throws an error", async () => {
                    await expect(walletAddress.deployNFT({
                        name: utils_1.ERC721_NAME,
                        symbol: utils_1.ERC721_SYMBOL,
                        baseURI: utils_1.ERC721_BASE_URI,
                    })).rejects.toThrow(api_error_1.APIError);
                });
            });
            describe("when it fails to broadcast a smart contract", () => {
                beforeEach(() => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_CONTRACT_INVOCATION_MODEL,
                        address_id: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError({
                        response: {
                            status: 400,
                            data: {
                                code: "invalid_signed_payload",
                                message: "failed to broadcast smart contract: invalid signed payload",
                            },
                        },
                    }));
                });
                it("throws an error", async () => {
                    await expect(walletAddress.deployNFT({
                        name: utils_1.ERC721_NAME,
                        symbol: utils_1.ERC721_SYMBOL,
                        baseURI: utils_1.ERC721_BASE_URI,
                    })).rejects.toThrow(api_error_1.APIError);
                });
            });
        });
        describe("when using a server-signer", () => {
            let smartContract;
            beforeEach(async () => {
                coinbase_1.Coinbase.useServerSigner = true;
                walletAddress = new wallet_address_1.WalletAddress(addressModel);
            });
            describe("when it is successful", () => {
                beforeEach(async () => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_ERC721_MODEL,
                        address_id: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    smartContract = await walletAddress.deployNFT({
                        name: utils_1.ERC721_NAME,
                        symbol: utils_1.ERC721_SYMBOL,
                        baseURI: utils_1.ERC721_BASE_URI,
                    });
                });
                it("returns a pending contract invocation", async () => {
                    expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
                    expect(smartContract.getId()).toBe(utils_1.VALID_SMART_CONTRACT_ERC721_MODEL.smart_contract_id);
                    expect(smartContract.getTransaction().getStatus()).toBe(types_1.TransactionStatus.PENDING);
                });
                it("creates a contract invocation", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                        type: client_1.SmartContractType.Erc721,
                        options: {
                            name: utils_1.ERC721_NAME,
                            symbol: utils_1.ERC721_SYMBOL,
                            base_uri: utils_1.ERC721_BASE_URI,
                        },
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledTimes(1);
                });
            });
            describe("when creating a contract invocation fails", () => {
                beforeEach(() => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError({
                        response: {
                            status: 400,
                            data: {
                                code: "malformed_request",
                                message: "failed to create contract invocation: invalid abi",
                            },
                        },
                    }));
                });
                it("throws an error", async () => {
                    await expect(walletAddress.deployNFT({
                        name: utils_1.ERC721_NAME,
                        symbol: utils_1.ERC721_SYMBOL,
                        baseURI: utils_1.ERC721_BASE_URI,
                    })).rejects.toThrow(api_error_1.APIError);
                });
            });
        });
    });
    describe("#deployMultiToken", () => {
        let key = ethers_1.ethers.Wallet.createRandom();
        let addressModel;
        let walletAddress;
        let expectedSignedPayload;
        beforeAll(() => {
            coinbase_1.Coinbase.apiClients.smartContract = utils_1.smartContractApiMock;
        });
        beforeEach(() => {
            jest.clearAllMocks();
            addressModel = (0, utils_1.newAddressModel)((0, crypto_1.randomUUID)(), (0, crypto_1.randomUUID)(), coinbase_1.Coinbase.networks.BaseSepolia);
        });
        describe("when not using a server-signer", () => {
            beforeEach(async () => {
                coinbase_1.Coinbase.useServerSigner = false;
                walletAddress = new wallet_address_1.WalletAddress(addressModel, key);
                const tx = new transaction_1.Transaction(utils_1.VALID_SMART_CONTRACT_ERC1155_MODEL.transaction);
                expectedSignedPayload = await tx.sign(key);
            });
            describe("when it is successful", () => {
                let smartContract;
                beforeEach(async () => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_ERC1155_MODEL,
                        deployer_address: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_ERC1155_MODEL,
                        address_id: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    smartContract = await walletAddress.deployMultiToken({
                        uri: utils_1.ERC1155_URI,
                    });
                });
                it("returns a smart contract", async () => {
                    expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
                    expect(smartContract.getId()).toBe(utils_1.VALID_SMART_CONTRACT_ERC1155_MODEL.smart_contract_id);
                });
                it("creates the smart contract", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                        type: client_1.SmartContractType.Erc1155,
                        options: {
                            uri: utils_1.ERC1155_URI,
                        },
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledTimes(1);
                });
                it("broadcasts the smart contract", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), utils_1.VALID_SMART_CONTRACT_ERC1155_MODEL.smart_contract_id, {
                        signed_payload: expectedSignedPayload,
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract).toHaveBeenCalledTimes(1);
                });
            });
            describe("when it is successful deploying a smart contract", () => {
                let smartContract;
                beforeEach(async () => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_ERC1155_MODEL,
                        deployer_address: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_ERC1155_MODEL,
                        deployer_address: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    coinbase_1.Coinbase.apiClients.smartContract.getSmartContract = (0, utils_1.mockReturnValue)(utils_1.VALID_SMART_CONTRACT_ERC1155_MODEL);
                    smartContract = await walletAddress.deployMultiToken({
                        uri: utils_1.ERC1155_URI,
                    });
                });
                it("returns a smart contract", async () => {
                    expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
                    expect(smartContract.getId()).toBe(utils_1.VALID_SMART_CONTRACT_ERC1155_MODEL.smart_contract_id);
                });
                it("creates the smart contract", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                        type: client_1.SmartContractType.Erc1155,
                        options: {
                            uri: utils_1.ERC1155_URI,
                        },
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledTimes(1);
                });
                it("broadcasts the smart contract", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), utils_1.VALID_SMART_CONTRACT_ERC1155_MODEL.smart_contract_id, {
                        signed_payload: expectedSignedPayload,
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract).toHaveBeenCalledTimes(1);
                });
            });
            describe("when no key is loaded", () => {
                beforeEach(() => {
                    walletAddress = new wallet_address_1.WalletAddress(addressModel);
                });
                it("throws an error", async () => {
                    await expect(walletAddress.deployMultiToken({
                        uri: utils_1.ERC1155_URI,
                    })).rejects.toThrow(Error);
                });
            });
            describe("when it fails to create a smart contract", () => {
                beforeEach(() => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError({
                        response: {
                            status: 400,
                            data: {
                                code: "malformed_request",
                                message: "failed to create smart contract: invalid abi",
                            },
                        },
                    }));
                });
                it("throws an error", async () => {
                    await expect(walletAddress.deployMultiToken({
                        uri: utils_1.ERC1155_URI,
                    })).rejects.toThrow(api_error_1.APIError);
                });
            });
            describe("when it fails to broadcast a smart contract", () => {
                beforeEach(() => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_CONTRACT_INVOCATION_MODEL,
                        address_id: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError({
                        response: {
                            status: 400,
                            data: {
                                code: "invalid_signed_payload",
                                message: "failed to broadcast smart contract: invalid signed payload",
                            },
                        },
                    }));
                });
                it("throws an error", async () => {
                    await expect(walletAddress.deployMultiToken({
                        uri: utils_1.ERC1155_URI,
                    })).rejects.toThrow(api_error_1.APIError);
                });
            });
        });
        describe("when using a server-signer", () => {
            let smartContract;
            beforeEach(async () => {
                coinbase_1.Coinbase.useServerSigner = true;
                walletAddress = new wallet_address_1.WalletAddress(addressModel);
            });
            describe("when it is successful", () => {
                beforeEach(async () => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_ERC1155_MODEL,
                        address_id: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    smartContract = await walletAddress.deployMultiToken({
                        uri: utils_1.ERC1155_URI,
                    });
                });
                it("returns a pending contract invocation", async () => {
                    expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
                    expect(smartContract.getId()).toBe(utils_1.VALID_SMART_CONTRACT_ERC1155_MODEL.smart_contract_id);
                    expect(smartContract.getTransaction().getStatus()).toBe(types_1.TransactionStatus.PENDING);
                });
                it("creates a contract invocation", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                        type: client_1.SmartContractType.Erc1155,
                        options: {
                            uri: utils_1.ERC1155_URI,
                        },
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledTimes(1);
                });
            });
            describe("when creating a contract invocation fails", () => {
                beforeEach(() => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError({
                        response: {
                            status: 400,
                            data: {
                                code: "malformed_request",
                                message: "failed to create contract invocation: invalid abi",
                            },
                        },
                    }));
                });
                it("throws an error", async () => {
                    await expect(walletAddress.deployMultiToken({
                        uri: utils_1.ERC1155_URI,
                    })).rejects.toThrow(api_error_1.APIError);
                });
            });
        });
    });
    describe("#deployContract", () => {
        let key = ethers_1.ethers.Wallet.createRandom();
        let addressModel;
        let walletAddress;
        let expectedSignedPayload;
        beforeAll(() => {
            coinbase_1.Coinbase.apiClients.smartContract = utils_1.smartContractApiMock;
        });
        beforeEach(() => {
            jest.clearAllMocks();
            addressModel = (0, utils_1.newAddressModel)((0, crypto_1.randomUUID)(), (0, crypto_1.randomUUID)(), coinbase_1.Coinbase.networks.BaseSepolia);
        });
        describe("when not using a server-signer", () => {
            beforeEach(async () => {
                coinbase_1.Coinbase.useServerSigner = false;
                walletAddress = new wallet_address_1.WalletAddress(addressModel, key);
                const tx = new transaction_1.Transaction(utils_1.VALID_SMART_CONTRACT_CUSTOM_MODEL.transaction);
                expectedSignedPayload = await tx.sign(key);
            });
            describe("when it is successful", () => {
                let smartContract;
                beforeEach(async () => {
                    coinbase_1.Coinbase.apiClients.smartContract.compileSmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_COMPILED_CONTRACT_MODEL,
                    });
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_CUSTOM_MODEL,
                        deployer_address: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_CUSTOM_MODEL,
                        address_id: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    smartContract = await walletAddress.deployContract({
                        solidityVersion: "0.8.0",
                        solidityInputJson: "{}",
                        contractName: "TestContract",
                        constructorArgs: {
                            arg1: "arg1",
                            arg2: "arg2",
                        },
                    });
                });
                it("returns a smart contract", async () => {
                    expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
                    expect(smartContract.getId()).toBe(utils_1.VALID_SMART_CONTRACT_CUSTOM_MODEL.smart_contract_id);
                });
                it("creates the smart contract", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                        type: client_1.SmartContractType.Custom,
                        options: `{"arg1":"arg1","arg2":"arg2"}`,
                        compiled_smart_contract_id: "test-compiled-contract-1",
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledTimes(1);
                });
                it("broadcasts the smart contract", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), utils_1.VALID_SMART_CONTRACT_CUSTOM_MODEL.smart_contract_id, {
                        signed_payload: expectedSignedPayload,
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract).toHaveBeenCalledTimes(1);
                });
            });
            describe("when it is successful deploying a smart contract", () => {
                let smartContract;
                beforeEach(async () => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_CUSTOM_MODEL,
                        deployer_address: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_CUSTOM_MODEL,
                        deployer_address: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    coinbase_1.Coinbase.apiClients.smartContract.getSmartContract = (0, utils_1.mockReturnValue)(utils_1.VALID_SMART_CONTRACT_CUSTOM_MODEL);
                    smartContract = await walletAddress.deployContract({
                        solidityVersion: "0.8.0",
                        solidityInputJson: "{}",
                        contractName: "TestContract",
                        constructorArgs: {
                            arg1: "arg1",
                            arg2: "arg2",
                        },
                    });
                });
                it("returns a smart contract", async () => {
                    expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
                    expect(smartContract.getId()).toBe(utils_1.VALID_SMART_CONTRACT_CUSTOM_MODEL.smart_contract_id);
                });
                it("creates the smart contract", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                        type: client_1.SmartContractType.Custom,
                        options: `{"arg1":"arg1","arg2":"arg2"}`,
                        compiled_smart_contract_id: "test-compiled-contract-1",
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledTimes(1);
                });
                it("broadcasts the smart contract", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), utils_1.VALID_SMART_CONTRACT_CUSTOM_MODEL.smart_contract_id, {
                        signed_payload: expectedSignedPayload,
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract).toHaveBeenCalledTimes(1);
                });
            });
            describe("when no key is loaded", () => {
                beforeEach(() => {
                    walletAddress = new wallet_address_1.WalletAddress(addressModel);
                });
                it("throws an error", async () => {
                    await expect(walletAddress.deployContract({
                        solidityVersion: "0.8.0",
                        solidityInputJson: "{}",
                        contractName: "TestContract",
                        constructorArgs: ["arg1", "arg2"],
                    })).rejects.toThrow(Error);
                });
            });
            describe("when it fails to create a smart contract", () => {
                beforeEach(() => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError({
                        response: {
                            status: 400,
                            data: {
                                code: "malformed_request",
                                message: "failed to create smart contract: invalid abi",
                            },
                        },
                    }));
                });
                it("throws an error", async () => {
                    await expect(walletAddress.deployContract({
                        solidityVersion: "0.8.0",
                        solidityInputJson: "{}",
                        contractName: "TestContract",
                        constructorArgs: ["arg1", "arg2"],
                    })).rejects.toThrow(api_error_1.APIError);
                });
            });
            describe("when it fails to broadcast a smart contract", () => {
                beforeEach(() => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_CUSTOM_MODEL,
                        address_id: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError({
                        response: {
                            status: 400,
                            data: {
                                code: "invalid_signed_payload",
                                message: "failed to broadcast smart contract: invalid signed payload",
                            },
                        },
                    }));
                });
                it("throws an error", async () => {
                    await expect(walletAddress.deployContract({
                        solidityVersion: "0.8.0",
                        solidityInputJson: "{}",
                        contractName: "TestContract",
                        constructorArgs: ["arg1", "arg2"],
                    })).rejects.toThrow(api_error_1.APIError);
                });
            });
        });
        describe("when using a server-signer", () => {
            let smartContract;
            beforeEach(() => {
                coinbase_1.Coinbase.useServerSigner = true;
                walletAddress = new wallet_address_1.WalletAddress(addressModel);
            });
            describe("when it is successful", () => {
                beforeEach(async () => {
                    coinbase_1.Coinbase.apiClients.smartContract.createSmartContract = (0, utils_1.mockReturnValue)({
                        ...utils_1.VALID_SMART_CONTRACT_CUSTOM_MODEL,
                        address_id: walletAddress.getId(),
                        wallet_id: walletAddress.getWalletId(),
                    });
                    smartContract = await walletAddress.deployContract({
                        solidityVersion: "0.8.0",
                        solidityInputJson: "{}",
                        contractName: "TestContract",
                        constructorArgs: {
                            arg1: "arg1",
                            arg2: "arg2",
                        },
                    });
                });
                it("returns a pending contract invocation", async () => {
                    expect(smartContract).toBeInstanceOf(smart_contract_1.SmartContract);
                    expect(smartContract.getId()).toBe(utils_1.VALID_SMART_CONTRACT_CUSTOM_MODEL.smart_contract_id);
                    expect(smartContract.getTransaction().getStatus()).toBe(types_1.TransactionStatus.PENDING);
                });
                it("creates a contract invocation", async () => {
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                        type: client_1.SmartContractType.Custom,
                        options: `{"arg1":"arg1","arg2":"arg2"}`,
                        compiled_smart_contract_id: "test-compiled-contract-1",
                    });
                    expect(coinbase_1.Coinbase.apiClients.smartContract.createSmartContract).toHaveBeenCalledTimes(1);
                });
            });
        });
    });
    describe("#createPayloadSignature", () => {
        let key = ethers_1.ethers.Wallet.createRandom();
        let addressModel;
        let walletAddress;
        let unsignedPayload = utils_1.VALID_PAYLOAD_SIGNATURE_MODEL.unsigned_payload;
        let signature;
        beforeAll(() => {
            coinbase_1.Coinbase.apiClients.address = utils_1.addressesApiMock;
        });
        beforeEach(() => {
            jest.clearAllMocks();
        });
        describe("when not using a server-signer", () => {
            beforeEach(() => {
                addressModel = (0, utils_1.newAddressModel)((0, crypto_1.randomUUID)(), (0, crypto_1.randomUUID)(), coinbase_1.Coinbase.networks.BaseSepolia);
                walletAddress = new wallet_address_1.WalletAddress(addressModel, key);
                signature = key.signingKey.sign(unsignedPayload).serialized;
                coinbase_1.Coinbase.useServerSigner = false;
            });
            it("should successfully create a payload signature", async () => {
                coinbase_1.Coinbase.apiClients.address.createPayloadSignature = (0, utils_1.mockReturnValue)(utils_1.VALID_PAYLOAD_SIGNATURE_MODEL);
                const payloadSignature = await walletAddress.createPayloadSignature(unsignedPayload);
                expect(coinbase_1.Coinbase.apiClients.address.createPayloadSignature).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                    unsigned_payload: unsignedPayload,
                    signature,
                });
                expect(coinbase_1.Coinbase.apiClients.address.createPayloadSignature).toHaveBeenCalledTimes(1);
                expect(payloadSignature).toBeInstanceOf(payload_signature_1.PayloadSignature);
            });
            it("should throw an error when no key is loaded", async () => {
                walletAddress = new wallet_address_1.WalletAddress(addressModel);
                expect(async () => {
                    await walletAddress.createPayloadSignature(unsignedPayload);
                }).rejects.toThrow(Error);
            });
            it("should throw an APIError when the API call to create a payload signature fails", async () => {
                coinbase_1.Coinbase.apiClients.address.createPayloadSignature = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError("Failed to create payload signature"));
                expect(async () => {
                    await walletAddress.createPayloadSignature(unsignedPayload);
                }).rejects.toThrow(Error);
                expect(coinbase_1.Coinbase.apiClients.address.createPayloadSignature).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                    unsigned_payload: unsignedPayload,
                    signature,
                });
                expect(coinbase_1.Coinbase.apiClients.address.createPayloadSignature).toHaveBeenCalledTimes(1);
            });
        });
        describe("when using a server-signer", () => {
            beforeEach(() => {
                addressModel = (0, utils_1.newAddressModel)((0, crypto_1.randomUUID)(), (0, crypto_1.randomUUID)(), coinbase_1.Coinbase.networks.BaseSepolia);
                walletAddress = new wallet_address_1.WalletAddress(addressModel);
                coinbase_1.Coinbase.useServerSigner = true;
            });
            it("should successfully create a payload signature", async () => {
                coinbase_1.Coinbase.apiClients.address.createPayloadSignature = (0, utils_1.mockReturnValue)(utils_1.VALID_PAYLOAD_SIGNATURE_MODEL);
                const payloadSignature = await walletAddress.createPayloadSignature(unsignedPayload);
                expect(coinbase_1.Coinbase.apiClients.address.createPayloadSignature).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                    unsigned_payload: unsignedPayload,
                });
                expect(coinbase_1.Coinbase.apiClients.address.createPayloadSignature).toHaveBeenCalledTimes(1);
                expect(payloadSignature).toBeInstanceOf(payload_signature_1.PayloadSignature);
            });
            it("should throw an APIError when the API call to create a payload signature fails", async () => {
                coinbase_1.Coinbase.apiClients.address.createPayloadSignature = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError("Failed to create payload signature"));
                expect(async () => {
                    await walletAddress.createPayloadSignature(unsignedPayload);
                }).rejects.toThrow(Error);
                expect(coinbase_1.Coinbase.apiClients.address.createPayloadSignature).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), {
                    unsigned_payload: unsignedPayload,
                });
                expect(coinbase_1.Coinbase.apiClients.address.createPayloadSignature).toHaveBeenCalledTimes(1);
            });
        });
    });
    describe("#getPayloadSignature", () => {
        let key = ethers_1.ethers.Wallet.createRandom();
        let addressModel;
        let walletAddress;
        let payloadSignatureId = utils_1.VALID_PAYLOAD_SIGNATURE_MODEL.payload_signature_id;
        beforeAll(() => {
            coinbase_1.Coinbase.apiClients.address = utils_1.addressesApiMock;
        });
        beforeEach(() => {
            addressModel = (0, utils_1.newAddressModel)((0, crypto_1.randomUUID)(), (0, crypto_1.randomUUID)(), coinbase_1.Coinbase.networks.BaseSepolia);
            walletAddress = new wallet_address_1.WalletAddress(addressModel, key);
            coinbase_1.Coinbase.useServerSigner = false;
            jest.clearAllMocks();
        });
        it("should successfully get the payload signature", async () => {
            coinbase_1.Coinbase.apiClients.address.getPayloadSignature = (0, utils_1.mockReturnValue)(utils_1.VALID_PAYLOAD_SIGNATURE_MODEL);
            const payloadSignature = await walletAddress.getPayloadSignature(payloadSignatureId);
            expect(coinbase_1.Coinbase.apiClients.address.getPayloadSignature).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), payloadSignatureId);
            expect(coinbase_1.Coinbase.apiClients.address.getPayloadSignature).toHaveBeenCalledTimes(1);
            expect(payloadSignature).toBeInstanceOf(payload_signature_1.PayloadSignature);
        });
        it("should throw an APIError when the API call to get the payload signature fails", async () => {
            coinbase_1.Coinbase.apiClients.address.getPayloadSignature = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError("Failed to get payload signature"));
            expect(async () => {
                await walletAddress.getPayloadSignature(payloadSignatureId);
            }).rejects.toThrow(Error);
            expect(coinbase_1.Coinbase.apiClients.address.getPayloadSignature).toHaveBeenCalledWith(walletAddress.getWalletId(), walletAddress.getId(), payloadSignatureId);
            expect(coinbase_1.Coinbase.apiClients.address.getPayloadSignature).toHaveBeenCalledTimes(1);
        });
    });
    describe("#listPayloadSignatures", () => {
        let key = ethers_1.ethers.Wallet.createRandom();
        let addressModel;
        let walletAddress;
        beforeAll(() => {
            coinbase_1.Coinbase.apiClients.address = utils_1.addressesApiMock;
        });
        beforeEach(() => {
            addressModel = (0, utils_1.newAddressModel)((0, crypto_1.randomUUID)(), (0, crypto_1.randomUUID)(), coinbase_1.Coinbase.networks.BaseSepolia);
            walletAddress = new wallet_address_1.WalletAddress(addressModel, key);
            coinbase_1.Coinbase.useServerSigner = false;
            jest.clearAllMocks();
        });
        it("should successfully list payload signatures", async () => {
            coinbase_1.Coinbase.apiClients.address.listPayloadSignatures = (0, utils_1.mockReturnValue)(utils_1.VALID_PAYLOAD_SIGNATURE_LIST);
            const paginationResponse = await walletAddress.listPayloadSignatures();
            expect(coinbase_1.Coinbase.apiClients.address.listPayloadSignatures).toHaveBeenCalledTimes(1);
            expect(paginationResponse.data).toHaveLength(utils_1.VALID_PAYLOAD_SIGNATURE_LIST.data.length);
            expect(paginationResponse.hasMore).toBe(false);
            expect(paginationResponse.nextPage).toBe(undefined);
        });
        it("should throw an APIError when the API call to list payload signatures fails", async () => {
            coinbase_1.Coinbase.apiClients.address.listPayloadSignatures = (0, utils_1.mockReturnRejectedValue)(new api_error_1.APIError("Failed to list payload signatures"));
            expect(async () => {
                await walletAddress.listPayloadSignatures();
            }).rejects.toThrow(Error);
            expect(coinbase_1.Coinbase.apiClients.address.listPayloadSignatures).toHaveBeenCalledTimes(1);
        });
    });
});
