/**
 * Coinbase Platform API
 * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.
 *
 * The version of the OpenAPI document: 0.0.1-alpha
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import type { RequestArgs } from './base';
import { BaseAPI } from './base';
/**
 *
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * The ID of the wallet that owns the address
     * @type {string}
     * @memberof Address
     */
    'wallet_id': string;
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Address
     */
    'network_id': string;
    /**
     * The public key from which the address is derived.
     * @type {string}
     * @memberof Address
     */
    'public_key': string;
    /**
     * The onchain address derived on the server-side.
     * @type {string}
     * @memberof Address
     */
    'address_id': string;
    /**
     * The index of the address in the wallet.
     * @type {number}
     * @memberof Address
     */
    'index': number;
}
/**
 *
 * @export
 * @interface AddressBalanceList
 */
export interface AddressBalanceList {
    /**
     *
     * @type {Array<Balance>}
     * @memberof AddressBalanceList
     */
    'data': Array<Balance>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof AddressBalanceList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof AddressBalanceList
     */
    'next_page': string;
    /**
     * The total number of balances for the wallet.
     * @type {number}
     * @memberof AddressBalanceList
     */
    'total_count': number;
}
/**
 *
 * @export
 * @interface AddressHistoricalBalanceList
 */
export interface AddressHistoricalBalanceList {
    /**
     *
     * @type {Array<HistoricalBalance>}
     * @memberof AddressHistoricalBalanceList
     */
    'data': Array<HistoricalBalance>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof AddressHistoricalBalanceList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof AddressHistoricalBalanceList
     */
    'next_page': string;
}
/**
 *
 * @export
 * @interface AddressList
 */
export interface AddressList {
    /**
     *
     * @type {Array<Address>}
     * @memberof AddressList
     */
    'data': Array<Address>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof AddressList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof AddressList
     */
    'next_page': string;
    /**
     * The total number of addresses for the wallet.
     * @type {number}
     * @memberof AddressList
     */
    'total_count': number;
}
/**
 * The reputation score with metadata of a blockchain address.
 * @export
 * @interface AddressReputation
 */
export interface AddressReputation {
    /**
     * The score of a wallet address, ranging from -100 to 100. A negative score indicates a bad reputation, while a positive score indicates a good reputation.
     * @type {number}
     * @memberof AddressReputation
     */
    'score': number;
    /**
     *
     * @type {AddressReputationMetadata}
     * @memberof AddressReputation
     */
    'metadata': AddressReputationMetadata;
}
/**
 * The metadata for the reputation score of onchain address.
 * @export
 * @interface AddressReputationMetadata
 */
export interface AddressReputationMetadata {
    /**
     * The total number of transactions performed by the address.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'total_transactions': number;
    /**
     * The number of unique days the address was active.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'unique_days_active': number;
    /**
     * The longest streak of consecutive active days.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'longest_active_streak': number;
    /**
     * The current streak of consecutive active days.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'current_active_streak': number;
    /**
     * The total number of days the address has been active.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'activity_period_days': number;
    /**
     * The number of token swaps performed by the address.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'token_swaps_performed': number;
    /**
     * The number of bridge transactions performed by the address.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'bridge_transactions_performed': number;
    /**
     * The number of lend, borrow, or stake transactions performed by the address.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'lend_borrow_stake_transactions': number;
    /**
     * The number of interactions with ENS contracts.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'ens_contract_interactions': number;
    /**
     * The number of smart contracts deployed by the address.
     * @type {number}
     * @memberof AddressReputationMetadata
     */
    'smart_contract_deployments': number;
}
/**
 *
 * @export
 * @interface AddressTransactionList
 */
export interface AddressTransactionList {
    /**
     *
     * @type {Array<Transaction>}
     * @memberof AddressTransactionList
     */
    'data': Array<Transaction>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof AddressTransactionList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof AddressTransactionList
     */
    'next_page': string;
}
/**
 * An asset onchain scoped to a particular network, e.g. ETH on base-sepolia, or the USDC ERC20 Token on ethereum-mainnet.
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Asset
     */
    'network_id': string;
    /**
     * The ID for the asset on the network
     * @type {string}
     * @memberof Asset
     */
    'asset_id': string;
    /**
     * The number of decimals the asset supports. This is used to convert from atomic units to base units.
     * @type {number}
     * @memberof Asset
     */
    'decimals'?: number;
    /**
     * The optional contract address for the asset. This will be specified for smart contract-based assets, for example ERC20s.
     * @type {string}
     * @memberof Asset
     */
    'contract_address'?: string;
}
/**
 * The balance of an asset onchain
 * @export
 * @interface Balance
 */
export interface Balance {
    /**
     * The amount in the atomic units of the asset
     * @type {string}
     * @memberof Balance
     */
    'amount': string;
    /**
     *
     * @type {Asset}
     * @memberof Balance
     */
    'asset': Asset;
}
/**
 *
 * @export
 * @interface BroadcastContractInvocationRequest
 */
export interface BroadcastContractInvocationRequest {
    /**
     * The hex-encoded signed payload of the contract invocation
     * @type {string}
     * @memberof BroadcastContractInvocationRequest
     */
    'signed_payload': string;
}
/**
 *
 * @export
 * @interface BroadcastExternalTransferRequest
 */
export interface BroadcastExternalTransferRequest {
    /**
     * The hex-encoded signed payload of the external transfer
     * @type {string}
     * @memberof BroadcastExternalTransferRequest
     */
    'signed_payload': string;
}
/**
 *
 * @export
 * @interface BroadcastStakingOperationRequest
 */
export interface BroadcastStakingOperationRequest {
    /**
     * The hex-encoded signed payload of the staking operation.
     * @type {string}
     * @memberof BroadcastStakingOperationRequest
     */
    'signed_payload': string;
    /**
     * The index in the transaction array of the staking operation.
     * @type {number}
     * @memberof BroadcastStakingOperationRequest
     */
    'transaction_index': number;
}
/**
 *
 * @export
 * @interface BroadcastTradeRequest
 */
export interface BroadcastTradeRequest {
    /**
     * The hex-encoded signed payload of the trade
     * @type {string}
     * @memberof BroadcastTradeRequest
     */
    'signed_payload': string;
    /**
     * The hex-encoded signed payload of the approval transaction
     * @type {string}
     * @memberof BroadcastTradeRequest
     */
    'approve_transaction_signed_payload'?: string;
}
/**
 *
 * @export
 * @interface BroadcastTransferRequest
 */
export interface BroadcastTransferRequest {
    /**
     * The hex-encoded signed payload of the transfer
     * @type {string}
     * @memberof BroadcastTransferRequest
     */
    'signed_payload': string;
}
/**
 *
 * @export
 * @interface BuildStakingOperationRequest
 */
export interface BuildStakingOperationRequest {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof BuildStakingOperationRequest
     */
    'network_id': string;
    /**
     * The ID of the asset being staked
     * @type {string}
     * @memberof BuildStakingOperationRequest
     */
    'asset_id': string;
    /**
     * The onchain address from which the staking transaction originates and is responsible for signing the transaction.
     * @type {string}
     * @memberof BuildStakingOperationRequest
     */
    'address_id': string;
    /**
     * The type of staking operation
     * @type {string}
     * @memberof BuildStakingOperationRequest
     */
    'action': string;
    /**
     * Additional options for the staking operation.
     * @type {{ [key: string]: string; }}
     * @memberof BuildStakingOperationRequest
     */
    'options': {
        [key: string]: string;
    };
}
/**
 *
 * @export
 * @interface CompileSmartContractRequest
 */
export interface CompileSmartContractRequest {
    /**
     * The JSON input containing the Solidity code, dependencies, and compiler settings.
     * @type {string}
     * @memberof CompileSmartContractRequest
     */
    'solidity_input_json': string;
    /**
     * The name of the contract to compile.
     * @type {string}
     * @memberof CompileSmartContractRequest
     */
    'contract_name': string;
    /**
     * The version of the Solidity compiler to use.
     * @type {string}
     * @memberof CompileSmartContractRequest
     */
    'solidity_compiler_version': string;
}
/**
 * Represents a compiled smart contract that can be deployed onchain
 * @export
 * @interface CompiledSmartContract
 */
export interface CompiledSmartContract {
    /**
     * The unique identifier of the compiled smart contract.
     * @type {string}
     * @memberof CompiledSmartContract
     */
    'compiled_smart_contract_id'?: string;
    /**
     * The JSON-encoded input for the Solidity compiler
     * @type {string}
     * @memberof CompiledSmartContract
     */
    'solidity_input_json'?: string;
    /**
     * The contract creation bytecode which will be used with constructor arguments to deploy the contract
     * @type {string}
     * @memberof CompiledSmartContract
     */
    'contract_creation_bytecode'?: string;
    /**
     * The JSON-encoded ABI of the contract
     * @type {string}
     * @memberof CompiledSmartContract
     */
    'abi'?: string;
    /**
     * The name of the smart contract to deploy
     * @type {string}
     * @memberof CompiledSmartContract
     */
    'contract_name'?: string;
}
/**
 * Represents a single decoded event emitted by a smart contract
 * @export
 * @interface ContractEvent
 */
export interface ContractEvent {
    /**
     * The name of the blockchain network
     * @type {string}
     * @memberof ContractEvent
     */
    'network_id': string;
    /**
     * The name of the blockchain project or protocol
     * @type {string}
     * @memberof ContractEvent
     */
    'protocol_name': string;
    /**
     * The name of the specific contract within the project
     * @type {string}
     * @memberof ContractEvent
     */
    'contract_name': string;
    /**
     * The name of the event emitted by the contract
     * @type {string}
     * @memberof ContractEvent
     */
    'event_name': string;
    /**
     * The signature of the event, including parameter types
     * @type {string}
     * @memberof ContractEvent
     */
    'sig': string;
    /**
     * The first four bytes of the Keccak hash of the event signature
     * @type {string}
     * @memberof ContractEvent
     */
    'four_bytes': string;
    /**
     * The EVM address of the smart contract
     * @type {string}
     * @memberof ContractEvent
     */
    'contract_address': string;
    /**
     * The timestamp of the block in which the event was emitted
     * @type {string}
     * @memberof ContractEvent
     */
    'block_time': string;
    /**
     * The block number in which the event was emitted
     * @type {number}
     * @memberof ContractEvent
     */
    'block_height': number;
    /**
     * The transaction hash in which the event was emitted
     * @type {string}
     * @memberof ContractEvent
     */
    'tx_hash': string;
    /**
     * The index of the transaction within the block
     * @type {number}
     * @memberof ContractEvent
     */
    'tx_index': number;
    /**
     * The index of the event within the transaction
     * @type {number}
     * @memberof ContractEvent
     */
    'event_index': number;
    /**
     * The event data in a stringified format
     * @type {string}
     * @memberof ContractEvent
     */
    'data': string;
}
/**
 * A list of contract events with pagination information
 * @export
 * @interface ContractEventList
 */
export interface ContractEventList {
    /**
     * An array of ContractEvent objects
     * @type {Array<ContractEvent>}
     * @memberof ContractEventList
     */
    'data': Array<ContractEvent>;
    /**
     * The page token to be used to fetch the next page
     * @type {string}
     * @memberof ContractEventList
     */
    'next_page': string;
    /**
     * True if this list has another page of items after this one that can be fetched
     * @type {boolean}
     * @memberof ContractEventList
     */
    'has_more': boolean;
}
/**
 * A contract invocation onchain.
 * @export
 * @interface ContractInvocation
 */
export interface ContractInvocation {
    /**
     * The ID of the blockchain network.
     * @type {string}
     * @memberof ContractInvocation
     */
    'network_id': string;
    /**
     * The ID of the wallet that owns the address.
     * @type {string}
     * @memberof ContractInvocation
     */
    'wallet_id': string;
    /**
     * The onchain address of the address invoking the contract.
     * @type {string}
     * @memberof ContractInvocation
     */
    'address_id': string;
    /**
     * The ID of the contract invocation.
     * @type {string}
     * @memberof ContractInvocation
     */
    'contract_invocation_id': string;
    /**
     * The onchain address of the contract.
     * @type {string}
     * @memberof ContractInvocation
     */
    'contract_address': string;
    /**
     * The method to be invoked on the contract.
     * @type {string}
     * @memberof ContractInvocation
     */
    'method': string;
    /**
     * The JSON-encoded arguments to pass to the contract method. The keys should be the argument names and the values should be the argument values.
     * @type {string}
     * @memberof ContractInvocation
     */
    'args': string;
    /**
     * The JSON-encoded ABI of the contract.
     * @type {string}
     * @memberof ContractInvocation
     */
    'abi'?: string;
    /**
     * The amount to send to the contract for a payable method
     * @type {string}
     * @memberof ContractInvocation
     */
    'amount': string;
    /**
     *
     * @type {Transaction}
     * @memberof ContractInvocation
     */
    'transaction': Transaction;
}
/**
 *
 * @export
 * @interface ContractInvocationList
 */
export interface ContractInvocationList {
    /**
     *
     * @type {Array<ContractInvocation>}
     * @memberof ContractInvocationList
     */
    'data': Array<ContractInvocation>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof ContractInvocationList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof ContractInvocationList
     */
    'next_page': string;
    /**
     * The total number of contract invocations for the address in the wallet.
     * @type {number}
     * @memberof ContractInvocationList
     */
    'total_count': number;
}
/**
 *
 * @export
 * @interface CreateAddressRequest
 */
export interface CreateAddressRequest {
    /**
     * The public key from which the address will be derived.
     * @type {string}
     * @memberof CreateAddressRequest
     */
    'public_key'?: string;
    /**
     * An attestation signed by the private key that is associated with the wallet. The attestation will be a hex-encoded signature of a json payload with fields `wallet_id` and `public_key`, signed by the private key associated with the public_key set in the request.
     * @type {string}
     * @memberof CreateAddressRequest
     */
    'attestation'?: string;
    /**
     * The index of the address within the wallet.
     * @type {number}
     * @memberof CreateAddressRequest
     */
    'address_index'?: number;
}
/**
 *
 * @export
 * @interface CreateContractInvocationRequest
 */
export interface CreateContractInvocationRequest {
    /**
     * The address of the contract to invoke.
     * @type {string}
     * @memberof CreateContractInvocationRequest
     */
    'contract_address': string;
    /**
     * The method to invoke on the contract.
     * @type {string}
     * @memberof CreateContractInvocationRequest
     */
    'method': string;
    /**
     * The JSON-encoded arguments to pass to the contract method. The keys should be the argument names and the values should be the argument values.
     * @type {string}
     * @memberof CreateContractInvocationRequest
     */
    'args': string;
    /**
     * The JSON-encoded ABI of the contract.
     * @type {string}
     * @memberof CreateContractInvocationRequest
     */
    'abi'?: string;
    /**
     * The amount in atomic units of the native asset to send to the contract for a payable method
     * @type {string}
     * @memberof CreateContractInvocationRequest
     */
    'amount'?: string;
}
/**
 *
 * @export
 * @interface CreateExternalTransferRequest
 */
export interface CreateExternalTransferRequest {
    /**
     * The amount to transfer
     * @type {string}
     * @memberof CreateExternalTransferRequest
     */
    'amount': string;
    /**
     * The ID of the asset to transfer. Can be an asset symbol or a token contract address.
     * @type {string}
     * @memberof CreateExternalTransferRequest
     */
    'asset_id': string;
    /**
     * The destination address, which can be a 0x address, Basename, or ENS name
     * @type {string}
     * @memberof CreateExternalTransferRequest
     */
    'destination': string;
    /**
     * Whether the transfer uses sponsored gas
     * @type {boolean}
     * @memberof CreateExternalTransferRequest
     */
    'gasless': boolean;
    /**
     * When true, the transfer will be submitted immediately. Otherwise, the transfer will be batched. Defaults to false. Note: Requires the gasless option to be set to true.
     * @type {boolean}
     * @memberof CreateExternalTransferRequest
     */
    'skip_batching'?: boolean;
}
/**
 *
 * @export
 * @interface CreateFundOperationRequest
 */
export interface CreateFundOperationRequest {
    /**
     * The amount of the asset to fund the address with in atomic units.
     * @type {string}
     * @memberof CreateFundOperationRequest
     */
    'amount': string;
    /**
     * The ID of the asset to fund the address with. Can be an asset symbol or a token contract address.
     * @type {string}
     * @memberof CreateFundOperationRequest
     */
    'asset_id': string;
    /**
     * The Optional ID of the fund quote to fund the address with. If omitted we will generate a quote and immediately execute it.
     * @type {string}
     * @memberof CreateFundOperationRequest
     */
    'fund_quote_id'?: string;
}
/**
 *
 * @export
 * @interface CreateFundQuoteRequest
 */
export interface CreateFundQuoteRequest {
    /**
     * The amount of the asset to fund the address with in atomic units.
     * @type {string}
     * @memberof CreateFundQuoteRequest
     */
    'amount': string;
    /**
     * The ID of the asset to fund the address with. Can be an asset symbol alias or a token contract address.
     * @type {string}
     * @memberof CreateFundQuoteRequest
     */
    'asset_id': string;
}
/**
 *
 * @export
 * @interface CreatePayloadSignatureRequest
 */
export interface CreatePayloadSignatureRequest {
    /**
     * The unsigned payload.
     * @type {string}
     * @memberof CreatePayloadSignatureRequest
     */
    'unsigned_payload': string;
    /**
     * The signature of the payload.
     * @type {string}
     * @memberof CreatePayloadSignatureRequest
     */
    'signature'?: string;
}
/**
 *
 * @export
 * @interface CreateServerSignerRequest
 */
export interface CreateServerSignerRequest {
    /**
     * The ID of the server signer for the 1 of 1 server signer.
     * @type {string}
     * @memberof CreateServerSignerRequest
     */
    'server_signer_id'?: string;
    /**
     * The enrollment data of the server signer. This will be the base64 encoded server-signer-id for the 1 of 1 server signer.
     * @type {string}
     * @memberof CreateServerSignerRequest
     */
    'enrollment_data': string;
    /**
     * Whether the Server-Signer uses MPC.
     * @type {boolean}
     * @memberof CreateServerSignerRequest
     */
    'is_mpc': boolean;
}
/**
 *
 * @export
 * @interface CreateSmartContractRequest
 */
export interface CreateSmartContractRequest {
    /**
     *
     * @type {SmartContractType}
     * @memberof CreateSmartContractRequest
     */
    'type': SmartContractType;
    /**
     *
     * @type {SmartContractOptions}
     * @memberof CreateSmartContractRequest
     */
    'options': SmartContractOptions;
    /**
     * The optional UUID of the compiled smart contract to deploy. This field is only required when SmartContractType is set to custom.
     * @type {string}
     * @memberof CreateSmartContractRequest
     */
    'compiled_smart_contract_id'?: string;
}
/**
 *
 * @export
 * @interface CreateStakingOperationRequest
 */
export interface CreateStakingOperationRequest {
    /**
     * The ID of the blockchain network.
     * @type {string}
     * @memberof CreateStakingOperationRequest
     */
    'network_id': string;
    /**
     * The ID of the asset being staked.
     * @type {string}
     * @memberof CreateStakingOperationRequest
     */
    'asset_id': string;
    /**
     * The type of staking operation.
     * @type {string}
     * @memberof CreateStakingOperationRequest
     */
    'action': string;
    /**
     * Additional options for the staking operation.
     * @type {{ [key: string]: string; }}
     * @memberof CreateStakingOperationRequest
     */
    'options': {
        [key: string]: string;
    };
}
/**
 *
 * @export
 * @interface CreateTradeRequest
 */
export interface CreateTradeRequest {
    /**
     * The amount to trade
     * @type {string}
     * @memberof CreateTradeRequest
     */
    'amount': string;
    /**
     * The ID of the asset to trade
     * @type {string}
     * @memberof CreateTradeRequest
     */
    'from_asset_id': string;
    /**
     * The ID of the asset to receive from the trade
     * @type {string}
     * @memberof CreateTradeRequest
     */
    'to_asset_id': string;
}
/**
 *
 * @export
 * @interface CreateTransferRequest
 */
export interface CreateTransferRequest {
    /**
     * The amount to transfer
     * @type {string}
     * @memberof CreateTransferRequest
     */
    'amount': string;
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof CreateTransferRequest
     */
    'network_id': string;
    /**
     * The ID of the asset to transfer. Can be an asset symbol or a token contract address.
     * @type {string}
     * @memberof CreateTransferRequest
     */
    'asset_id': string;
    /**
     * The destination address, which can be a 0x address, Basename, or ENS name
     * @type {string}
     * @memberof CreateTransferRequest
     */
    'destination': string;
    /**
     * Whether the transfer uses sponsored gas
     * @type {boolean}
     * @memberof CreateTransferRequest
     */
    'gasless'?: boolean;
    /**
     * When true, the transfer will be submitted immediately. Otherwise, the transfer will be batched. Defaults to false
     * @type {boolean}
     * @memberof CreateTransferRequest
     */
    'skip_batching'?: boolean;
}
/**
 *
 * @export
 * @interface CreateWalletRequest
 */
export interface CreateWalletRequest {
    /**
     *
     * @type {CreateWalletRequestWallet}
     * @memberof CreateWalletRequest
     */
    'wallet': CreateWalletRequestWallet;
}
/**
 * Parameters for configuring a wallet
 * @export
 * @interface CreateWalletRequestWallet
 */
export interface CreateWalletRequestWallet {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof CreateWalletRequestWallet
     */
    'network_id': string;
    /**
     * Whether the wallet should use the project\'s server signer or if the addresses in the wallets will belong to a private key the developer manages. Defaults to false.
     * @type {boolean}
     * @memberof CreateWalletRequestWallet
     */
    'use_server_signer'?: boolean;
}
/**
 *
 * @export
 * @interface CreateWalletWebhookRequest
 */
export interface CreateWalletWebhookRequest {
    /**
     * The URL to which the notifications will be sent.
     * @type {string}
     * @memberof CreateWalletWebhookRequest
     */
    'notification_uri': string;
    /**
     * The custom header to be used for x-webhook-signature header on callbacks, so developers can verify the requests are coming from Coinbase.
     * @type {string}
     * @memberof CreateWalletWebhookRequest
     */
    'signature_header'?: string;
}
/**
 *
 * @export
 * @interface CreateWebhookRequest
 */
export interface CreateWebhookRequest {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'network_id': string;
    /**
     *
     * @type {WebhookEventType}
     * @memberof CreateWebhookRequest
     */
    'event_type': WebhookEventType;
    /**
     *
     * @type {WebhookEventTypeFilter}
     * @memberof CreateWebhookRequest
     */
    'event_type_filter'?: WebhookEventTypeFilter;
    /**
     * Webhook will monitor all events that matches any one of the event filters.
     * @type {Array<WebhookEventFilter>}
     * @memberof CreateWebhookRequest
     */
    'event_filters'?: Array<WebhookEventFilter>;
    /**
     * The URL to which the notifications will be sent
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'notification_uri': string;
    /**
     * The custom header to be used for x-webhook-signature header on callbacks, so developers can verify the requests are coming from Coinbase.
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'signature_header'?: string;
}
/**
 * An amount in cryptocurrency
 * @export
 * @interface CryptoAmount
 */
export interface CryptoAmount {
    /**
     * The amount of the crypto in atomic units
     * @type {string}
     * @memberof CryptoAmount
     */
    'amount': string;
    /**
     *
     * @type {Asset}
     * @memberof CryptoAmount
     */
    'asset': Asset;
}
/**
 *
 * @export
 * @interface DeploySmartContractRequest
 */
export interface DeploySmartContractRequest {
    /**
     * The hex-encoded signed payload of the contract deployment transaction.
     * @type {string}
     * @memberof DeploySmartContractRequest
     */
    'signed_payload': string;
}
/**
 * Represents an event triggered by an ERC-20 token transfer on the blockchain. Contains information about the transaction, block, and involved addresses.
 * @export
 * @interface ERC20TransferEvent
 */
export interface ERC20TransferEvent {
    /**
     * Unique identifier for the webhook that triggered this event.
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'webhookId'?: string;
    /**
     * Type of event, in this case, an ERC-20 token transfer.
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'eventType'?: string;
    /**
     * Blockchain network where the event occurred.
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'network'?: string;
    /**
     * Hash of the block containing the transaction.
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'blockHash'?: string;
    /**
     * Number of the block containing the transaction.
     * @type {number}
     * @memberof ERC20TransferEvent
     */
    'blockNumber'?: number;
    /**
     * Timestamp when the block was mined.
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'blockTime'?: string;
    /**
     * Hash of the transaction that triggered the event.
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'transactionHash'?: string;
    /**
     * Position of the transaction within the block.
     * @type {number}
     * @memberof ERC20TransferEvent
     */
    'transactionIndex'?: number;
    /**
     * Position of the event log within the transaction.
     * @type {number}
     * @memberof ERC20TransferEvent
     */
    'logIndex'?: number;
    /**
     * Address of the ERC-20 token contract.
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'contractAddress'?: string;
    /**
     * Address of the sender in the token transfer.
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'from'?: string;
    /**
     * Address of the recipient in the token transfer.
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'to'?: string;
    /**
     * Amount of tokens transferred, typically in the smallest unit (e.g., wei for Ethereum).
     * @type {string}
     * @memberof ERC20TransferEvent
     */
    'value'?: string;
}
/**
 * Represents an event triggered by an ERC-721 token transfer on the blockchain. Contains information about the transaction, block, and involved addresses.
 * @export
 * @interface ERC721TransferEvent
 */
export interface ERC721TransferEvent {
    /**
     * Unique identifier for the webhook that triggered this event.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'webhookId'?: string;
    /**
     * Type of event, in this case, an ERC-721 token transfer.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'eventType'?: string;
    /**
     * Blockchain network where the event occurred.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'network'?: string;
    /**
     * Hash of the block containing the transaction.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'blockHash'?: string;
    /**
     * Number of the block containing the transaction.
     * @type {number}
     * @memberof ERC721TransferEvent
     */
    'blockNumber'?: number;
    /**
     * Timestamp when the block was mined.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'blockTime'?: string;
    /**
     * Hash of the transaction that triggered the event.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'transactionHash'?: string;
    /**
     * Position of the transaction within the block.
     * @type {number}
     * @memberof ERC721TransferEvent
     */
    'transactionIndex'?: number;
    /**
     * Position of the event log within the transaction.
     * @type {number}
     * @memberof ERC721TransferEvent
     */
    'logIndex'?: number;
    /**
     * Address of the ERC-721 token contract.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'contractAddress'?: string;
    /**
     * Address of the sender in the token transfer.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'from'?: string;
    /**
     * Address of the recipient in the token transfer.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'to'?: string;
    /**
     * Unique identifier of the NFT being transferred.
     * @type {string}
     * @memberof ERC721TransferEvent
     */
    'tokenId'?: string;
}
/**
 *
 * @export
 * @interface EthereumTokenTransfer
 */
export interface EthereumTokenTransfer {
    /**
     *
     * @type {string}
     * @memberof EthereumTokenTransfer
     */
    'contract_address': string;
    /**
     *
     * @type {string}
     * @memberof EthereumTokenTransfer
     */
    'from_address': string;
    /**
     *
     * @type {string}
     * @memberof EthereumTokenTransfer
     */
    'to_address': string;
    /**
     * The value of the transaction in atomic units of the token being transfer for ERC20 or ERC1155 contracts.
     * @type {string}
     * @memberof EthereumTokenTransfer
     */
    'value'?: string;
    /**
     * The ID of ERC721 or ERC1155 token being transferred.
     * @type {string}
     * @memberof EthereumTokenTransfer
     */
    'token_id'?: string;
    /**
     *
     * @type {number}
     * @memberof EthereumTokenTransfer
     */
    'log_index': number;
    /**
     *
     * @type {TokenTransferType}
     * @memberof EthereumTokenTransfer
     */
    'token_transfer_type': TokenTransferType;
}
/**
 *
 * @export
 * @interface EthereumTransaction
 */
export interface EthereumTransaction {
    /**
     * The onchain address of the sender.
     * @type {string}
     * @memberof EthereumTransaction
     */
    'from': string;
    /**
     * The amount of gas spent in the transaction.
     * @type {number}
     * @memberof EthereumTransaction
     */
    'gas'?: number;
    /**
     * The price per gas spent in the transaction in atomic units of the native asset.
     * @type {number}
     * @memberof EthereumTransaction
     */
    'gas_price'?: number;
    /**
     * The hash of the transaction as a hexadecimal string, prefixed with 0x.
     * @type {string}
     * @memberof EthereumTransaction
     */
    'hash'?: string;
    /**
     * The input data of the transaction.
     * @type {string}
     * @memberof EthereumTransaction
     */
    'input'?: string;
    /**
     * The nonce of the transaction in the source address.
     * @type {number}
     * @memberof EthereumTransaction
     */
    'nonce'?: number;
    /**
     * The onchain address of the receiver.
     * @type {string}
     * @memberof EthereumTransaction
     */
    'to': string;
    /**
     * The index of the transaction in the block.
     * @type {number}
     * @memberof EthereumTransaction
     */
    'index'?: number;
    /**
     * The value of the transaction in atomic units of the native asset.
     * @type {string}
     * @memberof EthereumTransaction
     */
    'value'?: string;
    /**
     * The EIP-2718 transaction type. See https://eips.ethereum.org/EIPS/eip-2718 for more details.
     * @type {number}
     * @memberof EthereumTransaction
     */
    'type'?: number;
    /**
     * The max fee per gas as defined in EIP-1559. https://eips.ethereum.org/EIPS/eip-1559 for more details.
     * @type {number}
     * @memberof EthereumTransaction
     */
    'max_fee_per_gas'?: number;
    /**
     * The max priority fee per gas as defined in EIP-1559. https://eips.ethereum.org/EIPS/eip-1559 for more details.
     * @type {number}
     * @memberof EthereumTransaction
     */
    'max_priority_fee_per_gas'?: number;
    /**
     * The confirmed priority fee per gas as defined in EIP-1559. https://eips.ethereum.org/EIPS/eip-1559 for more details.
     * @type {number}
     * @memberof EthereumTransaction
     */
    'priority_fee_per_gas'?: number;
    /**
     *
     * @type {EthereumTransactionAccessList}
     * @memberof EthereumTransaction
     */
    'transaction_access_list'?: EthereumTransactionAccessList;
    /**
     *
     * @type {Array<EthereumTokenTransfer>}
     * @memberof EthereumTransaction
     */
    'token_transfers'?: Array<EthereumTokenTransfer>;
    /**
     *
     * @type {Array<EthereumTransactionFlattenedTrace>}
     * @memberof EthereumTransaction
     */
    'flattened_traces'?: Array<EthereumTransactionFlattenedTrace>;
    /**
     * The timestamp of the block in which the event was emitted
     * @type {string}
     * @memberof EthereumTransaction
     */
    'block_timestamp'?: string;
    /**
     * This is for handling optimism rollup specific EIP-2718 transaction type field.
     * @type {string}
     * @memberof EthereumTransaction
     */
    'mint'?: string;
    /**
     * RLP encoded transaction as a hex string (prefixed with 0x) for native compatibility with popular eth clients such as etherjs, viem etc.
     * @type {string}
     * @memberof EthereumTransaction
     */
    'rlp_encoded_tx'?: string;
}
/**
 *
 * @export
 * @interface EthereumTransactionAccess
 */
export interface EthereumTransactionAccess {
    /**
     *
     * @type {string}
     * @memberof EthereumTransactionAccess
     */
    'address'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof EthereumTransactionAccess
     */
    'storage_keys'?: Array<string>;
}
/**
 *
 * @export
 * @interface EthereumTransactionAccessList
 */
export interface EthereumTransactionAccessList {
    /**
     *
     * @type {Array<EthereumTransactionAccess>}
     * @memberof EthereumTransactionAccessList
     */
    'access_list'?: Array<EthereumTransactionAccess>;
}
/**
 *
 * @export
 * @interface EthereumTransactionFlattenedTrace
 */
export interface EthereumTransactionFlattenedTrace {
    /**
     *
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'error'?: string;
    /**
     *
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'type'?: string;
    /**
     *
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'from'?: string;
    /**
     *
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'to'?: string;
    /**
     *
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'value'?: string;
    /**
     *
     * @type {number}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'gas'?: number;
    /**
     *
     * @type {number}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'gas_used'?: number;
    /**
     *
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'input'?: string;
    /**
     *
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'output'?: string;
    /**
     *
     * @type {number}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'sub_traces'?: number;
    /**
     *
     * @type {Array<number>}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'trace_address'?: Array<number>;
    /**
     *
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'trace_type'?: string;
    /**
     *
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'call_type'?: string;
    /**
     *
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'trace_id'?: string;
    /**
     *
     * @type {number}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'status'?: number;
    /**
     *
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'block_hash'?: string;
    /**
     *
     * @type {number}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'block_number'?: number;
    /**
     *
     * @type {string}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'transaction_hash'?: string;
    /**
     *
     * @type {number}
     * @memberof EthereumTransactionFlattenedTrace
     */
    'transaction_index'?: number;
}
/**
 * An Ethereum validator.
 * @export
 * @interface EthereumValidatorMetadata
 */
export interface EthereumValidatorMetadata {
    /**
     * The index of the validator in the validator set.
     * @type {string}
     * @memberof EthereumValidatorMetadata
     */
    'index': string;
    /**
     * The public key of the validator.
     * @type {string}
     * @memberof EthereumValidatorMetadata
     */
    'public_key': string;
    /**
     * The address to which the validator\'s rewards are sent.
     * @type {string}
     * @memberof EthereumValidatorMetadata
     */
    'withdrawal_address': string;
    /**
     * Whether the validator has been slashed.
     * @type {boolean}
     * @memberof EthereumValidatorMetadata
     */
    'slashed': boolean;
    /**
     * The epoch at which the validator was activated.
     * @type {string}
     * @memberof EthereumValidatorMetadata
     */
    'activationEpoch': string;
    /**
     * The epoch at which the validator exited.
     * @type {string}
     * @memberof EthereumValidatorMetadata
     */
    'exitEpoch': string;
    /**
     * The epoch at which the validator can withdraw.
     * @type {string}
     * @memberof EthereumValidatorMetadata
     */
    'withdrawableEpoch': string;
    /**
     *
     * @type {Balance}
     * @memberof EthereumValidatorMetadata
     */
    'balance': Balance;
    /**
     *
     * @type {Balance}
     * @memberof EthereumValidatorMetadata
     */
    'effective_balance': Balance;
}
/**
 * The faucet transaction
 * @export
 * @interface FaucetTransaction
 */
export interface FaucetTransaction {
    /**
     * The transaction hash of the transaction the faucet created.
     * @type {string}
     * @memberof FaucetTransaction
     */
    'transaction_hash': string;
    /**
     * Link to the transaction on the blockchain explorer.
     * @type {string}
     * @memberof FaucetTransaction
     */
    'transaction_link': string;
    /**
     *
     * @type {Transaction}
     * @memberof FaucetTransaction
     */
    'transaction': Transaction;
}
/**
 *
 * @export
 * @interface FeatureSet
 */
export interface FeatureSet {
    /**
     * Whether the network supports a faucet
     * @type {boolean}
     * @memberof FeatureSet
     */
    'faucet': boolean;
    /**
     * Whether the network supports Server-Signers
     * @type {boolean}
     * @memberof FeatureSet
     */
    'server_signer': boolean;
    /**
     * Whether the network supports transfers
     * @type {boolean}
     * @memberof FeatureSet
     */
    'transfer': boolean;
    /**
     * Whether the network supports trading
     * @type {boolean}
     * @memberof FeatureSet
     */
    'trade': boolean;
    /**
     * Whether the network supports staking
     * @type {boolean}
     * @memberof FeatureSet
     */
    'stake': boolean;
    /**
     * Whether the network supports gasless sends
     * @type {boolean}
     * @memberof FeatureSet
     */
    'gasless_send': boolean;
}
/**
 *
 * @export
 * @interface FetchHistoricalStakingBalances200Response
 */
export interface FetchHistoricalStakingBalances200Response {
    /**
     *
     * @type {Array<StakingBalance>}
     * @memberof FetchHistoricalStakingBalances200Response
     */
    'data': Array<StakingBalance>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof FetchHistoricalStakingBalances200Response
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof FetchHistoricalStakingBalances200Response
     */
    'next_page': string;
}
/**
 *
 * @export
 * @interface FetchStakingRewards200Response
 */
export interface FetchStakingRewards200Response {
    /**
     *
     * @type {Array<StakingReward>}
     * @memberof FetchStakingRewards200Response
     */
    'data': Array<StakingReward>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof FetchStakingRewards200Response
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof FetchStakingRewards200Response
     */
    'next_page': string;
}
/**
 *
 * @export
 * @interface FetchStakingRewardsRequest
 */
export interface FetchStakingRewardsRequest {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof FetchStakingRewardsRequest
     */
    'network_id': string;
    /**
     * The ID of the asset for which the staking rewards are being fetched
     * @type {string}
     * @memberof FetchStakingRewardsRequest
     */
    'asset_id': string;
    /**
     * The onchain addresses for which the staking rewards are being fetched
     * @type {Array<string>}
     * @memberof FetchStakingRewardsRequest
     */
    'address_ids': Array<string>;
    /**
     * The start time of this reward period
     * @type {string}
     * @memberof FetchStakingRewardsRequest
     */
    'start_time': string;
    /**
     * The end time of this reward period
     * @type {string}
     * @memberof FetchStakingRewardsRequest
     */
    'end_time': string;
    /**
     *
     * @type {StakingRewardFormat}
     * @memberof FetchStakingRewardsRequest
     */
    'format': StakingRewardFormat;
}
/**
 * An amount in fiat currency
 * @export
 * @interface FiatAmount
 */
export interface FiatAmount {
    /**
     * The amount of the fiat in whole units.
     * @type {string}
     * @memberof FiatAmount
     */
    'amount': string;
    /**
     * The currency of the fiat
     * @type {string}
     * @memberof FiatAmount
     */
    'currency': string;
}
/**
 * An operation to fund a wallet with crypto
 * @export
 * @interface FundOperation
 */
export interface FundOperation {
    /**
     * The ID of the fund operation
     * @type {string}
     * @memberof FundOperation
     */
    'fund_operation_id': string;
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof FundOperation
     */
    'network_id': string;
    /**
     * The ID of the wallet that will receive the crypto
     * @type {string}
     * @memberof FundOperation
     */
    'wallet_id': string;
    /**
     * The ID of the address that will receive the crypto
     * @type {string}
     * @memberof FundOperation
     */
    'address_id': string;
    /**
     *
     * @type {CryptoAmount}
     * @memberof FundOperation
     */
    'crypto_amount': CryptoAmount;
    /**
     *
     * @type {FiatAmount}
     * @memberof FundOperation
     */
    'fiat_amount': FiatAmount;
    /**
     *
     * @type {FundOperationFees}
     * @memberof FundOperation
     */
    'fees': FundOperationFees;
    /**
     * The status of the fund operation
     * @type {string}
     * @memberof FundOperation
     */
    'status': FundOperationStatusEnum;
}
export declare const FundOperationStatusEnum: {
    readonly Pending: "pending";
    readonly Complete: "complete";
    readonly Failed: "failed";
};
export type FundOperationStatusEnum = typeof FundOperationStatusEnum[keyof typeof FundOperationStatusEnum];
/**
 * The fees for a fund operation.
 * @export
 * @interface FundOperationFees
 */
export interface FundOperationFees {
    /**
     *
     * @type {FiatAmount}
     * @memberof FundOperationFees
     */
    'buy_fee': FiatAmount;
    /**
     *
     * @type {CryptoAmount}
     * @memberof FundOperationFees
     */
    'transfer_fee': CryptoAmount;
}
/**
 * Paginated list of fund operations
 * @export
 * @interface FundOperationList
 */
export interface FundOperationList {
    /**
     *
     * @type {Array<FundOperation>}
     * @memberof FundOperationList
     */
    'data': Array<FundOperation>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof FundOperationList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof FundOperationList
     */
    'next_page': string;
    /**
     * The total number of fund operations
     * @type {number}
     * @memberof FundOperationList
     */
    'total_count': number;
}
/**
 * A quote for a fund operation
 * @export
 * @interface FundQuote
 */
export interface FundQuote {
    /**
     * The ID of the fund quote
     * @type {string}
     * @memberof FundQuote
     */
    'fund_quote_id': string;
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof FundQuote
     */
    'network_id': string;
    /**
     * The ID of the wallet that will receive the crypto
     * @type {string}
     * @memberof FundQuote
     */
    'wallet_id': string;
    /**
     * The ID of the address that will receive the crypto
     * @type {string}
     * @memberof FundQuote
     */
    'address_id': string;
    /**
     *
     * @type {CryptoAmount}
     * @memberof FundQuote
     */
    'crypto_amount': CryptoAmount;
    /**
     *
     * @type {FiatAmount}
     * @memberof FundQuote
     */
    'fiat_amount': FiatAmount;
    /**
     * The time at which the quote expires
     * @type {string}
     * @memberof FundQuote
     */
    'expires_at': string;
    /**
     *
     * @type {FundOperationFees}
     * @memberof FundQuote
     */
    'fees': FundOperationFees;
}
/**
 *
 * @export
 * @interface GetStakingContextRequest
 */
export interface GetStakingContextRequest {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof GetStakingContextRequest
     */
    'network_id': string;
    /**
     * The ID of the asset being staked
     * @type {string}
     * @memberof GetStakingContextRequest
     */
    'asset_id': string;
    /**
     * The onchain address for which the staking context is being fetched
     * @type {string}
     * @memberof GetStakingContextRequest
     */
    'address_id': string;
    /**
     * Additional options for getting the staking context. This typically includes network specific fields.
     * @type {{ [key: string]: string; }}
     * @memberof GetStakingContextRequest
     */
    'options': {
        [key: string]: string;
    };
}
/**
 * The balance of an asset onchain at a particular block
 * @export
 * @interface HistoricalBalance
 */
export interface HistoricalBalance {
    /**
     * The amount in the atomic units of the asset
     * @type {string}
     * @memberof HistoricalBalance
     */
    'amount': string;
    /**
     * The hash of the block at which the balance was recorded
     * @type {string}
     * @memberof HistoricalBalance
     */
    'block_hash': string;
    /**
     * The block height at which the balance was recorded
     * @type {string}
     * @memberof HistoricalBalance
     */
    'block_height': string;
    /**
     *
     * @type {Asset}
     * @memberof HistoricalBalance
     */
    'asset': Asset;
}
/**
 * An error response from the Coinbase Developer Platform API
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * A short string representing the reported error. Can be use to handle errors programmatically.
     * @type {string}
     * @memberof ModelError
     */
    'code': string;
    /**
     * A human-readable message providing more details about the error.
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
    /**
     * A unique identifier for the request that generated the error. This can be used to help debug issues with the API.
     * @type {string}
     * @memberof ModelError
     */
    'correlation_id'?: string;
}
/**
 * Options for multi-token contract creation
 * @export
 * @interface MultiTokenContractOptions
 */
export interface MultiTokenContractOptions {
    /**
     * The URI for all token metadata
     * @type {string}
     * @memberof MultiTokenContractOptions
     */
    'uri': string;
}
/**
 * Options for NFT contract creation
 * @export
 * @interface NFTContractOptions
 */
export interface NFTContractOptions {
    /**
     * The name of the NFT
     * @type {string}
     * @memberof NFTContractOptions
     */
    'name': string;
    /**
     * The symbol of the NFT
     * @type {string}
     * @memberof NFTContractOptions
     */
    'symbol': string;
    /**
     * The base URI for the NFT metadata
     * @type {string}
     * @memberof NFTContractOptions
     */
    'base_uri': string;
}
/**
 *
 * @export
 * @interface Network
 */
export interface Network {
    /**
     *
     * @type {NetworkIdentifier}
     * @memberof Network
     */
    'id': NetworkIdentifier;
    /**
     * The human-readable name of the blockchain network
     * @type {string}
     * @memberof Network
     */
    'display_name': string;
    /**
     * The chain ID of the blockchain network
     * @type {number}
     * @memberof Network
     */
    'chain_id': number;
    /**
     * The protocol family of the blockchain network
     * @type {string}
     * @memberof Network
     */
    'protocol_family': NetworkProtocolFamilyEnum;
    /**
     * Whether the network is a testnet or not
     * @type {boolean}
     * @memberof Network
     */
    'is_testnet': boolean;
    /**
     *
     * @type {Asset}
     * @memberof Network
     */
    'native_asset': Asset;
    /**
     *
     * @type {FeatureSet}
     * @memberof Network
     */
    'feature_set': FeatureSet;
    /**
     * The BIP44 path prefix for the network
     * @type {string}
     * @memberof Network
     */
    'address_path_prefix'?: string;
}
export declare const NetworkProtocolFamilyEnum: {
    readonly Evm: "evm";
    readonly Solana: "solana";
};
export type NetworkProtocolFamilyEnum = typeof NetworkProtocolFamilyEnum[keyof typeof NetworkProtocolFamilyEnum];
/**
 * The ID of the blockchain network. This is unique across all networks, and takes the form of `<blockchain>-<network>`.
 * @export
 * @enum {string}
 */
export declare const NetworkIdentifier: {
    readonly BaseSepolia: "base-sepolia";
    readonly BaseMainnet: "base-mainnet";
    readonly EthereumHolesky: "ethereum-holesky";
    readonly EthereumMainnet: "ethereum-mainnet";
    readonly PolygonMainnet: "polygon-mainnet";
    readonly SolanaDevnet: "solana-devnet";
    readonly SolanaMainnet: "solana-mainnet";
    readonly ArbitrumMainnet: "arbitrum-mainnet";
};
export type NetworkIdentifier = typeof NetworkIdentifier[keyof typeof NetworkIdentifier];
/**
 * A representation of an onchain stored name from name systems i.e. ENS or Basenames
 * @export
 * @interface OnchainName
 */
export interface OnchainName {
    /**
     * The ID for the NFT related to this name
     * @type {string}
     * @memberof OnchainName
     */
    'token_id': string;
    /**
     * The onchain address of the owner of the name
     * @type {string}
     * @memberof OnchainName
     */
    'owner_address': string;
    /**
     * The onchain address of the manager of the name
     * @type {string}
     * @memberof OnchainName
     */
    'manager_address': string;
    /**
     * The primary onchain address of the name
     * @type {string}
     * @memberof OnchainName
     */
    'primary_address'?: string;
    /**
     * The readable format for the name in complete form
     * @type {string}
     * @memberof OnchainName
     */
    'domain': string;
    /**
     * The visual representation attached to this name
     * @type {string}
     * @memberof OnchainName
     */
    'avatar'?: string;
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof OnchainName
     */
    'network_id': string;
    /**
     * The expiration date for this name\'s ownership
     * @type {string}
     * @memberof OnchainName
     */
    'expires_at': string;
    /**
     * The metadata attached to this name
     * @type {{ [key: string]: string; }}
     * @memberof OnchainName
     */
    'text_records'?: {
        [key: string]: string;
    };
    /**
     * Whether this name is the primary name for the owner (This is when the ETH coin address for this name is equal to the primary_address. More info here https://docs.ens.domains/ensip/19)
     * @type {boolean}
     * @memberof OnchainName
     */
    'is_primary': boolean;
}
/**
 * A list of onchain events with pagination information
 * @export
 * @interface OnchainNameList
 */
export interface OnchainNameList {
    /**
     * A list of onchain name objects
     * @type {Array<OnchainName>}
     * @memberof OnchainNameList
     */
    'data': Array<OnchainName>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof OnchainNameList
     */
    'has_more'?: boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof OnchainNameList
     */
    'next_page': string;
    /**
     * The total number of payload signatures for the address.
     * @type {number}
     * @memberof OnchainNameList
     */
    'total_count'?: number;
}
/**
 * A payload signed by an address.
 * @export
 * @interface PayloadSignature
 */
export interface PayloadSignature {
    /**
     * The ID of the payload signature.
     * @type {string}
     * @memberof PayloadSignature
     */
    'payload_signature_id': string;
    /**
     * The ID of the wallet that owns the address.
     * @type {string}
     * @memberof PayloadSignature
     */
    'wallet_id': string;
    /**
     * The onchain address of the signer.
     * @type {string}
     * @memberof PayloadSignature
     */
    'address_id': string;
    /**
     * The unsigned payload. This is the payload that needs to be signed by the signer address.
     * @type {string}
     * @memberof PayloadSignature
     */
    'unsigned_payload': string;
    /**
     * The signature of the payload.
     * @type {string}
     * @memberof PayloadSignature
     */
    'signature'?: string;
    /**
     * The status of the payload signature.
     * @type {string}
     * @memberof PayloadSignature
     */
    'status': PayloadSignatureStatusEnum;
}
export declare const PayloadSignatureStatusEnum: {
    readonly Pending: "pending";
    readonly Signed: "signed";
    readonly Failed: "failed";
};
export type PayloadSignatureStatusEnum = typeof PayloadSignatureStatusEnum[keyof typeof PayloadSignatureStatusEnum];
/**
 *
 * @export
 * @interface PayloadSignatureList
 */
export interface PayloadSignatureList {
    /**
     *
     * @type {Array<PayloadSignature>}
     * @memberof PayloadSignatureList
     */
    'data': Array<PayloadSignature>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof PayloadSignatureList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof PayloadSignatureList
     */
    'next_page': string;
    /**
     * The total number of payload signatures for the address.
     * @type {number}
     * @memberof PayloadSignatureList
     */
    'total_count': number;
}
/**
 *
 * @export
 * @interface ReadContractRequest
 */
export interface ReadContractRequest {
    /**
     * The name of the contract method to call
     * @type {string}
     * @memberof ReadContractRequest
     */
    'method': string;
    /**
     * The JSON-encoded arguments to pass to the contract method. The keys should be the argument names and the values should be the argument values.
     * @type {string}
     * @memberof ReadContractRequest
     */
    'args': string;
    /**
     * The JSON-encoded ABI of the contract method (optional, will use cached ABI if not provided)
     * @type {string}
     * @memberof ReadContractRequest
     */
    'abi'?: string;
}
/**
 * Smart Contract data to be registered
 * @export
 * @interface RegisterSmartContractRequest
 */
export interface RegisterSmartContractRequest {
    /**
     * ABI of the smart contract
     * @type {string}
     * @memberof RegisterSmartContractRequest
     */
    'abi': string;
    /**
     * Name of the smart contract
     * @type {string}
     * @memberof RegisterSmartContractRequest
     */
    'contract_name'?: string;
}
/**
 * An event representing a seed creation.
 * @export
 * @interface SeedCreationEvent
 */
export interface SeedCreationEvent {
    /**
     * The ID of the wallet that the server-signer should create the seed for
     * @type {string}
     * @memberof SeedCreationEvent
     */
    'wallet_id': string;
    /**
     * The ID of the user that the wallet belongs to
     * @type {string}
     * @memberof SeedCreationEvent
     */
    'wallet_user_id': string;
}
/**
 * The result to a SeedCreationEvent.
 * @export
 * @interface SeedCreationEventResult
 */
export interface SeedCreationEventResult {
    /**
     * The ID of the wallet that the seed was created for
     * @type {string}
     * @memberof SeedCreationEventResult
     */
    'wallet_id': string;
    /**
     * The ID of the user that the wallet belongs to
     * @type {string}
     * @memberof SeedCreationEventResult
     */
    'wallet_user_id': string;
    /**
     * The extended public key for the first master key derived from seed.
     * @type {string}
     * @memberof SeedCreationEventResult
     */
    'extended_public_key': string;
    /**
     * The ID of the seed in Server-Signer used to generate the extended public key.
     * @type {string}
     * @memberof SeedCreationEventResult
     */
    'seed_id': string;
}
/**
 * A Server-Signer assigned to sign transactions in a wallet.
 * @export
 * @interface ServerSigner
 */
export interface ServerSigner {
    /**
     * The ID of the server-signer
     * @type {string}
     * @memberof ServerSigner
     */
    'server_signer_id': string;
    /**
     * The IDs of the wallets that the server-signer can sign for
     * @type {Array<string>}
     * @memberof ServerSigner
     */
    'wallets'?: Array<string>;
    /**
     * Whether the Server-Signer uses MPC.
     * @type {boolean}
     * @memberof ServerSigner
     */
    'is_mpc': boolean;
}
/**
 * An event that is waiting to be processed by a Server-Signer.
 * @export
 * @interface ServerSignerEvent
 */
export interface ServerSignerEvent {
    /**
     * The ID of the server-signer that the event is for
     * @type {string}
     * @memberof ServerSignerEvent
     */
    'server_signer_id': string;
    /**
     *
     * @type {ServerSignerEventEvent}
     * @memberof ServerSignerEvent
     */
    'event': ServerSignerEventEvent;
}
/**
 * @type ServerSignerEventEvent
 * @export
 */
export type ServerSignerEventEvent = SeedCreationEvent | SignatureCreationEvent;
/**
 *
 * @export
 * @interface ServerSignerEventList
 */
export interface ServerSignerEventList {
    /**
     *
     * @type {Array<ServerSignerEvent>}
     * @memberof ServerSignerEventList
     */
    'data': Array<ServerSignerEvent>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof ServerSignerEventList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof ServerSignerEventList
     */
    'next_page': string;
    /**
     * The total number of events for the server signer.
     * @type {number}
     * @memberof ServerSignerEventList
     */
    'total_count': number;
}
/**
 *
 * @export
 * @interface ServerSignerList
 */
export interface ServerSignerList {
    /**
     *
     * @type {Array<ServerSigner>}
     * @memberof ServerSignerList
     */
    'data': Array<ServerSigner>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof ServerSignerList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof ServerSignerList
     */
    'next_page': string;
    /**
     * The total number of server-signers for the project.
     * @type {number}
     * @memberof ServerSignerList
     */
    'total_count': number;
}
/**
 * An event representing a signature creation.
 * @export
 * @interface SignatureCreationEvent
 */
export interface SignatureCreationEvent {
    /**
     * The ID of the seed that the server-signer should create the signature for
     * @type {string}
     * @memberof SignatureCreationEvent
     */
    'seed_id': string;
    /**
     * The ID of the wallet the signature is for
     * @type {string}
     * @memberof SignatureCreationEvent
     */
    'wallet_id': string;
    /**
     * The ID of the user that the wallet belongs to
     * @type {string}
     * @memberof SignatureCreationEvent
     */
    'wallet_user_id': string;
    /**
     * The ID of the address the transfer belongs to
     * @type {string}
     * @memberof SignatureCreationEvent
     */
    'address_id': string;
    /**
     * The index of the address that the server-signer should sign with
     * @type {number}
     * @memberof SignatureCreationEvent
     */
    'address_index': number;
    /**
     * The payload that the server-signer should sign
     * @type {string}
     * @memberof SignatureCreationEvent
     */
    'signing_payload': string;
    /**
     *
     * @type {TransactionType}
     * @memberof SignatureCreationEvent
     */
    'transaction_type': TransactionType;
    /**
     * The ID of the transaction that the server-signer should sign
     * @type {string}
     * @memberof SignatureCreationEvent
     */
    'transaction_id': string;
}
/**
 * The result to a SignatureCreationEvent.
 * @export
 * @interface SignatureCreationEventResult
 */
export interface SignatureCreationEventResult {
    /**
     * The ID of the wallet that the event was created for.
     * @type {string}
     * @memberof SignatureCreationEventResult
     */
    'wallet_id': string;
    /**
     * The ID of the user that the wallet belongs to
     * @type {string}
     * @memberof SignatureCreationEventResult
     */
    'wallet_user_id': string;
    /**
     * The ID of the address the transfer belongs to
     * @type {string}
     * @memberof SignatureCreationEventResult
     */
    'address_id': string;
    /**
     *
     * @type {TransactionType}
     * @memberof SignatureCreationEventResult
     */
    'transaction_type': TransactionType;
    /**
     * The ID of the transaction that the Server-Signer has signed for
     * @type {string}
     * @memberof SignatureCreationEventResult
     */
    'transaction_id': string;
    /**
     * The signature created by the server-signer.
     * @type {string}
     * @memberof SignatureCreationEventResult
     */
    'signature': string;
}
/**
 * Signed voluntary exit message metadata to be provided to beacon chain to exit a validator.
 * @export
 * @interface SignedVoluntaryExitMessageMetadata
 */
export interface SignedVoluntaryExitMessageMetadata {
    /**
     * The public key of the validator associated with the exit message.
     * @type {string}
     * @memberof SignedVoluntaryExitMessageMetadata
     */
    'validator_pub_key': string;
    /**
     * The current fork version of the Ethereum beacon chain.
     * @type {string}
     * @memberof SignedVoluntaryExitMessageMetadata
     */
    'fork': string;
    /**
     * A base64 encoded version of a json string representing a voluntary exit message.
     * @type {string}
     * @memberof SignedVoluntaryExitMessageMetadata
     */
    'signed_voluntary_exit': string;
}
/**
 * Represents a smart contract on the blockchain
 * @export
 * @interface SmartContract
 */
export interface SmartContract {
    /**
     * The unique identifier of the smart contract.
     * @type {string}
     * @memberof SmartContract
     */
    'smart_contract_id': string;
    /**
     * The name of the blockchain network
     * @type {string}
     * @memberof SmartContract
     */
    'network_id': string;
    /**
     * The ID of the wallet that deployed the smart contract. If this smart contract was deployed externally, this will be omitted.
     * @type {string}
     * @memberof SmartContract
     */
    'wallet_id'?: string;
    /**
     * The EVM address of the smart contract
     * @type {string}
     * @memberof SmartContract
     */
    'contract_address': string;
    /**
     * The name of the smart contract
     * @type {string}
     * @memberof SmartContract
     */
    'contract_name': string;
    /**
     * The EVM address of the account that deployed the smart contract. If this smart contract was deployed externally, this will be omitted.
     * @type {string}
     * @memberof SmartContract
     */
    'deployer_address'?: string;
    /**
     *
     * @type {SmartContractType}
     * @memberof SmartContract
     */
    'type': SmartContractType;
    /**
     *
     * @type {SmartContractOptions}
     * @memberof SmartContract
     */
    'options'?: SmartContractOptions;
    /**
     * The JSON-encoded ABI of the contract
     * @type {string}
     * @memberof SmartContract
     */
    'abi': string;
    /**
     *
     * @type {Transaction}
     * @memberof SmartContract
     */
    'transaction'?: Transaction;
    /**
     * Whether the smart contract was deployed externally. If true, the deployer_address and transaction will be omitted.
     * @type {boolean}
     * @memberof SmartContract
     */
    'is_external': boolean;
    /**
     * The ID of the compiled smart contract that was used to deploy this contract
     * @type {string}
     * @memberof SmartContract
     */
    'compiled_smart_contract_id'?: string;
}
/**
 * Represents an event triggered by a smart contract activity on the blockchain. Contains information about the function, transaction, block, and involved addresses.
 * @export
 * @interface SmartContractActivityEvent
 */
export interface SmartContractActivityEvent {
    /**
     * Unique identifier for the webhook that triggered this event.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'webhookId'?: string;
    /**
     * Type of event, in this case, an ERC-721 token transfer.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'eventType'?: string;
    /**
     * Blockchain network where the event occurred.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'network'?: string;
    /**
     * Name of the project this smart contract belongs to.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'projectName'?: string;
    /**
     * Name of the contract.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'contractName'?: string;
    /**
     * Name of the function.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'func'?: string;
    /**
     * Signature of the function.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'sig'?: string;
    /**
     * First 4 bytes of the Transaction, a unique ID.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'fourBytes'?: string;
    /**
     * Address of the smart contract.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'contractAddress'?: string;
    /**
     * Hash of the block containing the transaction.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'blockHash'?: string;
    /**
     * Number of the block containing the transaction.
     * @type {number}
     * @memberof SmartContractActivityEvent
     */
    'blockNumber'?: number;
    /**
     * Timestamp when the block was mined.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'blockTime'?: string;
    /**
     * Hash of the transaction that triggered the event.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'transactionHash'?: string;
    /**
     * Position of the transaction within the block.
     * @type {number}
     * @memberof SmartContractActivityEvent
     */
    'transactionIndex'?: number;
    /**
     * Position of the event log within the transaction.
     * @type {number}
     * @memberof SmartContractActivityEvent
     */
    'logIndex'?: number;
    /**
     * Address of the initiator in the transfer.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'from'?: string;
    /**
     * Address of the recipient in the transfer.
     * @type {string}
     * @memberof SmartContractActivityEvent
     */
    'to'?: string;
    /**
     * Amount of tokens transferred, typically in the smallest unit (e.g., wei for Ethereum).
     * @type {number}
     * @memberof SmartContractActivityEvent
     */
    'value'?: number;
}
/**
 *
 * @export
 * @interface SmartContractList
 */
export interface SmartContractList {
    /**
     *
     * @type {Array<SmartContract>}
     * @memberof SmartContractList
     */
    'data': Array<SmartContract>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof SmartContractList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof SmartContractList
     */
    'next_page': string;
}
/**
 * @type SmartContractOptions
 * Options for smart contract creation
 * @export
 */
export type SmartContractOptions = MultiTokenContractOptions | NFTContractOptions | TokenContractOptions | string;
/**
 * The type of the smart contract.
 * @export
 * @enum {string}
 */
export declare const SmartContractType: {
    readonly Erc20: "erc20";
    readonly Erc721: "erc721";
    readonly Erc1155: "erc1155";
    readonly Custom: "custom";
};
export type SmartContractType = typeof SmartContractType[keyof typeof SmartContractType];
/**
 *
 * @export
 * @interface SolidityValue
 */
export interface SolidityValue {
    /**
     *
     * @type {string}
     * @memberof SolidityValue
     */
    'type': SolidityValueTypeEnum;
    /**
     * The field name for tuple types. Not used for other types.
     * @type {string}
     * @memberof SolidityValue
     */
    'name'?: string;
    /**
     * The value as a string for simple types. Not used for complex types (array, tuple).
     * @type {string}
     * @memberof SolidityValue
     */
    'value'?: string;
    /**
     * For array and tuple types, the components of the value
     * @type {Array<SolidityValue>}
     * @memberof SolidityValue
     */
    'values'?: Array<SolidityValue>;
}
export declare const SolidityValueTypeEnum: {
    readonly Uint8: "uint8";
    readonly Uint16: "uint16";
    readonly Uint32: "uint32";
    readonly Uint64: "uint64";
    readonly Uint128: "uint128";
    readonly Uint160: "uint160";
    readonly Uint256: "uint256";
    readonly Int8: "int8";
    readonly Int16: "int16";
    readonly Int24: "int24";
    readonly Int32: "int32";
    readonly Int56: "int56";
    readonly Int64: "int64";
    readonly Int128: "int128";
    readonly Int256: "int256";
    readonly Address: "address";
    readonly Bool: "bool";
    readonly String: "string";
    readonly Bytes: "bytes";
    readonly Bytes1: "bytes1";
    readonly Bytes2: "bytes2";
    readonly Bytes3: "bytes3";
    readonly Bytes4: "bytes4";
    readonly Bytes5: "bytes5";
    readonly Bytes6: "bytes6";
    readonly Bytes7: "bytes7";
    readonly Bytes8: "bytes8";
    readonly Bytes9: "bytes9";
    readonly Bytes10: "bytes10";
    readonly Bytes11: "bytes11";
    readonly Bytes12: "bytes12";
    readonly Bytes13: "bytes13";
    readonly Bytes14: "bytes14";
    readonly Bytes15: "bytes15";
    readonly Bytes16: "bytes16";
    readonly Bytes17: "bytes17";
    readonly Bytes18: "bytes18";
    readonly Bytes19: "bytes19";
    readonly Bytes20: "bytes20";
    readonly Bytes21: "bytes21";
    readonly Bytes22: "bytes22";
    readonly Bytes23: "bytes23";
    readonly Bytes24: "bytes24";
    readonly Bytes25: "bytes25";
    readonly Bytes26: "bytes26";
    readonly Bytes27: "bytes27";
    readonly Bytes28: "bytes28";
    readonly Bytes29: "bytes29";
    readonly Bytes30: "bytes30";
    readonly Bytes31: "bytes31";
    readonly Bytes32: "bytes32";
    readonly Array: "array";
    readonly Tuple: "tuple";
};
export type SolidityValueTypeEnum = typeof SolidityValueTypeEnum[keyof typeof SolidityValueTypeEnum];
/**
 * An onchain sponsored gasless send.
 * @export
 * @interface SponsoredSend
 */
export interface SponsoredSend {
    /**
     * The onchain address of the recipient
     * @type {string}
     * @memberof SponsoredSend
     */
    'to_address_id': string;
    /**
     * The raw typed data for the sponsored send
     * @type {string}
     * @memberof SponsoredSend
     */
    'raw_typed_data': string;
    /**
     * The typed data hash for the sponsored send. This is the typed data hash that needs to be signed by the sender.
     * @type {string}
     * @memberof SponsoredSend
     */
    'typed_data_hash': string;
    /**
     * The signed hash of the sponsored send typed data.
     * @type {string}
     * @memberof SponsoredSend
     */
    'signature'?: string;
    /**
     * The hash of the onchain sponsored send transaction
     * @type {string}
     * @memberof SponsoredSend
     */
    'transaction_hash'?: string;
    /**
     * The link to view the transaction on a block explorer. This is optional and may not be present for all transactions.
     * @type {string}
     * @memberof SponsoredSend
     */
    'transaction_link'?: string;
    /**
     * The status of the sponsored send
     * @type {string}
     * @memberof SponsoredSend
     */
    'status': SponsoredSendStatusEnum;
}
export declare const SponsoredSendStatusEnum: {
    readonly Pending: "pending";
    readonly Signed: "signed";
    readonly Submitted: "submitted";
    readonly Complete: "complete";
    readonly Failed: "failed";
};
export type SponsoredSendStatusEnum = typeof SponsoredSendStatusEnum[keyof typeof SponsoredSendStatusEnum];
/**
 * The staking balances for an address.
 * @export
 * @interface StakingBalance
 */
export interface StakingBalance {
    /**
     * The onchain address for which the staking balances are being fetched.
     * @type {string}
     * @memberof StakingBalance
     */
    'address': string;
    /**
     * The timestamp of the staking balance in UTC.
     * @type {string}
     * @memberof StakingBalance
     */
    'date': string;
    /**
     *
     * @type {Balance}
     * @memberof StakingBalance
     */
    'bonded_stake': Balance;
    /**
     *
     * @type {Balance}
     * @memberof StakingBalance
     */
    'unbonded_balance': Balance;
    /**
     * The type of staking participation.
     * @type {string}
     * @memberof StakingBalance
     */
    'participant_type': string;
}
/**
 * Context needed to perform a staking operation
 * @export
 * @interface StakingContext
 */
export interface StakingContext {
    /**
     *
     * @type {StakingContextContext}
     * @memberof StakingContext
     */
    'context': StakingContextContext;
}
/**
 *
 * @export
 * @interface StakingContextContext
 */
export interface StakingContextContext {
    /**
     *
     * @type {Balance}
     * @memberof StakingContextContext
     */
    'stakeable_balance': Balance;
    /**
     *
     * @type {Balance}
     * @memberof StakingContextContext
     */
    'unstakeable_balance': Balance;
    /**
     *
     * @type {Balance}
     * @memberof StakingContextContext
     */
    'claimable_balance': Balance;
}
/**
 * A list of onchain transactions to help realize a staking action.
 * @export
 * @interface StakingOperation
 */
export interface StakingOperation {
    /**
     * The unique ID of the staking operation.
     * @type {string}
     * @memberof StakingOperation
     */
    'id': string;
    /**
     * The ID of the wallet that owns the address.
     * @type {string}
     * @memberof StakingOperation
     */
    'wallet_id'?: string;
    /**
     * The ID of the blockchain network.
     * @type {string}
     * @memberof StakingOperation
     */
    'network_id': string;
    /**
     * The onchain address orchestrating the staking operation.
     * @type {string}
     * @memberof StakingOperation
     */
    'address_id': string;
    /**
     * The status of the staking operation.
     * @type {string}
     * @memberof StakingOperation
     */
    'status': StakingOperationStatusEnum;
    /**
     * The transaction(s) that will execute the staking operation onchain.
     * @type {Array<Transaction>}
     * @memberof StakingOperation
     */
    'transactions': Array<Transaction>;
    /**
     *
     * @type {StakingOperationMetadata}
     * @memberof StakingOperation
     */
    'metadata'?: StakingOperationMetadata;
}
export declare const StakingOperationStatusEnum: {
    readonly Initialized: "initialized";
    readonly Complete: "complete";
    readonly Failed: "failed";
    readonly Unspecified: "unspecified";
};
export type StakingOperationStatusEnum = typeof StakingOperationStatusEnum[keyof typeof StakingOperationStatusEnum];
/**
 * @type StakingOperationMetadata
 * @export
 */
export type StakingOperationMetadata = Array<SignedVoluntaryExitMessageMetadata>;
/**
 * The staking rewards for an address.
 * @export
 * @interface StakingReward
 */
export interface StakingReward {
    /**
     * The onchain address for which the staking rewards are being fetched.
     * @type {string}
     * @memberof StakingReward
     */
    'address_id': string;
    /**
     * The timestamp of the reward in UTC.
     * @type {string}
     * @memberof StakingReward
     */
    'date': string;
    /**
     * The reward amount in requested \"format\". Default is USD.
     * @type {string}
     * @memberof StakingReward
     */
    'amount': string;
    /**
     * The state of the reward.
     * @type {string}
     * @memberof StakingReward
     */
    'state': StakingRewardStateEnum;
    /**
     *
     * @type {StakingRewardFormat}
     * @memberof StakingReward
     */
    'format': StakingRewardFormat;
    /**
     *
     * @type {StakingRewardUSDValue}
     * @memberof StakingReward
     */
    'usd_value': StakingRewardUSDValue;
}
export declare const StakingRewardStateEnum: {
    readonly Pending: "pending";
    readonly Distributed: "distributed";
};
export type StakingRewardStateEnum = typeof StakingRewardStateEnum[keyof typeof StakingRewardStateEnum];
/**
 * The format in which the rewards are to be fetched i.e native or in equivalent USD
 * @export
 * @enum {string}
 */
export declare const StakingRewardFormat: {
    readonly Usd: "usd";
    readonly Native: "native";
};
export type StakingRewardFormat = typeof StakingRewardFormat[keyof typeof StakingRewardFormat];
/**
 * The USD value of the reward
 * @export
 * @interface StakingRewardUSDValue
 */
export interface StakingRewardUSDValue {
    /**
     * The value of the reward in USD
     * @type {string}
     * @memberof StakingRewardUSDValue
     */
    'amount': string;
    /**
     * The conversion price from native currency to USD
     * @type {string}
     * @memberof StakingRewardUSDValue
     */
    'conversion_price': string;
    /**
     * The time of the conversion in UTC.
     * @type {string}
     * @memberof StakingRewardUSDValue
     */
    'conversion_time': string;
}
/**
 * Options for token contract creation
 * @export
 * @interface TokenContractOptions
 */
export interface TokenContractOptions {
    /**
     * The name of the token
     * @type {string}
     * @memberof TokenContractOptions
     */
    'name': string;
    /**
     * The symbol of the token
     * @type {string}
     * @memberof TokenContractOptions
     */
    'symbol': string;
    /**
     * The total supply of the token denominated in the whole amount of the token.
     * @type {string}
     * @memberof TokenContractOptions
     */
    'total_supply': string;
}
/**
 * The type of the token transfer.
 * @export
 * @enum {string}
 */
export declare const TokenTransferType: {
    readonly Erc20: "erc20";
    readonly Erc721: "erc721";
    readonly Erc1155: "erc1155";
    readonly Unknown: "unknown";
};
export type TokenTransferType = typeof TokenTransferType[keyof typeof TokenTransferType];
/**
 * A trade of an asset to another asset
 * @export
 * @interface Trade
 */
export interface Trade {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Trade
     */
    'network_id': string;
    /**
     * The ID of the wallet that owns the from address
     * @type {string}
     * @memberof Trade
     */
    'wallet_id': string;
    /**
     * The onchain address of the sender
     * @type {string}
     * @memberof Trade
     */
    'address_id': string;
    /**
     * The ID of the trade
     * @type {string}
     * @memberof Trade
     */
    'trade_id': string;
    /**
     * The amount of the from asset to be traded (in atomic units of the from asset)
     * @type {string}
     * @memberof Trade
     */
    'from_amount': string;
    /**
     *
     * @type {Asset}
     * @memberof Trade
     */
    'from_asset': Asset;
    /**
     * The amount of the to asset that will be received (in atomic units of the to asset)
     * @type {string}
     * @memberof Trade
     */
    'to_amount': string;
    /**
     *
     * @type {Asset}
     * @memberof Trade
     */
    'to_asset': Asset;
    /**
     *
     * @type {Transaction}
     * @memberof Trade
     */
    'transaction': Transaction;
    /**
     *
     * @type {Transaction}
     * @memberof Trade
     */
    'approve_transaction'?: Transaction;
}
/**
 *
 * @export
 * @interface TradeList
 */
export interface TradeList {
    /**
     *
     * @type {Array<Trade>}
     * @memberof TradeList
     */
    'data': Array<Trade>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof TradeList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof TradeList
     */
    'next_page': string;
    /**
     * The total number of trades for the address in the wallet.
     * @type {number}
     * @memberof TradeList
     */
    'total_count': number;
}
/**
 * An onchain transaction.
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * The ID of the blockchain network.
     * @type {string}
     * @memberof Transaction
     */
    'network_id': string;
    /**
     * The hash of the block at which the transaction was recorded.
     * @type {string}
     * @memberof Transaction
     */
    'block_hash'?: string;
    /**
     * The block height at which the transaction was recorded.
     * @type {string}
     * @memberof Transaction
     */
    'block_height'?: string;
    /**
     * The onchain address of the sender.
     * @type {string}
     * @memberof Transaction
     */
    'from_address_id': string;
    /**
     * The onchain address of the recipient.
     * @type {string}
     * @memberof Transaction
     */
    'to_address_id'?: string;
    /**
     * The unsigned payload of the transaction. This is the payload that needs to be signed by the sender.
     * @type {string}
     * @memberof Transaction
     */
    'unsigned_payload': string;
    /**
     * The signed payload of the transaction. This is the payload that has been signed by the sender.
     * @type {string}
     * @memberof Transaction
     */
    'signed_payload'?: string;
    /**
     * The hash of the transaction.
     * @type {string}
     * @memberof Transaction
     */
    'transaction_hash'?: string;
    /**
     * The link to view the transaction on a block explorer. This is optional and may not be present for all transactions.
     * @type {string}
     * @memberof Transaction
     */
    'transaction_link'?: string;
    /**
     * The status of the transaction.
     * @type {string}
     * @memberof Transaction
     */
    'status': TransactionStatusEnum;
    /**
     *
     * @type {TransactionContent}
     * @memberof Transaction
     */
    'content'?: TransactionContent;
}
export declare const TransactionStatusEnum: {
    readonly Pending: "pending";
    readonly Signed: "signed";
    readonly Broadcast: "broadcast";
    readonly Complete: "complete";
    readonly Failed: "failed";
    readonly Unspecified: "unspecified";
};
export type TransactionStatusEnum = typeof TransactionStatusEnum[keyof typeof TransactionStatusEnum];
/**
 * @type TransactionContent
 * @export
 */
export type TransactionContent = EthereumTransaction;
/**
 *
 * @export
 * @enum {string}
 */
export declare const TransactionType: {
    readonly Transfer: "transfer";
};
export type TransactionType = typeof TransactionType[keyof typeof TransactionType];
/**
 * A transfer of an asset from one address to another
 * @export
 * @interface Transfer
 */
export interface Transfer {
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Transfer
     */
    'network_id': string;
    /**
     * The ID of the wallet that owns the from address
     * @type {string}
     * @memberof Transfer
     */
    'wallet_id': string;
    /**
     * The onchain address of the sender
     * @type {string}
     * @memberof Transfer
     */
    'address_id': string;
    /**
     * The onchain address of the recipient
     * @type {string}
     * @memberof Transfer
     */
    'destination': string;
    /**
     * The amount in the atomic units of the asset
     * @type {string}
     * @memberof Transfer
     */
    'amount': string;
    /**
     * The ID of the asset being transferred. Use `asset.asset_id` instead.
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'asset_id': string;
    /**
     *
     * @type {Asset}
     * @memberof Transfer
     */
    'asset': Asset;
    /**
     * The ID of the transfer
     * @type {string}
     * @memberof Transfer
     */
    'transfer_id': string;
    /**
     *
     * @type {Transaction}
     * @memberof Transfer
     */
    'transaction'?: Transaction;
    /**
     *
     * @type {SponsoredSend}
     * @memberof Transfer
     */
    'sponsored_send'?: SponsoredSend;
    /**
     * The unsigned payload of the transfer. This is the payload that needs to be signed by the sender.
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'unsigned_payload'?: string;
    /**
     * The signed payload of the transfer. This is the payload that has been signed by the sender.
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'signed_payload'?: string;
    /**
     * The hash of the transfer transaction
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'transaction_hash'?: string;
    /**
     *
     * @type {string}
     * @memberof Transfer
     * @deprecated
     */
    'status'?: string;
    /**
     * Whether the transfer uses sponsored gas
     * @type {boolean}
     * @memberof Transfer
     */
    'gasless': boolean;
}
/**
 *
 * @export
 * @interface TransferList
 */
export interface TransferList {
    /**
     *
     * @type {Array<Transfer>}
     * @memberof TransferList
     */
    'data': Array<Transfer>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof TransferList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof TransferList
     */
    'next_page': string;
    /**
     * The total number of transfers for the address in the wallet.
     * @type {number}
     * @memberof TransferList
     */
    'total_count': number;
}
/**
 * Smart Contract data to be updated
 * @export
 * @interface UpdateSmartContractRequest
 */
export interface UpdateSmartContractRequest {
    /**
     * ABI of the smart contract
     * @type {string}
     * @memberof UpdateSmartContractRequest
     */
    'abi'?: string;
    /**
     * Name of the smart contract
     * @type {string}
     * @memberof UpdateSmartContractRequest
     */
    'contract_name'?: string;
}
/**
 *
 * @export
 * @interface UpdateWebhookRequest
 */
export interface UpdateWebhookRequest {
    /**
     *
     * @type {WebhookEventTypeFilter}
     * @memberof UpdateWebhookRequest
     */
    'event_type_filter'?: WebhookEventTypeFilter;
    /**
     * Webhook will monitor all events that matches any one of the event filters.
     * @type {Array<WebhookEventFilter>}
     * @memberof UpdateWebhookRequest
     */
    'event_filters'?: Array<WebhookEventFilter>;
    /**
     * The Webhook uri that updates to
     * @type {string}
     * @memberof UpdateWebhookRequest
     */
    'notification_uri'?: string;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
    /**
     * The ID of the user
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'display_name'?: string;
}
/**
 * A validator onchain.
 * @export
 * @interface Validator
 */
export interface Validator {
    /**
     * The publicly identifiable unique id of the validator. This can be the public key for Ethereum validators and maybe an address for some other network.
     * @type {string}
     * @memberof Validator
     */
    'validator_id': string;
    /**
     * The ID of the blockchain network to which the Validator belongs.
     * @type {string}
     * @memberof Validator
     */
    'network_id': string;
    /**
     * The ID of the asset that the validator helps stake.
     * @type {string}
     * @memberof Validator
     */
    'asset_id': string;
    /**
     *
     * @type {ValidatorStatus}
     * @memberof Validator
     */
    'status': ValidatorStatus;
    /**
     *
     * @type {ValidatorDetails}
     * @memberof Validator
     */
    'details'?: ValidatorDetails;
}
/**
 * @type ValidatorDetails
 * @export
 */
export type ValidatorDetails = EthereumValidatorMetadata;
/**
 *
 * @export
 * @interface ValidatorList
 */
export interface ValidatorList {
    /**
     *
     * @type {Array<Validator>}
     * @memberof ValidatorList
     */
    'data': Array<Validator>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof ValidatorList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof ValidatorList
     */
    'next_page': string;
}
/**
 * The status of the validator.
 * @export
 * @enum {string}
 */
export declare const ValidatorStatus: {
    readonly Unknown: "unknown";
    readonly Provisioning: "provisioning";
    readonly Provisioned: "provisioned";
    readonly Deposited: "deposited";
    readonly PendingActivation: "pending_activation";
    readonly Active: "active";
    readonly Exiting: "exiting";
    readonly Exited: "exited";
    readonly WithdrawalAvailable: "withdrawal_available";
    readonly WithdrawalComplete: "withdrawal_complete";
    readonly ActiveSlashed: "active_slashed";
    readonly ExitedSlashed: "exited_slashed";
    readonly Reaped: "reaped";
};
export type ValidatorStatus = typeof ValidatorStatus[keyof typeof ValidatorStatus];
/**
 *
 * @export
 * @interface Wallet
 */
export interface Wallet {
    /**
     * The server-assigned ID for the wallet.
     * @type {string}
     * @memberof Wallet
     */
    'id': string;
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Wallet
     */
    'network_id': string;
    /**
     *
     * @type {Address}
     * @memberof Wallet
     */
    'default_address'?: Address;
    /**
     *
     * @type {FeatureSet}
     * @memberof Wallet
     */
    'feature_set': FeatureSet;
    /**
     * The status of the Server-Signer for the wallet if present.
     * @type {string}
     * @memberof Wallet
     */
    'server_signer_status'?: WalletServerSignerStatusEnum;
}
export declare const WalletServerSignerStatusEnum: {
    readonly PendingSeedCreation: "pending_seed_creation";
    readonly ActiveSeed: "active_seed";
};
export type WalletServerSignerStatusEnum = typeof WalletServerSignerStatusEnum[keyof typeof WalletServerSignerStatusEnum];
/**
 * Paginated list of wallets
 * @export
 * @interface WalletList
 */
export interface WalletList {
    /**
     *
     * @type {Array<Wallet>}
     * @memberof WalletList
     */
    'data': Array<Wallet>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof WalletList
     */
    'has_more': boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof WalletList
     */
    'next_page': string;
    /**
     * The total number of wallets
     * @type {number}
     * @memberof WalletList
     */
    'total_count': number;
}
/**
 * Webhook that is used for getting notifications when monitored events occur.
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * Identifier of the webhook.
     * @type {string}
     * @memberof Webhook
     */
    'id'?: string;
    /**
     * The ID of the blockchain network
     * @type {string}
     * @memberof Webhook
     */
    'network_id'?: string;
    /**
     *
     * @type {WebhookEventType}
     * @memberof Webhook
     */
    'event_type'?: WebhookEventType;
    /**
     *
     * @type {WebhookEventTypeFilter}
     * @memberof Webhook
     */
    'event_type_filter'?: WebhookEventTypeFilter;
    /**
     * Webhook will monitor all events that matches any one of the event filters.
     * @type {Array<WebhookEventFilter>}
     * @memberof Webhook
     */
    'event_filters'?: Array<WebhookEventFilter>;
    /**
     * The URL to which the notifications will be sent.
     * @type {string}
     * @memberof Webhook
     */
    'notification_uri'?: string;
    /**
     * The date and time the webhook was created.
     * @type {string}
     * @memberof Webhook
     */
    'created_at'?: string;
    /**
     * The date and time the webhook was last updated.
     * @type {string}
     * @memberof Webhook
     */
    'updated_at'?: string;
    /**
     * The header that will contain the signature of the webhook payload.
     * @type {string}
     * @memberof Webhook
     */
    'signature_header'?: string;
}
/**
 * The event_filter parameter specifies the criteria to filter events from the blockchain. It allows filtering events by contract address, sender address and receiver address. For a single event filter, not all of the properties need to be presented.
 * @export
 * @interface WebhookEventFilter
 */
export interface WebhookEventFilter {
    /**
     * The onchain contract address of the token for which the events should be tracked.
     * @type {string}
     * @memberof WebhookEventFilter
     */
    'contract_address'?: string;
    /**
     * The onchain address of the sender. Set this filter to track all transfer events originating from your address.
     * @type {string}
     * @memberof WebhookEventFilter
     */
    'from_address'?: string;
    /**
     * The onchain address of the receiver. Set this filter to track all transfer events sent to your address.
     * @type {string}
     * @memberof WebhookEventFilter
     */
    'to_address'?: string;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const WebhookEventType: {
    readonly Unspecified: "unspecified";
    readonly Erc20Transfer: "erc20_transfer";
    readonly Erc721Transfer: "erc721_transfer";
    readonly WalletActivity: "wallet_activity";
    readonly SmartContractEventActivity: "smart_contract_event_activity";
};
export type WebhookEventType = typeof WebhookEventType[keyof typeof WebhookEventType];
/**
 * @type WebhookEventTypeFilter
 * The event_type_filter parameter specifies the criteria to filter events based on event type.
 * @export
 */
export type WebhookEventTypeFilter = WebhookSmartContractEventFilter | WebhookWalletActivityFilter;
/**
 *
 * @export
 * @interface WebhookList
 */
export interface WebhookList {
    /**
     *
     * @type {Array<Webhook>}
     * @memberof WebhookList
     */
    'data': Array<Webhook>;
    /**
     * True if this list has another page of items after this one that can be fetched.
     * @type {boolean}
     * @memberof WebhookList
     */
    'has_more'?: boolean;
    /**
     * The page token to be used to fetch the next page.
     * @type {string}
     * @memberof WebhookList
     */
    'next_page'?: string;
}
/**
 * Filter for smart contract events. This filter allows the client to specify smart contract addresses to monitor for activities such as contract function calls.
 * @export
 * @interface WebhookSmartContractEventFilter
 */
export interface WebhookSmartContractEventFilter {
    /**
     * A list of smart contract addresses to filter on.
     * @type {Array<string>}
     * @memberof WebhookSmartContractEventFilter
     */
    'contract_addresses': Array<string>;
}
/**
 * Filter for wallet activity events. This filter allows the client to specify one or more wallet addresses to monitor for activities such as transactions, transfers, or other types of events that are associated with the specified addresses.
 * @export
 * @interface WebhookWalletActivityFilter
 */
export interface WebhookWalletActivityFilter {
    /**
     * A list of wallet addresses to filter on.
     * @type {Array<string>}
     * @memberof WebhookWalletActivityFilter
     */
    'addresses'?: Array<string>;
    /**
     * The ID of the wallet that owns the webhook.
     * @type {string}
     * @memberof WebhookWalletActivityFilter
     */
    'wallet_id': string;
}
/**
 * AddressesApi - axios parameter creator
 * @export
 */
export declare const AddressesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new address scoped to the wallet.
     * @summary Create a new address
     * @param {string} walletId The ID of the wallet to create the address in.
     * @param {CreateAddressRequest} [createAddressRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAddress: (walletId: string, createAddressRequest?: CreateAddressRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a new payload signature with an address.
     * @summary Create a new payload signature.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address to sign the payload with.
     * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPayloadSignature: (walletId: string, addressId: string, createPayloadSignatureRequest?: CreatePayloadSignatureRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get address
     * @summary Get address by onchain address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddress: (walletId: string, addressId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get address balance
     * @summary Get address balance for asset
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressBalance: (walletId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get payload signature.
     * @summary Get payload signature.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that signed the payload.
     * @param {string} payloadSignatureId The ID of the payload signature to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayloadSignature: (walletId: string, addressId: string, payloadSignatureId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get address balances
     * @summary Get all balances for address
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddressBalances: (walletId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List addresses in the wallet.
     * @summary List addresses in a wallet.
     * @param {string} walletId The ID of the wallet whose addresses to fetch
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddresses: (walletId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List payload signatures for an address.
     * @summary List payload signatures for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address whose payload signatures to fetch.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPayloadSignatures: (walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Request faucet funds to be sent to onchain address.
     * @summary Request faucet funds for onchain address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [assetId] The ID of the asset to transfer from the faucet.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    requestFaucetFunds: (walletId: string, addressId: string, assetId?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AddressesApi - functional programming interface
 * @export
 */
export declare const AddressesApiFp: (configuration?: Configuration) => {
    /**
     * Create a new address scoped to the wallet.
     * @summary Create a new address
     * @param {string} walletId The ID of the wallet to create the address in.
     * @param {CreateAddressRequest} [createAddressRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAddress(walletId: string, createAddressRequest?: CreateAddressRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>>;
    /**
     * Create a new payload signature with an address.
     * @summary Create a new payload signature.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address to sign the payload with.
     * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPayloadSignature(walletId: string, addressId: string, createPayloadSignatureRequest?: CreatePayloadSignatureRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayloadSignature>>;
    /**
     * Get address
     * @summary Get address by onchain address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddress(walletId: string, addressId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>>;
    /**
     * Get address balance
     * @summary Get address balance for asset
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressBalance(walletId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance>>;
    /**
     * Get payload signature.
     * @summary Get payload signature.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that signed the payload.
     * @param {string} payloadSignatureId The ID of the payload signature to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayloadSignature(walletId: string, addressId: string, payloadSignatureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayloadSignature>>;
    /**
     * Get address balances
     * @summary Get all balances for address
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddressBalances(walletId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressBalanceList>>;
    /**
     * List addresses in the wallet.
     * @summary List addresses in a wallet.
     * @param {string} walletId The ID of the wallet whose addresses to fetch
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddresses(walletId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressList>>;
    /**
     * List payload signatures for an address.
     * @summary List payload signatures for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address whose payload signatures to fetch.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPayloadSignatures(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayloadSignatureList>>;
    /**
     * Request faucet funds to be sent to onchain address.
     * @summary Request faucet funds for onchain address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [assetId] The ID of the asset to transfer from the faucet.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    requestFaucetFunds(walletId: string, addressId: string, assetId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FaucetTransaction>>;
};
/**
 * AddressesApi - factory interface
 * @export
 */
export declare const AddressesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a new address scoped to the wallet.
     * @summary Create a new address
     * @param {string} walletId The ID of the wallet to create the address in.
     * @param {CreateAddressRequest} [createAddressRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAddress(walletId: string, createAddressRequest?: CreateAddressRequest, options?: RawAxiosRequestConfig): AxiosPromise<Address>;
    /**
     * Create a new payload signature with an address.
     * @summary Create a new payload signature.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address to sign the payload with.
     * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPayloadSignature(walletId: string, addressId: string, createPayloadSignatureRequest?: CreatePayloadSignatureRequest, options?: RawAxiosRequestConfig): AxiosPromise<PayloadSignature>;
    /**
     * Get address
     * @summary Get address by onchain address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddress(walletId: string, addressId: string, options?: RawAxiosRequestConfig): AxiosPromise<Address>;
    /**
     * Get address balance
     * @summary Get address balance for asset
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressBalance(walletId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Balance>;
    /**
     * Get payload signature.
     * @summary Get payload signature.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that signed the payload.
     * @param {string} payloadSignatureId The ID of the payload signature to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayloadSignature(walletId: string, addressId: string, payloadSignatureId: string, options?: RawAxiosRequestConfig): AxiosPromise<PayloadSignature>;
    /**
     * Get address balances
     * @summary Get all balances for address
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddressBalances(walletId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressBalanceList>;
    /**
     * List addresses in the wallet.
     * @summary List addresses in a wallet.
     * @param {string} walletId The ID of the wallet whose addresses to fetch
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddresses(walletId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressList>;
    /**
     * List payload signatures for an address.
     * @summary List payload signatures for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address whose payload signatures to fetch.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPayloadSignatures(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<PayloadSignatureList>;
    /**
     * Request faucet funds to be sent to onchain address.
     * @summary Request faucet funds for onchain address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [assetId] The ID of the asset to transfer from the faucet.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    requestFaucetFunds(walletId: string, addressId: string, assetId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FaucetTransaction>;
};
/**
 * AddressesApi - interface
 * @export
 * @interface AddressesApi
 */
export interface AddressesApiInterface {
    /**
     * Create a new address scoped to the wallet.
     * @summary Create a new address
     * @param {string} walletId The ID of the wallet to create the address in.
     * @param {CreateAddressRequest} [createAddressRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    createAddress(walletId: string, createAddressRequest?: CreateAddressRequest, options?: RawAxiosRequestConfig): AxiosPromise<Address>;
    /**
     * Create a new payload signature with an address.
     * @summary Create a new payload signature.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address to sign the payload with.
     * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    createPayloadSignature(walletId: string, addressId: string, createPayloadSignatureRequest?: CreatePayloadSignatureRequest, options?: RawAxiosRequestConfig): AxiosPromise<PayloadSignature>;
    /**
     * Get address
     * @summary Get address by onchain address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getAddress(walletId: string, addressId: string, options?: RawAxiosRequestConfig): AxiosPromise<Address>;
    /**
     * Get address balance
     * @summary Get address balance for asset
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getAddressBalance(walletId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Balance>;
    /**
     * Get payload signature.
     * @summary Get payload signature.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that signed the payload.
     * @param {string} payloadSignatureId The ID of the payload signature to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getPayloadSignature(walletId: string, addressId: string, payloadSignatureId: string, options?: RawAxiosRequestConfig): AxiosPromise<PayloadSignature>;
    /**
     * Get address balances
     * @summary Get all balances for address
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    listAddressBalances(walletId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressBalanceList>;
    /**
     * List addresses in the wallet.
     * @summary List addresses in a wallet.
     * @param {string} walletId The ID of the wallet whose addresses to fetch
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    listAddresses(walletId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressList>;
    /**
     * List payload signatures for an address.
     * @summary List payload signatures for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address whose payload signatures to fetch.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    listPayloadSignatures(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<PayloadSignatureList>;
    /**
     * Request faucet funds to be sent to onchain address.
     * @summary Request faucet funds for onchain address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [assetId] The ID of the asset to transfer from the faucet.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    requestFaucetFunds(walletId: string, addressId: string, assetId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FaucetTransaction>;
}
/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export declare class AddressesApi extends BaseAPI implements AddressesApiInterface {
    /**
     * Create a new address scoped to the wallet.
     * @summary Create a new address
     * @param {string} walletId The ID of the wallet to create the address in.
     * @param {CreateAddressRequest} [createAddressRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    createAddress(walletId: string, createAddressRequest?: CreateAddressRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Address, any>>;
    /**
     * Create a new payload signature with an address.
     * @summary Create a new payload signature.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address to sign the payload with.
     * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    createPayloadSignature(walletId: string, addressId: string, createPayloadSignatureRequest?: CreatePayloadSignatureRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PayloadSignature, any>>;
    /**
     * Get address
     * @summary Get address by onchain address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    getAddress(walletId: string, addressId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Address, any>>;
    /**
     * Get address balance
     * @summary Get address balance for asset
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    getAddressBalance(walletId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Balance, any>>;
    /**
     * Get payload signature.
     * @summary Get payload signature.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that signed the payload.
     * @param {string} payloadSignatureId The ID of the payload signature to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    getPayloadSignature(walletId: string, addressId: string, payloadSignatureId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PayloadSignature, any>>;
    /**
     * Get address balances
     * @summary Get all balances for address
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    listAddressBalances(walletId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AddressBalanceList, any>>;
    /**
     * List addresses in the wallet.
     * @summary List addresses in a wallet.
     * @param {string} walletId The ID of the wallet whose addresses to fetch
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    listAddresses(walletId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AddressList, any>>;
    /**
     * List payload signatures for an address.
     * @summary List payload signatures for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address whose payload signatures to fetch.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    listPayloadSignatures(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PayloadSignatureList, any>>;
    /**
     * Request faucet funds to be sent to onchain address.
     * @summary Request faucet funds for onchain address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [assetId] The ID of the asset to transfer from the faucet.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    requestFaucetFunds(walletId: string, addressId: string, assetId?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<FaucetTransaction, any>>;
}
/**
 * AssetsApi - axios parameter creator
 * @export
 */
export declare const AssetsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get the asset for the specified asset ID.
     * @summary Get the asset for the specified asset ID.
     * @param {string} networkId The ID of the blockchain network
     * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAsset: (networkId: string, assetId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AssetsApi - functional programming interface
 * @export
 */
export declare const AssetsApiFp: (configuration?: Configuration) => {
    /**
     * Get the asset for the specified asset ID.
     * @summary Get the asset for the specified asset ID.
     * @param {string} networkId The ID of the blockchain network
     * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAsset(networkId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>>;
};
/**
 * AssetsApi - factory interface
 * @export
 */
export declare const AssetsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get the asset for the specified asset ID.
     * @summary Get the asset for the specified asset ID.
     * @param {string} networkId The ID of the blockchain network
     * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAsset(networkId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Asset>;
};
/**
 * AssetsApi - interface
 * @export
 * @interface AssetsApi
 */
export interface AssetsApiInterface {
    /**
     * Get the asset for the specified asset ID.
     * @summary Get the asset for the specified asset ID.
     * @param {string} networkId The ID of the blockchain network
     * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApiInterface
     */
    getAsset(networkId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Asset>;
}
/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export declare class AssetsApi extends BaseAPI implements AssetsApiInterface {
    /**
     * Get the asset for the specified asset ID.
     * @summary Get the asset for the specified asset ID.
     * @param {string} networkId The ID of the blockchain network
     * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    getAsset(networkId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Asset, any>>;
}
/**
 * BalanceHistoryApi - axios parameter creator
 * @export
 */
export declare const BalanceHistoryApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * List the historical balance of an asset in a specific address.
     * @summary Get address balance history for asset
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the historical balance for.
     * @param {string} assetId The symbol of the asset to fetch the historical balance for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddressHistoricalBalance: (networkId: string, addressId: string, assetId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * BalanceHistoryApi - functional programming interface
 * @export
 */
export declare const BalanceHistoryApiFp: (configuration?: Configuration) => {
    /**
     * List the historical balance of an asset in a specific address.
     * @summary Get address balance history for asset
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the historical balance for.
     * @param {string} assetId The symbol of the asset to fetch the historical balance for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddressHistoricalBalance(networkId: string, addressId: string, assetId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressHistoricalBalanceList>>;
};
/**
 * BalanceHistoryApi - factory interface
 * @export
 */
export declare const BalanceHistoryApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * List the historical balance of an asset in a specific address.
     * @summary Get address balance history for asset
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the historical balance for.
     * @param {string} assetId The symbol of the asset to fetch the historical balance for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddressHistoricalBalance(networkId: string, addressId: string, assetId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressHistoricalBalanceList>;
};
/**
 * BalanceHistoryApi - interface
 * @export
 * @interface BalanceHistoryApi
 */
export interface BalanceHistoryApiInterface {
    /**
     * List the historical balance of an asset in a specific address.
     * @summary Get address balance history for asset
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the historical balance for.
     * @param {string} assetId The symbol of the asset to fetch the historical balance for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceHistoryApiInterface
     */
    listAddressHistoricalBalance(networkId: string, addressId: string, assetId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressHistoricalBalanceList>;
}
/**
 * BalanceHistoryApi - object-oriented interface
 * @export
 * @class BalanceHistoryApi
 * @extends {BaseAPI}
 */
export declare class BalanceHistoryApi extends BaseAPI implements BalanceHistoryApiInterface {
    /**
     * List the historical balance of an asset in a specific address.
     * @summary Get address balance history for asset
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the historical balance for.
     * @param {string} assetId The symbol of the asset to fetch the historical balance for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceHistoryApi
     */
    listAddressHistoricalBalance(networkId: string, addressId: string, assetId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AddressHistoricalBalanceList, any>>;
}
/**
 * ContractEventsApi - axios parameter creator
 * @export
 */
export declare const ContractEventsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Retrieve events for a specific contract
     * @summary List contract events
     * @param {string} networkId Unique identifier for the blockchain network
     * @param {string} protocolName Case-sensitive name of the blockchain protocol
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {string} contractName Case-sensitive name of the specific contract within the project
     * @param {string} eventName Case-sensitive name of the event to filter for in the contract\&#39;s logs
     * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
     * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
     * @param {string} [nextPage] Pagination token for retrieving the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContractEvents: (networkId: string, protocolName: string, contractAddress: string, contractName: string, eventName: string, fromBlockHeight: number, toBlockHeight: number, nextPage?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ContractEventsApi - functional programming interface
 * @export
 */
export declare const ContractEventsApiFp: (configuration?: Configuration) => {
    /**
     * Retrieve events for a specific contract
     * @summary List contract events
     * @param {string} networkId Unique identifier for the blockchain network
     * @param {string} protocolName Case-sensitive name of the blockchain protocol
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {string} contractName Case-sensitive name of the specific contract within the project
     * @param {string} eventName Case-sensitive name of the event to filter for in the contract\&#39;s logs
     * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
     * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
     * @param {string} [nextPage] Pagination token for retrieving the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContractEvents(networkId: string, protocolName: string, contractAddress: string, contractName: string, eventName: string, fromBlockHeight: number, toBlockHeight: number, nextPage?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractEventList>>;
};
/**
 * ContractEventsApi - factory interface
 * @export
 */
export declare const ContractEventsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Retrieve events for a specific contract
     * @summary List contract events
     * @param {string} networkId Unique identifier for the blockchain network
     * @param {string} protocolName Case-sensitive name of the blockchain protocol
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {string} contractName Case-sensitive name of the specific contract within the project
     * @param {string} eventName Case-sensitive name of the event to filter for in the contract\&#39;s logs
     * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
     * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
     * @param {string} [nextPage] Pagination token for retrieving the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContractEvents(networkId: string, protocolName: string, contractAddress: string, contractName: string, eventName: string, fromBlockHeight: number, toBlockHeight: number, nextPage?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContractEventList>;
};
/**
 * ContractEventsApi - interface
 * @export
 * @interface ContractEventsApi
 */
export interface ContractEventsApiInterface {
    /**
     * Retrieve events for a specific contract
     * @summary List contract events
     * @param {string} networkId Unique identifier for the blockchain network
     * @param {string} protocolName Case-sensitive name of the blockchain protocol
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {string} contractName Case-sensitive name of the specific contract within the project
     * @param {string} eventName Case-sensitive name of the event to filter for in the contract\&#39;s logs
     * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
     * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
     * @param {string} [nextPage] Pagination token for retrieving the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractEventsApiInterface
     */
    listContractEvents(networkId: string, protocolName: string, contractAddress: string, contractName: string, eventName: string, fromBlockHeight: number, toBlockHeight: number, nextPage?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContractEventList>;
}
/**
 * ContractEventsApi - object-oriented interface
 * @export
 * @class ContractEventsApi
 * @extends {BaseAPI}
 */
export declare class ContractEventsApi extends BaseAPI implements ContractEventsApiInterface {
    /**
     * Retrieve events for a specific contract
     * @summary List contract events
     * @param {string} networkId Unique identifier for the blockchain network
     * @param {string} protocolName Case-sensitive name of the blockchain protocol
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {string} contractName Case-sensitive name of the specific contract within the project
     * @param {string} eventName Case-sensitive name of the event to filter for in the contract\&#39;s logs
     * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)
     * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)
     * @param {string} [nextPage] Pagination token for retrieving the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractEventsApi
     */
    listContractEvents(networkId: string, protocolName: string, contractAddress: string, contractName: string, eventName: string, fromBlockHeight: number, toBlockHeight: number, nextPage?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ContractEventList, any>>;
}
/**
 * ContractInvocationsApi - axios parameter creator
 * @export
 */
export declare const ContractInvocationsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Broadcast a contract invocation.
     * @summary Broadcast a contract invocation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the contract invocation belongs to.
     * @param {string} contractInvocationId The ID of the contract invocation to broadcast.
     * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastContractInvocation: (walletId: string, addressId: string, contractInvocationId: string, broadcastContractInvocationRequest: BroadcastContractInvocationRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a new contract invocation.
     * @summary Create a new contract invocation for an address.
     * @param {string} walletId The ID of the wallet the source address belongs to.
     * @param {string} addressId The ID of the address to invoke the contract from.
     * @param {CreateContractInvocationRequest} createContractInvocationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContractInvocation: (walletId: string, addressId: string, createContractInvocationRequest: CreateContractInvocationRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a contract invocation by ID.
     * @summary Get a contract invocation by ID.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the contract invocation belongs to.
     * @param {string} contractInvocationId The ID of the contract invocation to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractInvocation: (walletId: string, addressId: string, contractInvocationId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List contract invocations for an address.
     * @summary List contract invocations for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to list contract invocations for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContractInvocations: (walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ContractInvocationsApi - functional programming interface
 * @export
 */
export declare const ContractInvocationsApiFp: (configuration?: Configuration) => {
    /**
     * Broadcast a contract invocation.
     * @summary Broadcast a contract invocation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the contract invocation belongs to.
     * @param {string} contractInvocationId The ID of the contract invocation to broadcast.
     * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastContractInvocation(walletId: string, addressId: string, contractInvocationId: string, broadcastContractInvocationRequest: BroadcastContractInvocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractInvocation>>;
    /**
     * Create a new contract invocation.
     * @summary Create a new contract invocation for an address.
     * @param {string} walletId The ID of the wallet the source address belongs to.
     * @param {string} addressId The ID of the address to invoke the contract from.
     * @param {CreateContractInvocationRequest} createContractInvocationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContractInvocation(walletId: string, addressId: string, createContractInvocationRequest: CreateContractInvocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractInvocation>>;
    /**
     * Get a contract invocation by ID.
     * @summary Get a contract invocation by ID.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the contract invocation belongs to.
     * @param {string} contractInvocationId The ID of the contract invocation to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractInvocation(walletId: string, addressId: string, contractInvocationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractInvocation>>;
    /**
     * List contract invocations for an address.
     * @summary List contract invocations for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to list contract invocations for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContractInvocations(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractInvocationList>>;
};
/**
 * ContractInvocationsApi - factory interface
 * @export
 */
export declare const ContractInvocationsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Broadcast a contract invocation.
     * @summary Broadcast a contract invocation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the contract invocation belongs to.
     * @param {string} contractInvocationId The ID of the contract invocation to broadcast.
     * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastContractInvocation(walletId: string, addressId: string, contractInvocationId: string, broadcastContractInvocationRequest: BroadcastContractInvocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractInvocation>;
    /**
     * Create a new contract invocation.
     * @summary Create a new contract invocation for an address.
     * @param {string} walletId The ID of the wallet the source address belongs to.
     * @param {string} addressId The ID of the address to invoke the contract from.
     * @param {CreateContractInvocationRequest} createContractInvocationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContractInvocation(walletId: string, addressId: string, createContractInvocationRequest: CreateContractInvocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractInvocation>;
    /**
     * Get a contract invocation by ID.
     * @summary Get a contract invocation by ID.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the contract invocation belongs to.
     * @param {string} contractInvocationId The ID of the contract invocation to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContractInvocation(walletId: string, addressId: string, contractInvocationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ContractInvocation>;
    /**
     * List contract invocations for an address.
     * @summary List contract invocations for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to list contract invocations for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContractInvocations(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContractInvocationList>;
};
/**
 * ContractInvocationsApi - interface
 * @export
 * @interface ContractInvocationsApi
 */
export interface ContractInvocationsApiInterface {
    /**
     * Broadcast a contract invocation.
     * @summary Broadcast a contract invocation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the contract invocation belongs to.
     * @param {string} contractInvocationId The ID of the contract invocation to broadcast.
     * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApiInterface
     */
    broadcastContractInvocation(walletId: string, addressId: string, contractInvocationId: string, broadcastContractInvocationRequest: BroadcastContractInvocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractInvocation>;
    /**
     * Create a new contract invocation.
     * @summary Create a new contract invocation for an address.
     * @param {string} walletId The ID of the wallet the source address belongs to.
     * @param {string} addressId The ID of the address to invoke the contract from.
     * @param {CreateContractInvocationRequest} createContractInvocationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApiInterface
     */
    createContractInvocation(walletId: string, addressId: string, createContractInvocationRequest: CreateContractInvocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContractInvocation>;
    /**
     * Get a contract invocation by ID.
     * @summary Get a contract invocation by ID.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the contract invocation belongs to.
     * @param {string} contractInvocationId The ID of the contract invocation to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApiInterface
     */
    getContractInvocation(walletId: string, addressId: string, contractInvocationId: string, options?: RawAxiosRequestConfig): AxiosPromise<ContractInvocation>;
    /**
     * List contract invocations for an address.
     * @summary List contract invocations for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to list contract invocations for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApiInterface
     */
    listContractInvocations(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContractInvocationList>;
}
/**
 * ContractInvocationsApi - object-oriented interface
 * @export
 * @class ContractInvocationsApi
 * @extends {BaseAPI}
 */
export declare class ContractInvocationsApi extends BaseAPI implements ContractInvocationsApiInterface {
    /**
     * Broadcast a contract invocation.
     * @summary Broadcast a contract invocation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the contract invocation belongs to.
     * @param {string} contractInvocationId The ID of the contract invocation to broadcast.
     * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApi
     */
    broadcastContractInvocation(walletId: string, addressId: string, contractInvocationId: string, broadcastContractInvocationRequest: BroadcastContractInvocationRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ContractInvocation, any>>;
    /**
     * Create a new contract invocation.
     * @summary Create a new contract invocation for an address.
     * @param {string} walletId The ID of the wallet the source address belongs to.
     * @param {string} addressId The ID of the address to invoke the contract from.
     * @param {CreateContractInvocationRequest} createContractInvocationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApi
     */
    createContractInvocation(walletId: string, addressId: string, createContractInvocationRequest: CreateContractInvocationRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ContractInvocation, any>>;
    /**
     * Get a contract invocation by ID.
     * @summary Get a contract invocation by ID.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the contract invocation belongs to.
     * @param {string} contractInvocationId The ID of the contract invocation to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApi
     */
    getContractInvocation(walletId: string, addressId: string, contractInvocationId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ContractInvocation, any>>;
    /**
     * List contract invocations for an address.
     * @summary List contract invocations for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to list contract invocations for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractInvocationsApi
     */
    listContractInvocations(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ContractInvocationList, any>>;
}
/**
 * ExternalAddressesApi - axios parameter creator
 * @export
 */
export declare const ExternalAddressesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Broadcast an external address\'s transfer with a signed payload
     * @summary Broadcast an external address\' transfer
     * @param {string} networkId The ID of the network the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastExternalTransfer: (networkId: string, addressId: string, transferId: string, broadcastExternalTransferRequest: BroadcastExternalTransferRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a new transfer between addresses.
     * @summary Create a new transfer
     * @param {string} networkId The ID of the network the address is on
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateExternalTransferRequest} createExternalTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExternalTransfer: (networkId: string, addressId: string, createExternalTransferRequest: CreateExternalTransferRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the balance of an asset in an external address
     * @summary Get the balance of an asset in an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} assetId The ID of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExternalAddressBalance: (networkId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get an external address\' transfer by ID
     * @summary Get a external address\' transfer
     * @param {string} networkId The ID of the network the address is on
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExternalTransfer: (networkId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the status of a faucet transaction
     * @summary Get the status of a faucet transaction
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the faucet transaction for
     * @param {string} txHash The hash of the faucet transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFaucetTransaction: (networkId: string, addressId: string, txHash: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List all of the balances of an external address
     * @summary Get the balances of an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listExternalAddressBalances: (networkId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Request faucet funds to be sent to external address.
     * @summary Request faucet funds for external address.
     * @param {string} networkId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [assetId] The ID of the asset to transfer from the faucet.
     * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestExternalFaucetFunds: (networkId: string, addressId: string, assetId?: string, skipWait?: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ExternalAddressesApi - functional programming interface
 * @export
 */
export declare const ExternalAddressesApiFp: (configuration?: Configuration) => {
    /**
     * Broadcast an external address\'s transfer with a signed payload
     * @summary Broadcast an external address\' transfer
     * @param {string} networkId The ID of the network the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastExternalTransfer(networkId: string, addressId: string, transferId: string, broadcastExternalTransferRequest: BroadcastExternalTransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>>;
    /**
     * Create a new transfer between addresses.
     * @summary Create a new transfer
     * @param {string} networkId The ID of the network the address is on
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateExternalTransferRequest} createExternalTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExternalTransfer(networkId: string, addressId: string, createExternalTransferRequest: CreateExternalTransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>>;
    /**
     * Get the balance of an asset in an external address
     * @summary Get the balance of an asset in an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} assetId The ID of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExternalAddressBalance(networkId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance>>;
    /**
     * Get an external address\' transfer by ID
     * @summary Get a external address\' transfer
     * @param {string} networkId The ID of the network the address is on
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExternalTransfer(networkId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>>;
    /**
     * Get the status of a faucet transaction
     * @summary Get the status of a faucet transaction
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the faucet transaction for
     * @param {string} txHash The hash of the faucet transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFaucetTransaction(networkId: string, addressId: string, txHash: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FaucetTransaction>>;
    /**
     * List all of the balances of an external address
     * @summary Get the balances of an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listExternalAddressBalances(networkId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressBalanceList>>;
    /**
     * Request faucet funds to be sent to external address.
     * @summary Request faucet funds for external address.
     * @param {string} networkId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [assetId] The ID of the asset to transfer from the faucet.
     * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestExternalFaucetFunds(networkId: string, addressId: string, assetId?: string, skipWait?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FaucetTransaction>>;
};
/**
 * ExternalAddressesApi - factory interface
 * @export
 */
export declare const ExternalAddressesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Broadcast an external address\'s transfer with a signed payload
     * @summary Broadcast an external address\' transfer
     * @param {string} networkId The ID of the network the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastExternalTransfer(networkId: string, addressId: string, transferId: string, broadcastExternalTransferRequest: BroadcastExternalTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;
    /**
     * Create a new transfer between addresses.
     * @summary Create a new transfer
     * @param {string} networkId The ID of the network the address is on
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateExternalTransferRequest} createExternalTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createExternalTransfer(networkId: string, addressId: string, createExternalTransferRequest: CreateExternalTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;
    /**
     * Get the balance of an asset in an external address
     * @summary Get the balance of an asset in an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} assetId The ID of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExternalAddressBalance(networkId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Balance>;
    /**
     * Get an external address\' transfer by ID
     * @summary Get a external address\' transfer
     * @param {string} networkId The ID of the network the address is on
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExternalTransfer(networkId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;
    /**
     * Get the status of a faucet transaction
     * @summary Get the status of a faucet transaction
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the faucet transaction for
     * @param {string} txHash The hash of the faucet transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFaucetTransaction(networkId: string, addressId: string, txHash: string, options?: RawAxiosRequestConfig): AxiosPromise<FaucetTransaction>;
    /**
     * List all of the balances of an external address
     * @summary Get the balances of an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listExternalAddressBalances(networkId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressBalanceList>;
    /**
     * Request faucet funds to be sent to external address.
     * @summary Request faucet funds for external address.
     * @param {string} networkId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [assetId] The ID of the asset to transfer from the faucet.
     * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestExternalFaucetFunds(networkId: string, addressId: string, assetId?: string, skipWait?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<FaucetTransaction>;
};
/**
 * ExternalAddressesApi - interface
 * @export
 * @interface ExternalAddressesApi
 */
export interface ExternalAddressesApiInterface {
    /**
     * Broadcast an external address\'s transfer with a signed payload
     * @summary Broadcast an external address\' transfer
     * @param {string} networkId The ID of the network the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApiInterface
     */
    broadcastExternalTransfer(networkId: string, addressId: string, transferId: string, broadcastExternalTransferRequest: BroadcastExternalTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;
    /**
     * Create a new transfer between addresses.
     * @summary Create a new transfer
     * @param {string} networkId The ID of the network the address is on
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateExternalTransferRequest} createExternalTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApiInterface
     */
    createExternalTransfer(networkId: string, addressId: string, createExternalTransferRequest: CreateExternalTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;
    /**
     * Get the balance of an asset in an external address
     * @summary Get the balance of an asset in an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} assetId The ID of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApiInterface
     */
    getExternalAddressBalance(networkId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Balance>;
    /**
     * Get an external address\' transfer by ID
     * @summary Get a external address\' transfer
     * @param {string} networkId The ID of the network the address is on
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApiInterface
     */
    getExternalTransfer(networkId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;
    /**
     * Get the status of a faucet transaction
     * @summary Get the status of a faucet transaction
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the faucet transaction for
     * @param {string} txHash The hash of the faucet transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApiInterface
     */
    getFaucetTransaction(networkId: string, addressId: string, txHash: string, options?: RawAxiosRequestConfig): AxiosPromise<FaucetTransaction>;
    /**
     * List all of the balances of an external address
     * @summary Get the balances of an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApiInterface
     */
    listExternalAddressBalances(networkId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressBalanceList>;
    /**
     * Request faucet funds to be sent to external address.
     * @summary Request faucet funds for external address.
     * @param {string} networkId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [assetId] The ID of the asset to transfer from the faucet.
     * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApiInterface
     */
    requestExternalFaucetFunds(networkId: string, addressId: string, assetId?: string, skipWait?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<FaucetTransaction>;
}
/**
 * ExternalAddressesApi - object-oriented interface
 * @export
 * @class ExternalAddressesApi
 * @extends {BaseAPI}
 */
export declare class ExternalAddressesApi extends BaseAPI implements ExternalAddressesApiInterface {
    /**
     * Broadcast an external address\'s transfer with a signed payload
     * @summary Broadcast an external address\' transfer
     * @param {string} networkId The ID of the network the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    broadcastExternalTransfer(networkId: string, addressId: string, transferId: string, broadcastExternalTransferRequest: BroadcastExternalTransferRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Transfer, any>>;
    /**
     * Create a new transfer between addresses.
     * @summary Create a new transfer
     * @param {string} networkId The ID of the network the address is on
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateExternalTransferRequest} createExternalTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    createExternalTransfer(networkId: string, addressId: string, createExternalTransferRequest: CreateExternalTransferRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Transfer, any>>;
    /**
     * Get the balance of an asset in an external address
     * @summary Get the balance of an asset in an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} assetId The ID of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    getExternalAddressBalance(networkId: string, addressId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Balance, any>>;
    /**
     * Get an external address\' transfer by ID
     * @summary Get a external address\' transfer
     * @param {string} networkId The ID of the network the address is on
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    getExternalTransfer(networkId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Transfer, any>>;
    /**
     * Get the status of a faucet transaction
     * @summary Get the status of a faucet transaction
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the faucet transaction for
     * @param {string} txHash The hash of the faucet transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    getFaucetTransaction(networkId: string, addressId: string, txHash: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<FaucetTransaction, any>>;
    /**
     * List all of the balances of an external address
     * @summary Get the balances of an external address
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the balance for
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    listExternalAddressBalances(networkId: string, addressId: string, page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AddressBalanceList, any>>;
    /**
     * Request faucet funds to be sent to external address.
     * @summary Request faucet funds for external address.
     * @param {string} networkId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that is being fetched.
     * @param {string} [assetId] The ID of the asset to transfer from the faucet.
     * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAddressesApi
     */
    requestExternalFaucetFunds(networkId: string, addressId: string, assetId?: string, skipWait?: boolean, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<FaucetTransaction, any>>;
}
/**
 * FundApi - axios parameter creator
 * @export
 */
export declare const FundApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new fund operation with an address.
     * @summary Create a new fund operation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address to be funded.
     * @param {CreateFundOperationRequest} createFundOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFundOperation: (walletId: string, addressId: string, createFundOperationRequest: CreateFundOperationRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a new fund operation with an address.
     * @summary Create a Fund Operation quote.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address to be funded.
     * @param {CreateFundQuoteRequest} createFundQuoteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFundQuote: (walletId: string, addressId: string, createFundQuoteRequest: CreateFundQuoteRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get fund operation.
     * @summary Get fund operation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that created the fund operation.
     * @param {string} fundOperationId The ID of the fund operation to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFundOperation: (walletId: string, addressId: string, fundOperationId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List fund operations for an address.
     * @summary List fund operations for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address to list fund operations for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFundOperations: (walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FundApi - functional programming interface
 * @export
 */
export declare const FundApiFp: (configuration?: Configuration) => {
    /**
     * Create a new fund operation with an address.
     * @summary Create a new fund operation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address to be funded.
     * @param {CreateFundOperationRequest} createFundOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFundOperation(walletId: string, addressId: string, createFundOperationRequest: CreateFundOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FundOperation>>;
    /**
     * Create a new fund operation with an address.
     * @summary Create a Fund Operation quote.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address to be funded.
     * @param {CreateFundQuoteRequest} createFundQuoteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFundQuote(walletId: string, addressId: string, createFundQuoteRequest: CreateFundQuoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FundQuote>>;
    /**
     * Get fund operation.
     * @summary Get fund operation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that created the fund operation.
     * @param {string} fundOperationId The ID of the fund operation to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFundOperation(walletId: string, addressId: string, fundOperationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FundOperation>>;
    /**
     * List fund operations for an address.
     * @summary List fund operations for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address to list fund operations for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFundOperations(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FundOperationList>>;
};
/**
 * FundApi - factory interface
 * @export
 */
export declare const FundApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a new fund operation with an address.
     * @summary Create a new fund operation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address to be funded.
     * @param {CreateFundOperationRequest} createFundOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFundOperation(walletId: string, addressId: string, createFundOperationRequest: CreateFundOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<FundOperation>;
    /**
     * Create a new fund operation with an address.
     * @summary Create a Fund Operation quote.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address to be funded.
     * @param {CreateFundQuoteRequest} createFundQuoteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFundQuote(walletId: string, addressId: string, createFundQuoteRequest: CreateFundQuoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<FundQuote>;
    /**
     * Get fund operation.
     * @summary Get fund operation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that created the fund operation.
     * @param {string} fundOperationId The ID of the fund operation to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFundOperation(walletId: string, addressId: string, fundOperationId: string, options?: RawAxiosRequestConfig): AxiosPromise<FundOperation>;
    /**
     * List fund operations for an address.
     * @summary List fund operations for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address to list fund operations for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFundOperations(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<FundOperationList>;
};
/**
 * FundApi - interface
 * @export
 * @interface FundApi
 */
export interface FundApiInterface {
    /**
     * Create a new fund operation with an address.
     * @summary Create a new fund operation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address to be funded.
     * @param {CreateFundOperationRequest} createFundOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApiInterface
     */
    createFundOperation(walletId: string, addressId: string, createFundOperationRequest: CreateFundOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<FundOperation>;
    /**
     * Create a new fund operation with an address.
     * @summary Create a Fund Operation quote.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address to be funded.
     * @param {CreateFundQuoteRequest} createFundQuoteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApiInterface
     */
    createFundQuote(walletId: string, addressId: string, createFundQuoteRequest: CreateFundQuoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<FundQuote>;
    /**
     * Get fund operation.
     * @summary Get fund operation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that created the fund operation.
     * @param {string} fundOperationId The ID of the fund operation to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApiInterface
     */
    getFundOperation(walletId: string, addressId: string, fundOperationId: string, options?: RawAxiosRequestConfig): AxiosPromise<FundOperation>;
    /**
     * List fund operations for an address.
     * @summary List fund operations for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address to list fund operations for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApiInterface
     */
    listFundOperations(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<FundOperationList>;
}
/**
 * FundApi - object-oriented interface
 * @export
 * @class FundApi
 * @extends {BaseAPI}
 */
export declare class FundApi extends BaseAPI implements FundApiInterface {
    /**
     * Create a new fund operation with an address.
     * @summary Create a new fund operation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address to be funded.
     * @param {CreateFundOperationRequest} createFundOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    createFundOperation(walletId: string, addressId: string, createFundOperationRequest: CreateFundOperationRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<FundOperation, any>>;
    /**
     * Create a new fund operation with an address.
     * @summary Create a Fund Operation quote.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address to be funded.
     * @param {CreateFundQuoteRequest} createFundQuoteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    createFundQuote(walletId: string, addressId: string, createFundQuoteRequest: CreateFundQuoteRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<FundQuote, any>>;
    /**
     * Get fund operation.
     * @summary Get fund operation.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address that created the fund operation.
     * @param {string} fundOperationId The ID of the fund operation to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    getFundOperation(walletId: string, addressId: string, fundOperationId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<FundOperation, any>>;
    /**
     * List fund operations for an address.
     * @summary List fund operations for an address.
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The onchain address of the address to list fund operations for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundApi
     */
    listFundOperations(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<FundOperationList, any>>;
}
/**
 * MPCWalletStakeApi - axios parameter creator
 * @export
 */
export declare const MPCWalletStakeApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Broadcast a staking operation.
     * @summary Broadcast a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the staking operation belongs to.
     * @param {string} stakingOperationId The ID of the staking operation to broadcast.
     * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastStakingOperation: (walletId: string, addressId: string, stakingOperationId: string, broadcastStakingOperationRequest: BroadcastStakingOperationRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a new staking operation.
     * @summary Create a new staking operation for an address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to create the staking operation for.
     * @param {CreateStakingOperationRequest} createStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStakingOperation: (walletId: string, addressId: string, createStakingOperationRequest: CreateStakingOperationRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the latest state of a staking operation.
     * @summary Get the latest state of a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to fetch the staking operation for.
     * @param {string} stakingOperationId The ID of the staking operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStakingOperation: (walletId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * MPCWalletStakeApi - functional programming interface
 * @export
 */
export declare const MPCWalletStakeApiFp: (configuration?: Configuration) => {
    /**
     * Broadcast a staking operation.
     * @summary Broadcast a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the staking operation belongs to.
     * @param {string} stakingOperationId The ID of the staking operation to broadcast.
     * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastStakingOperation(walletId: string, addressId: string, stakingOperationId: string, broadcastStakingOperationRequest: BroadcastStakingOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingOperation>>;
    /**
     * Create a new staking operation.
     * @summary Create a new staking operation for an address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to create the staking operation for.
     * @param {CreateStakingOperationRequest} createStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStakingOperation(walletId: string, addressId: string, createStakingOperationRequest: CreateStakingOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingOperation>>;
    /**
     * Get the latest state of a staking operation.
     * @summary Get the latest state of a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to fetch the staking operation for.
     * @param {string} stakingOperationId The ID of the staking operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStakingOperation(walletId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingOperation>>;
};
/**
 * MPCWalletStakeApi - factory interface
 * @export
 */
export declare const MPCWalletStakeApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Broadcast a staking operation.
     * @summary Broadcast a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the staking operation belongs to.
     * @param {string} stakingOperationId The ID of the staking operation to broadcast.
     * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastStakingOperation(walletId: string, addressId: string, stakingOperationId: string, broadcastStakingOperationRequest: BroadcastStakingOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;
    /**
     * Create a new staking operation.
     * @summary Create a new staking operation for an address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to create the staking operation for.
     * @param {CreateStakingOperationRequest} createStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStakingOperation(walletId: string, addressId: string, createStakingOperationRequest: CreateStakingOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;
    /**
     * Get the latest state of a staking operation.
     * @summary Get the latest state of a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to fetch the staking operation for.
     * @param {string} stakingOperationId The ID of the staking operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStakingOperation(walletId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;
};
/**
 * MPCWalletStakeApi - interface
 * @export
 * @interface MPCWalletStakeApi
 */
export interface MPCWalletStakeApiInterface {
    /**
     * Broadcast a staking operation.
     * @summary Broadcast a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the staking operation belongs to.
     * @param {string} stakingOperationId The ID of the staking operation to broadcast.
     * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MPCWalletStakeApiInterface
     */
    broadcastStakingOperation(walletId: string, addressId: string, stakingOperationId: string, broadcastStakingOperationRequest: BroadcastStakingOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;
    /**
     * Create a new staking operation.
     * @summary Create a new staking operation for an address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to create the staking operation for.
     * @param {CreateStakingOperationRequest} createStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MPCWalletStakeApiInterface
     */
    createStakingOperation(walletId: string, addressId: string, createStakingOperationRequest: CreateStakingOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;
    /**
     * Get the latest state of a staking operation.
     * @summary Get the latest state of a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to fetch the staking operation for.
     * @param {string} stakingOperationId The ID of the staking operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MPCWalletStakeApiInterface
     */
    getStakingOperation(walletId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;
}
/**
 * MPCWalletStakeApi - object-oriented interface
 * @export
 * @class MPCWalletStakeApi
 * @extends {BaseAPI}
 */
export declare class MPCWalletStakeApi extends BaseAPI implements MPCWalletStakeApiInterface {
    /**
     * Broadcast a staking operation.
     * @summary Broadcast a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address the staking operation belongs to.
     * @param {string} stakingOperationId The ID of the staking operation to broadcast.
     * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MPCWalletStakeApi
     */
    broadcastStakingOperation(walletId: string, addressId: string, stakingOperationId: string, broadcastStakingOperationRequest: BroadcastStakingOperationRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<StakingOperation, any>>;
    /**
     * Create a new staking operation.
     * @summary Create a new staking operation for an address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to create the staking operation for.
     * @param {CreateStakingOperationRequest} createStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MPCWalletStakeApi
     */
    createStakingOperation(walletId: string, addressId: string, createStakingOperationRequest: CreateStakingOperationRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<StakingOperation, any>>;
    /**
     * Get the latest state of a staking operation.
     * @summary Get the latest state of a staking operation
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to fetch the staking operation for.
     * @param {string} stakingOperationId The ID of the staking operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MPCWalletStakeApi
     */
    getStakingOperation(walletId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<StakingOperation, any>>;
}
/**
 * NetworksApi - axios parameter creator
 * @export
 */
export declare const NetworksApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get network
     * @summary Get network by ID
     * @param {string} networkId The ID of the network to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNetwork: (networkId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * NetworksApi - functional programming interface
 * @export
 */
export declare const NetworksApiFp: (configuration?: Configuration) => {
    /**
     * Get network
     * @summary Get network by ID
     * @param {string} networkId The ID of the network to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNetwork(networkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Network>>;
};
/**
 * NetworksApi - factory interface
 * @export
 */
export declare const NetworksApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get network
     * @summary Get network by ID
     * @param {string} networkId The ID of the network to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNetwork(networkId: string, options?: RawAxiosRequestConfig): AxiosPromise<Network>;
};
/**
 * NetworksApi - interface
 * @export
 * @interface NetworksApi
 */
export interface NetworksApiInterface {
    /**
     * Get network
     * @summary Get network by ID
     * @param {string} networkId The ID of the network to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApiInterface
     */
    getNetwork(networkId: string, options?: RawAxiosRequestConfig): AxiosPromise<Network>;
}
/**
 * NetworksApi - object-oriented interface
 * @export
 * @class NetworksApi
 * @extends {BaseAPI}
 */
export declare class NetworksApi extends BaseAPI implements NetworksApiInterface {
    /**
     * Get network
     * @summary Get network by ID
     * @param {string} networkId The ID of the network to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    getNetwork(networkId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Network, any>>;
}
/**
 * OnchainIdentityApi - axios parameter creator
 * @export
 */
export declare const OnchainIdentityApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Obtains onchain identity for an address on a specific network
     * @summary Obtains onchain identity for an address on a specific network
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the identity for
     * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resolveIdentityByAddress: (networkId: string, addressId: string, roles?: Array<ResolveIdentityByAddressRolesEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * OnchainIdentityApi - functional programming interface
 * @export
 */
export declare const OnchainIdentityApiFp: (configuration?: Configuration) => {
    /**
     * Obtains onchain identity for an address on a specific network
     * @summary Obtains onchain identity for an address on a specific network
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the identity for
     * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resolveIdentityByAddress(networkId: string, addressId: string, roles?: Array<ResolveIdentityByAddressRolesEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnchainNameList>>;
};
/**
 * OnchainIdentityApi - factory interface
 * @export
 */
export declare const OnchainIdentityApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Obtains onchain identity for an address on a specific network
     * @summary Obtains onchain identity for an address on a specific network
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the identity for
     * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resolveIdentityByAddress(networkId: string, addressId: string, roles?: Array<ResolveIdentityByAddressRolesEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<OnchainNameList>;
};
/**
 * OnchainIdentityApi - interface
 * @export
 * @interface OnchainIdentityApi
 */
export interface OnchainIdentityApiInterface {
    /**
     * Obtains onchain identity for an address on a specific network
     * @summary Obtains onchain identity for an address on a specific network
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the identity for
     * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnchainIdentityApiInterface
     */
    resolveIdentityByAddress(networkId: string, addressId: string, roles?: Array<ResolveIdentityByAddressRolesEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<OnchainNameList>;
}
/**
 * OnchainIdentityApi - object-oriented interface
 * @export
 * @class OnchainIdentityApi
 * @extends {BaseAPI}
 */
export declare class OnchainIdentityApi extends BaseAPI implements OnchainIdentityApiInterface {
    /**
     * Obtains onchain identity for an address on a specific network
     * @summary Obtains onchain identity for an address on a specific network
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the identity for
     * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnchainIdentityApi
     */
    resolveIdentityByAddress(networkId: string, addressId: string, roles?: Array<ResolveIdentityByAddressRolesEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<OnchainNameList, any>>;
}
/**
 * @export
 */
export declare const ResolveIdentityByAddressRolesEnum: {
    readonly Managed: "managed";
    readonly Owned: "owned";
};
export type ResolveIdentityByAddressRolesEnum = typeof ResolveIdentityByAddressRolesEnum[keyof typeof ResolveIdentityByAddressRolesEnum];
/**
 * ReputationApi - axios parameter creator
 * @export
 */
export declare const ReputationApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get the onchain reputation of an external address
     * @summary Get the onchain reputation of an external address
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} addressId The ID of the address to fetch the reputation for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressReputation: (networkId: string, addressId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ReputationApi - functional programming interface
 * @export
 */
export declare const ReputationApiFp: (configuration?: Configuration) => {
    /**
     * Get the onchain reputation of an external address
     * @summary Get the onchain reputation of an external address
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} addressId The ID of the address to fetch the reputation for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressReputation(networkId: string, addressId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressReputation>>;
};
/**
 * ReputationApi - factory interface
 * @export
 */
export declare const ReputationApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get the onchain reputation of an external address
     * @summary Get the onchain reputation of an external address
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} addressId The ID of the address to fetch the reputation for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressReputation(networkId: string, addressId: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressReputation>;
};
/**
 * ReputationApi - interface
 * @export
 * @interface ReputationApi
 */
export interface ReputationApiInterface {
    /**
     * Get the onchain reputation of an external address
     * @summary Get the onchain reputation of an external address
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} addressId The ID of the address to fetch the reputation for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReputationApiInterface
     */
    getAddressReputation(networkId: string, addressId: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressReputation>;
}
/**
 * ReputationApi - object-oriented interface
 * @export
 * @class ReputationApi
 * @extends {BaseAPI}
 */
export declare class ReputationApi extends BaseAPI implements ReputationApiInterface {
    /**
     * Get the onchain reputation of an external address
     * @summary Get the onchain reputation of an external address
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} addressId The ID of the address to fetch the reputation for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReputationApi
     */
    getAddressReputation(networkId: string, addressId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AddressReputation, any>>;
}
/**
 * ServerSignersApi - axios parameter creator
 * @export
 */
export declare const ServerSignersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new Server-Signer
     * @summary Create a new Server-Signer
     * @param {CreateServerSignerRequest} [createServerSignerRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createServerSigner: (createServerSignerRequest?: CreateServerSignerRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a server signer by ID
     * @summary Get a server signer by ID
     * @param {string} serverSignerId The ID of the server signer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerSigner: (serverSignerId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List events for a server signer
     * @summary List events for a server signer
     * @param {string} serverSignerId The ID of the server signer to fetch events for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    listServerSignerEvents: (serverSignerId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List server signers for the current project
     * @summary List server signers for the current project
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listServerSigners: (limit?: number, page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SeedCreationEventResult} [seedCreationEventResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitServerSignerSeedEventResult: (serverSignerId: string, seedCreationEventResult?: SeedCreationEventResult, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SignatureCreationEventResult} [signatureCreationEventResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitServerSignerSignatureEventResult: (serverSignerId: string, signatureCreationEventResult?: SignatureCreationEventResult, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ServerSignersApi - functional programming interface
 * @export
 */
export declare const ServerSignersApiFp: (configuration?: Configuration) => {
    /**
     * Create a new Server-Signer
     * @summary Create a new Server-Signer
     * @param {CreateServerSignerRequest} [createServerSignerRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createServerSigner(createServerSignerRequest?: CreateServerSignerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerSigner>>;
    /**
     * Get a server signer by ID
     * @summary Get a server signer by ID
     * @param {string} serverSignerId The ID of the server signer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerSigner(serverSignerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerSigner>>;
    /**
     * List events for a server signer
     * @summary List events for a server signer
     * @param {string} serverSignerId The ID of the server signer to fetch events for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    listServerSignerEvents(serverSignerId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerSignerEventList>>;
    /**
     * List server signers for the current project
     * @summary List server signers for the current project
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listServerSigners(limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerSignerList>>;
    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SeedCreationEventResult} [seedCreationEventResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitServerSignerSeedEventResult(serverSignerId: string, seedCreationEventResult?: SeedCreationEventResult, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeedCreationEventResult>>;
    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SignatureCreationEventResult} [signatureCreationEventResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitServerSignerSignatureEventResult(serverSignerId: string, signatureCreationEventResult?: SignatureCreationEventResult, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignatureCreationEventResult>>;
};
/**
 * ServerSignersApi - factory interface
 * @export
 */
export declare const ServerSignersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a new Server-Signer
     * @summary Create a new Server-Signer
     * @param {CreateServerSignerRequest} [createServerSignerRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createServerSigner(createServerSignerRequest?: CreateServerSignerRequest, options?: RawAxiosRequestConfig): AxiosPromise<ServerSigner>;
    /**
     * Get a server signer by ID
     * @summary Get a server signer by ID
     * @param {string} serverSignerId The ID of the server signer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerSigner(serverSignerId: string, options?: RawAxiosRequestConfig): AxiosPromise<ServerSigner>;
    /**
     * List events for a server signer
     * @summary List events for a server signer
     * @param {string} serverSignerId The ID of the server signer to fetch events for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    listServerSignerEvents(serverSignerId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ServerSignerEventList>;
    /**
     * List server signers for the current project
     * @summary List server signers for the current project
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listServerSigners(limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ServerSignerList>;
    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SeedCreationEventResult} [seedCreationEventResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitServerSignerSeedEventResult(serverSignerId: string, seedCreationEventResult?: SeedCreationEventResult, options?: RawAxiosRequestConfig): AxiosPromise<SeedCreationEventResult>;
    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SignatureCreationEventResult} [signatureCreationEventResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitServerSignerSignatureEventResult(serverSignerId: string, signatureCreationEventResult?: SignatureCreationEventResult, options?: RawAxiosRequestConfig): AxiosPromise<SignatureCreationEventResult>;
};
/**
 * ServerSignersApi - interface
 * @export
 * @interface ServerSignersApi
 */
export interface ServerSignersApiInterface {
    /**
     * Create a new Server-Signer
     * @summary Create a new Server-Signer
     * @param {CreateServerSignerRequest} [createServerSignerRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApiInterface
     */
    createServerSigner(createServerSignerRequest?: CreateServerSignerRequest, options?: RawAxiosRequestConfig): AxiosPromise<ServerSigner>;
    /**
     * Get a server signer by ID
     * @summary Get a server signer by ID
     * @param {string} serverSignerId The ID of the server signer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApiInterface
     */
    getServerSigner(serverSignerId: string, options?: RawAxiosRequestConfig): AxiosPromise<ServerSigner>;
    /**
     * List events for a server signer
     * @summary List events for a server signer
     * @param {string} serverSignerId The ID of the server signer to fetch events for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ServerSignersApiInterface
     */
    listServerSignerEvents(serverSignerId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ServerSignerEventList>;
    /**
     * List server signers for the current project
     * @summary List server signers for the current project
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApiInterface
     */
    listServerSigners(limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ServerSignerList>;
    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SeedCreationEventResult} [seedCreationEventResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApiInterface
     */
    submitServerSignerSeedEventResult(serverSignerId: string, seedCreationEventResult?: SeedCreationEventResult, options?: RawAxiosRequestConfig): AxiosPromise<SeedCreationEventResult>;
    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SignatureCreationEventResult} [signatureCreationEventResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApiInterface
     */
    submitServerSignerSignatureEventResult(serverSignerId: string, signatureCreationEventResult?: SignatureCreationEventResult, options?: RawAxiosRequestConfig): AxiosPromise<SignatureCreationEventResult>;
}
/**
 * ServerSignersApi - object-oriented interface
 * @export
 * @class ServerSignersApi
 * @extends {BaseAPI}
 */
export declare class ServerSignersApi extends BaseAPI implements ServerSignersApiInterface {
    /**
     * Create a new Server-Signer
     * @summary Create a new Server-Signer
     * @param {CreateServerSignerRequest} [createServerSignerRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    createServerSigner(createServerSignerRequest?: CreateServerSignerRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ServerSigner, any>>;
    /**
     * Get a server signer by ID
     * @summary Get a server signer by ID
     * @param {string} serverSignerId The ID of the server signer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    getServerSigner(serverSignerId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ServerSigner, any>>;
    /**
     * List events for a server signer
     * @summary List events for a server signer
     * @param {string} serverSignerId The ID of the server signer to fetch events for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    listServerSignerEvents(serverSignerId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ServerSignerEventList, any>>;
    /**
     * List server signers for the current project
     * @summary List server signers for the current project
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    listServerSigners(limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ServerSignerList, any>>;
    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SeedCreationEventResult} [seedCreationEventResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    submitServerSignerSeedEventResult(serverSignerId: string, seedCreationEventResult?: SeedCreationEventResult, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<SeedCreationEventResult, any>>;
    /**
     * Submit the result of a server signer event
     * @summary Submit the result of a server signer event
     * @param {string} serverSignerId The ID of the server signer to submit the event result for
     * @param {SignatureCreationEventResult} [signatureCreationEventResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSignersApi
     */
    submitServerSignerSignatureEventResult(serverSignerId: string, signatureCreationEventResult?: SignatureCreationEventResult, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<SignatureCreationEventResult, any>>;
}
/**
 * SmartContractsApi - axios parameter creator
 * @export
 */
export declare const SmartContractsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Compile a smart contract
     * @summary Compile a smart contract
     * @param {CompileSmartContractRequest} compileSmartContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    compileSmartContract: (compileSmartContractRequest: CompileSmartContractRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a new smart contract
     * @summary Create a new smart contract
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to deploy the smart contract from.
     * @param {CreateSmartContractRequest} createSmartContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSmartContract: (walletId: string, addressId: string, createSmartContractRequest: CreateSmartContractRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Deploys a smart contract, by broadcasting the transaction to the network.
     * @summary Deploy a smart contract
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to broadcast the transaction from.
     * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.
     * @param {DeploySmartContractRequest} deploySmartContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deploySmartContract: (walletId: string, addressId: string, smartContractId: string, deploySmartContractRequest: DeploySmartContractRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a specific smart contract deployed by address.
     * @summary Get a specific smart contract deployed by address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to fetch the smart contract for.
     * @param {string} smartContractId The UUID of the smart contract to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSmartContract: (walletId: string, addressId: string, smartContractId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List smart contracts
     * @summary List smart contracts
     * @param {string} [page] Pagination token for retrieving the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSmartContracts: (page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Perform a read operation on a smart contract without creating a transaction
     * @summary Read data from a smart contract
     * @param {string} networkId
     * @param {string} contractAddress
     * @param {ReadContractRequest} readContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readContract: (networkId: string, contractAddress: string, readContractRequest: ReadContractRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Register a smart contract
     * @summary Register a smart contract
     * @param {string} networkId The ID of the network to fetch.
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {RegisterSmartContractRequest} [registerSmartContractRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerSmartContract: (networkId: string, contractAddress: string, registerSmartContractRequest?: RegisterSmartContractRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update a smart contract
     * @summary Update a smart contract
     * @param {string} networkId The ID of the network to fetch.
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {UpdateSmartContractRequest} [updateSmartContractRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSmartContract: (networkId: string, contractAddress: string, updateSmartContractRequest?: UpdateSmartContractRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * SmartContractsApi - functional programming interface
 * @export
 */
export declare const SmartContractsApiFp: (configuration?: Configuration) => {
    /**
     * Compile a smart contract
     * @summary Compile a smart contract
     * @param {CompileSmartContractRequest} compileSmartContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    compileSmartContract(compileSmartContractRequest: CompileSmartContractRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompiledSmartContract>>;
    /**
     * Create a new smart contract
     * @summary Create a new smart contract
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to deploy the smart contract from.
     * @param {CreateSmartContractRequest} createSmartContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSmartContract(walletId: string, addressId: string, createSmartContractRequest: CreateSmartContractRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContract>>;
    /**
     * Deploys a smart contract, by broadcasting the transaction to the network.
     * @summary Deploy a smart contract
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to broadcast the transaction from.
     * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.
     * @param {DeploySmartContractRequest} deploySmartContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deploySmartContract(walletId: string, addressId: string, smartContractId: string, deploySmartContractRequest: DeploySmartContractRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContract>>;
    /**
     * Get a specific smart contract deployed by address.
     * @summary Get a specific smart contract deployed by address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to fetch the smart contract for.
     * @param {string} smartContractId The UUID of the smart contract to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSmartContract(walletId: string, addressId: string, smartContractId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContract>>;
    /**
     * List smart contracts
     * @summary List smart contracts
     * @param {string} [page] Pagination token for retrieving the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSmartContracts(page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContractList>>;
    /**
     * Perform a read operation on a smart contract without creating a transaction
     * @summary Read data from a smart contract
     * @param {string} networkId
     * @param {string} contractAddress
     * @param {ReadContractRequest} readContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readContract(networkId: string, contractAddress: string, readContractRequest: ReadContractRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolidityValue>>;
    /**
     * Register a smart contract
     * @summary Register a smart contract
     * @param {string} networkId The ID of the network to fetch.
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {RegisterSmartContractRequest} [registerSmartContractRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerSmartContract(networkId: string, contractAddress: string, registerSmartContractRequest?: RegisterSmartContractRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContract>>;
    /**
     * Update a smart contract
     * @summary Update a smart contract
     * @param {string} networkId The ID of the network to fetch.
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {UpdateSmartContractRequest} [updateSmartContractRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSmartContract(networkId: string, contractAddress: string, updateSmartContractRequest?: UpdateSmartContractRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContract>>;
};
/**
 * SmartContractsApi - factory interface
 * @export
 */
export declare const SmartContractsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Compile a smart contract
     * @summary Compile a smart contract
     * @param {CompileSmartContractRequest} compileSmartContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    compileSmartContract(compileSmartContractRequest: CompileSmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<CompiledSmartContract>;
    /**
     * Create a new smart contract
     * @summary Create a new smart contract
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to deploy the smart contract from.
     * @param {CreateSmartContractRequest} createSmartContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSmartContract(walletId: string, addressId: string, createSmartContractRequest: CreateSmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract>;
    /**
     * Deploys a smart contract, by broadcasting the transaction to the network.
     * @summary Deploy a smart contract
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to broadcast the transaction from.
     * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.
     * @param {DeploySmartContractRequest} deploySmartContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deploySmartContract(walletId: string, addressId: string, smartContractId: string, deploySmartContractRequest: DeploySmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract>;
    /**
     * Get a specific smart contract deployed by address.
     * @summary Get a specific smart contract deployed by address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to fetch the smart contract for.
     * @param {string} smartContractId The UUID of the smart contract to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSmartContract(walletId: string, addressId: string, smartContractId: string, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract>;
    /**
     * List smart contracts
     * @summary List smart contracts
     * @param {string} [page] Pagination token for retrieving the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSmartContracts(page?: string, options?: RawAxiosRequestConfig): AxiosPromise<SmartContractList>;
    /**
     * Perform a read operation on a smart contract without creating a transaction
     * @summary Read data from a smart contract
     * @param {string} networkId
     * @param {string} contractAddress
     * @param {ReadContractRequest} readContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readContract(networkId: string, contractAddress: string, readContractRequest: ReadContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SolidityValue>;
    /**
     * Register a smart contract
     * @summary Register a smart contract
     * @param {string} networkId The ID of the network to fetch.
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {RegisterSmartContractRequest} [registerSmartContractRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerSmartContract(networkId: string, contractAddress: string, registerSmartContractRequest?: RegisterSmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract>;
    /**
     * Update a smart contract
     * @summary Update a smart contract
     * @param {string} networkId The ID of the network to fetch.
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {UpdateSmartContractRequest} [updateSmartContractRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSmartContract(networkId: string, contractAddress: string, updateSmartContractRequest?: UpdateSmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract>;
};
/**
 * SmartContractsApi - interface
 * @export
 * @interface SmartContractsApi
 */
export interface SmartContractsApiInterface {
    /**
     * Compile a smart contract
     * @summary Compile a smart contract
     * @param {CompileSmartContractRequest} compileSmartContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApiInterface
     */
    compileSmartContract(compileSmartContractRequest: CompileSmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<CompiledSmartContract>;
    /**
     * Create a new smart contract
     * @summary Create a new smart contract
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to deploy the smart contract from.
     * @param {CreateSmartContractRequest} createSmartContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApiInterface
     */
    createSmartContract(walletId: string, addressId: string, createSmartContractRequest: CreateSmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract>;
    /**
     * Deploys a smart contract, by broadcasting the transaction to the network.
     * @summary Deploy a smart contract
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to broadcast the transaction from.
     * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.
     * @param {DeploySmartContractRequest} deploySmartContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApiInterface
     */
    deploySmartContract(walletId: string, addressId: string, smartContractId: string, deploySmartContractRequest: DeploySmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract>;
    /**
     * Get a specific smart contract deployed by address.
     * @summary Get a specific smart contract deployed by address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to fetch the smart contract for.
     * @param {string} smartContractId The UUID of the smart contract to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApiInterface
     */
    getSmartContract(walletId: string, addressId: string, smartContractId: string, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract>;
    /**
     * List smart contracts
     * @summary List smart contracts
     * @param {string} [page] Pagination token for retrieving the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApiInterface
     */
    listSmartContracts(page?: string, options?: RawAxiosRequestConfig): AxiosPromise<SmartContractList>;
    /**
     * Perform a read operation on a smart contract without creating a transaction
     * @summary Read data from a smart contract
     * @param {string} networkId
     * @param {string} contractAddress
     * @param {ReadContractRequest} readContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApiInterface
     */
    readContract(networkId: string, contractAddress: string, readContractRequest: ReadContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SolidityValue>;
    /**
     * Register a smart contract
     * @summary Register a smart contract
     * @param {string} networkId The ID of the network to fetch.
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {RegisterSmartContractRequest} [registerSmartContractRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApiInterface
     */
    registerSmartContract(networkId: string, contractAddress: string, registerSmartContractRequest?: RegisterSmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract>;
    /**
     * Update a smart contract
     * @summary Update a smart contract
     * @param {string} networkId The ID of the network to fetch.
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {UpdateSmartContractRequest} [updateSmartContractRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApiInterface
     */
    updateSmartContract(networkId: string, contractAddress: string, updateSmartContractRequest?: UpdateSmartContractRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartContract>;
}
/**
 * SmartContractsApi - object-oriented interface
 * @export
 * @class SmartContractsApi
 * @extends {BaseAPI}
 */
export declare class SmartContractsApi extends BaseAPI implements SmartContractsApiInterface {
    /**
     * Compile a smart contract
     * @summary Compile a smart contract
     * @param {CompileSmartContractRequest} compileSmartContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    compileSmartContract(compileSmartContractRequest: CompileSmartContractRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CompiledSmartContract, any>>;
    /**
     * Create a new smart contract
     * @summary Create a new smart contract
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to deploy the smart contract from.
     * @param {CreateSmartContractRequest} createSmartContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    createSmartContract(walletId: string, addressId: string, createSmartContractRequest: CreateSmartContractRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<SmartContract, any>>;
    /**
     * Deploys a smart contract, by broadcasting the transaction to the network.
     * @summary Deploy a smart contract
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to broadcast the transaction from.
     * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.
     * @param {DeploySmartContractRequest} deploySmartContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    deploySmartContract(walletId: string, addressId: string, smartContractId: string, deploySmartContractRequest: DeploySmartContractRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<SmartContract, any>>;
    /**
     * Get a specific smart contract deployed by address.
     * @summary Get a specific smart contract deployed by address
     * @param {string} walletId The ID of the wallet the address belongs to.
     * @param {string} addressId The ID of the address to fetch the smart contract for.
     * @param {string} smartContractId The UUID of the smart contract to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    getSmartContract(walletId: string, addressId: string, smartContractId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<SmartContract, any>>;
    /**
     * List smart contracts
     * @summary List smart contracts
     * @param {string} [page] Pagination token for retrieving the next set of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    listSmartContracts(page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<SmartContractList, any>>;
    /**
     * Perform a read operation on a smart contract without creating a transaction
     * @summary Read data from a smart contract
     * @param {string} networkId
     * @param {string} contractAddress
     * @param {ReadContractRequest} readContractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    readContract(networkId: string, contractAddress: string, readContractRequest: ReadContractRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<SolidityValue, any>>;
    /**
     * Register a smart contract
     * @summary Register a smart contract
     * @param {string} networkId The ID of the network to fetch.
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {RegisterSmartContractRequest} [registerSmartContractRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    registerSmartContract(networkId: string, contractAddress: string, registerSmartContractRequest?: RegisterSmartContractRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<SmartContract, any>>;
    /**
     * Update a smart contract
     * @summary Update a smart contract
     * @param {string} networkId The ID of the network to fetch.
     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \&#39;0x\&#39;, in lowercase)
     * @param {UpdateSmartContractRequest} [updateSmartContractRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractsApi
     */
    updateSmartContract(networkId: string, contractAddress: string, updateSmartContractRequest?: UpdateSmartContractRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<SmartContract, any>>;
}
/**
 * StakeApi - axios parameter creator
 * @export
 */
export declare const StakeApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Build a new staking operation
     * @summary Build a new staking operation
     * @param {BuildStakingOperationRequest} buildStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    buildStakingOperation: (buildStakingOperationRequest: BuildStakingOperationRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fetch historical staking balances for given address.
     * @summary Fetch historical staking balances
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.
     * @param {string} addressId The onchain address for which the historical staking balances are being fetched.
     * @param {string} startTime The start time of this historical staking balance period.
     * @param {string} endTime The end time of this historical staking balance period.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchHistoricalStakingBalances: (networkId: string, assetId: string, addressId: string, startTime: string, endTime: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fetch staking rewards for a list of addresses
     * @summary Fetch staking rewards
     * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchStakingRewards: (fetchStakingRewardsRequest: FetchStakingRewardsRequest, limit?: number, page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the latest state of a staking operation
     * @summary Get the latest state of a staking operation
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the staking operation for
     * @param {string} stakingOperationId The ID of the staking operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExternalStakingOperation: (networkId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get staking context for an address
     * @summary Get staking context
     * @param {GetStakingContextRequest} getStakingContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStakingContext: (getStakingContextRequest: GetStakingContextRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a validator belonging to the user for a given network, asset and id.
     * @summary Get a validator belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validator for.
     * @param {string} validatorId The unique id of the validator to fetch details for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getValidator: (networkId: string, assetId: string, validatorId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List validators belonging to the user for a given network and asset.
     * @summary List validators belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validators for.
     * @param {ValidatorStatus} [status] A filter to list validators based on a status.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listValidators: (networkId: string, assetId: string, status?: ValidatorStatus, limit?: number, page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * StakeApi - functional programming interface
 * @export
 */
export declare const StakeApiFp: (configuration?: Configuration) => {
    /**
     * Build a new staking operation
     * @summary Build a new staking operation
     * @param {BuildStakingOperationRequest} buildStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    buildStakingOperation(buildStakingOperationRequest: BuildStakingOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingOperation>>;
    /**
     * Fetch historical staking balances for given address.
     * @summary Fetch historical staking balances
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.
     * @param {string} addressId The onchain address for which the historical staking balances are being fetched.
     * @param {string} startTime The start time of this historical staking balance period.
     * @param {string} endTime The end time of this historical staking balance period.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchHistoricalStakingBalances(networkId: string, assetId: string, addressId: string, startTime: string, endTime: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FetchHistoricalStakingBalances200Response>>;
    /**
     * Fetch staking rewards for a list of addresses
     * @summary Fetch staking rewards
     * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchStakingRewards(fetchStakingRewardsRequest: FetchStakingRewardsRequest, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FetchStakingRewards200Response>>;
    /**
     * Get the latest state of a staking operation
     * @summary Get the latest state of a staking operation
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the staking operation for
     * @param {string} stakingOperationId The ID of the staking operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExternalStakingOperation(networkId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingOperation>>;
    /**
     * Get staking context for an address
     * @summary Get staking context
     * @param {GetStakingContextRequest} getStakingContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStakingContext(getStakingContextRequest: GetStakingContextRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingContext>>;
    /**
     * Get a validator belonging to the user for a given network, asset and id.
     * @summary Get a validator belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validator for.
     * @param {string} validatorId The unique id of the validator to fetch details for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getValidator(networkId: string, assetId: string, validatorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Validator>>;
    /**
     * List validators belonging to the user for a given network and asset.
     * @summary List validators belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validators for.
     * @param {ValidatorStatus} [status] A filter to list validators based on a status.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listValidators(networkId: string, assetId: string, status?: ValidatorStatus, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatorList>>;
};
/**
 * StakeApi - factory interface
 * @export
 */
export declare const StakeApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Build a new staking operation
     * @summary Build a new staking operation
     * @param {BuildStakingOperationRequest} buildStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    buildStakingOperation(buildStakingOperationRequest: BuildStakingOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;
    /**
     * Fetch historical staking balances for given address.
     * @summary Fetch historical staking balances
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.
     * @param {string} addressId The onchain address for which the historical staking balances are being fetched.
     * @param {string} startTime The start time of this historical staking balance period.
     * @param {string} endTime The end time of this historical staking balance period.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchHistoricalStakingBalances(networkId: string, assetId: string, addressId: string, startTime: string, endTime: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<FetchHistoricalStakingBalances200Response>;
    /**
     * Fetch staking rewards for a list of addresses
     * @summary Fetch staking rewards
     * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchStakingRewards(fetchStakingRewardsRequest: FetchStakingRewardsRequest, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<FetchStakingRewards200Response>;
    /**
     * Get the latest state of a staking operation
     * @summary Get the latest state of a staking operation
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the staking operation for
     * @param {string} stakingOperationId The ID of the staking operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExternalStakingOperation(networkId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;
    /**
     * Get staking context for an address
     * @summary Get staking context
     * @param {GetStakingContextRequest} getStakingContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStakingContext(getStakingContextRequest: GetStakingContextRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingContext>;
    /**
     * Get a validator belonging to the user for a given network, asset and id.
     * @summary Get a validator belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validator for.
     * @param {string} validatorId The unique id of the validator to fetch details for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getValidator(networkId: string, assetId: string, validatorId: string, options?: RawAxiosRequestConfig): AxiosPromise<Validator>;
    /**
     * List validators belonging to the user for a given network and asset.
     * @summary List validators belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validators for.
     * @param {ValidatorStatus} [status] A filter to list validators based on a status.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listValidators(networkId: string, assetId: string, status?: ValidatorStatus, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ValidatorList>;
};
/**
 * StakeApi - interface
 * @export
 * @interface StakeApi
 */
export interface StakeApiInterface {
    /**
     * Build a new staking operation
     * @summary Build a new staking operation
     * @param {BuildStakingOperationRequest} buildStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    buildStakingOperation(buildStakingOperationRequest: BuildStakingOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;
    /**
     * Fetch historical staking balances for given address.
     * @summary Fetch historical staking balances
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.
     * @param {string} addressId The onchain address for which the historical staking balances are being fetched.
     * @param {string} startTime The start time of this historical staking balance period.
     * @param {string} endTime The end time of this historical staking balance period.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    fetchHistoricalStakingBalances(networkId: string, assetId: string, addressId: string, startTime: string, endTime: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<FetchHistoricalStakingBalances200Response>;
    /**
     * Fetch staking rewards for a list of addresses
     * @summary Fetch staking rewards
     * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    fetchStakingRewards(fetchStakingRewardsRequest: FetchStakingRewardsRequest, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<FetchStakingRewards200Response>;
    /**
     * Get the latest state of a staking operation
     * @summary Get the latest state of a staking operation
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the staking operation for
     * @param {string} stakingOperationId The ID of the staking operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    getExternalStakingOperation(networkId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig): AxiosPromise<StakingOperation>;
    /**
     * Get staking context for an address
     * @summary Get staking context
     * @param {GetStakingContextRequest} getStakingContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    getStakingContext(getStakingContextRequest: GetStakingContextRequest, options?: RawAxiosRequestConfig): AxiosPromise<StakingContext>;
    /**
     * Get a validator belonging to the user for a given network, asset and id.
     * @summary Get a validator belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validator for.
     * @param {string} validatorId The unique id of the validator to fetch details for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    getValidator(networkId: string, assetId: string, validatorId: string, options?: RawAxiosRequestConfig): AxiosPromise<Validator>;
    /**
     * List validators belonging to the user for a given network and asset.
     * @summary List validators belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validators for.
     * @param {ValidatorStatus} [status] A filter to list validators based on a status.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApiInterface
     */
    listValidators(networkId: string, assetId: string, status?: ValidatorStatus, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<ValidatorList>;
}
/**
 * StakeApi - object-oriented interface
 * @export
 * @class StakeApi
 * @extends {BaseAPI}
 */
export declare class StakeApi extends BaseAPI implements StakeApiInterface {
    /**
     * Build a new staking operation
     * @summary Build a new staking operation
     * @param {BuildStakingOperationRequest} buildStakingOperationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    buildStakingOperation(buildStakingOperationRequest: BuildStakingOperationRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<StakingOperation, any>>;
    /**
     * Fetch historical staking balances for given address.
     * @summary Fetch historical staking balances
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.
     * @param {string} addressId The onchain address for which the historical staking balances are being fetched.
     * @param {string} startTime The start time of this historical staking balance period.
     * @param {string} endTime The end time of this historical staking balance period.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    fetchHistoricalStakingBalances(networkId: string, assetId: string, addressId: string, startTime: string, endTime: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<FetchHistoricalStakingBalances200Response, any>>;
    /**
     * Fetch staking rewards for a list of addresses
     * @summary Fetch staking rewards
     * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    fetchStakingRewards(fetchStakingRewardsRequest: FetchStakingRewardsRequest, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<FetchStakingRewards200Response, any>>;
    /**
     * Get the latest state of a staking operation
     * @summary Get the latest state of a staking operation
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the staking operation for
     * @param {string} stakingOperationId The ID of the staking operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    getExternalStakingOperation(networkId: string, addressId: string, stakingOperationId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<StakingOperation, any>>;
    /**
     * Get staking context for an address
     * @summary Get staking context
     * @param {GetStakingContextRequest} getStakingContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    getStakingContext(getStakingContextRequest: GetStakingContextRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<StakingContext, any>>;
    /**
     * Get a validator belonging to the user for a given network, asset and id.
     * @summary Get a validator belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validator for.
     * @param {string} validatorId The unique id of the validator to fetch details for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    getValidator(networkId: string, assetId: string, validatorId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Validator, any>>;
    /**
     * List validators belonging to the user for a given network and asset.
     * @summary List validators belonging to the CDP project
     * @param {string} networkId The ID of the blockchain network.
     * @param {string} assetId The symbol of the asset to get the validators for.
     * @param {ValidatorStatus} [status] A filter to list validators based on a status.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakeApi
     */
    listValidators(networkId: string, assetId: string, status?: ValidatorStatus, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ValidatorList, any>>;
}
/**
 * TradesApi - axios parameter creator
 * @export
 */
export declare const TradesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Broadcast a trade
     * @summary Broadcast a trade
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to broadcast
     * @param {BroadcastTradeRequest} broadcastTradeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastTrade: (walletId: string, addressId: string, tradeId: string, broadcastTradeRequest: BroadcastTradeRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a new trade
     * @summary Create a new trade for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to conduct the trade from
     * @param {CreateTradeRequest} createTradeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTrade: (walletId: string, addressId: string, createTradeRequest: CreateTradeRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a trade by ID
     * @summary Get a trade by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTrade: (walletId: string, addressId: string, tradeId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List trades for an address.
     * @summary List trades for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list trades for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTrades: (walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TradesApi - functional programming interface
 * @export
 */
export declare const TradesApiFp: (configuration?: Configuration) => {
    /**
     * Broadcast a trade
     * @summary Broadcast a trade
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to broadcast
     * @param {BroadcastTradeRequest} broadcastTradeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastTrade(walletId: string, addressId: string, tradeId: string, broadcastTradeRequest: BroadcastTradeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>>;
    /**
     * Create a new trade
     * @summary Create a new trade for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to conduct the trade from
     * @param {CreateTradeRequest} createTradeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTrade(walletId: string, addressId: string, createTradeRequest: CreateTradeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>>;
    /**
     * Get a trade by ID
     * @summary Get a trade by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTrade(walletId: string, addressId: string, tradeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>>;
    /**
     * List trades for an address.
     * @summary List trades for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list trades for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTrades(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradeList>>;
};
/**
 * TradesApi - factory interface
 * @export
 */
export declare const TradesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Broadcast a trade
     * @summary Broadcast a trade
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to broadcast
     * @param {BroadcastTradeRequest} broadcastTradeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastTrade(walletId: string, addressId: string, tradeId: string, broadcastTradeRequest: BroadcastTradeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Trade>;
    /**
     * Create a new trade
     * @summary Create a new trade for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to conduct the trade from
     * @param {CreateTradeRequest} createTradeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTrade(walletId: string, addressId: string, createTradeRequest: CreateTradeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Trade>;
    /**
     * Get a trade by ID
     * @summary Get a trade by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTrade(walletId: string, addressId: string, tradeId: string, options?: RawAxiosRequestConfig): AxiosPromise<Trade>;
    /**
     * List trades for an address.
     * @summary List trades for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list trades for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTrades(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<TradeList>;
};
/**
 * TradesApi - interface
 * @export
 * @interface TradesApi
 */
export interface TradesApiInterface {
    /**
     * Broadcast a trade
     * @summary Broadcast a trade
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to broadcast
     * @param {BroadcastTradeRequest} broadcastTradeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApiInterface
     */
    broadcastTrade(walletId: string, addressId: string, tradeId: string, broadcastTradeRequest: BroadcastTradeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Trade>;
    /**
     * Create a new trade
     * @summary Create a new trade for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to conduct the trade from
     * @param {CreateTradeRequest} createTradeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApiInterface
     */
    createTrade(walletId: string, addressId: string, createTradeRequest: CreateTradeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Trade>;
    /**
     * Get a trade by ID
     * @summary Get a trade by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApiInterface
     */
    getTrade(walletId: string, addressId: string, tradeId: string, options?: RawAxiosRequestConfig): AxiosPromise<Trade>;
    /**
     * List trades for an address.
     * @summary List trades for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list trades for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApiInterface
     */
    listTrades(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<TradeList>;
}
/**
 * TradesApi - object-oriented interface
 * @export
 * @class TradesApi
 * @extends {BaseAPI}
 */
export declare class TradesApi extends BaseAPI implements TradesApiInterface {
    /**
     * Broadcast a trade
     * @summary Broadcast a trade
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to broadcast
     * @param {BroadcastTradeRequest} broadcastTradeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    broadcastTrade(walletId: string, addressId: string, tradeId: string, broadcastTradeRequest: BroadcastTradeRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Trade, any>>;
    /**
     * Create a new trade
     * @summary Create a new trade for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to conduct the trade from
     * @param {CreateTradeRequest} createTradeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    createTrade(walletId: string, addressId: string, createTradeRequest: CreateTradeRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Trade, any>>;
    /**
     * Get a trade by ID
     * @summary Get a trade by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the trade belongs to
     * @param {string} tradeId The ID of the trade to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    getTrade(walletId: string, addressId: string, tradeId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Trade, any>>;
    /**
     * List trades for an address.
     * @summary List trades for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list trades for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    listTrades(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<TradeList, any>>;
}
/**
 * TransactionHistoryApi - axios parameter creator
 * @export
 */
export declare const TransactionHistoryApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * List all transactions that interact with the address.
     * @summary List transactions for an address.
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the transactions for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddressTransactions: (networkId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TransactionHistoryApi - functional programming interface
 * @export
 */
export declare const TransactionHistoryApiFp: (configuration?: Configuration) => {
    /**
     * List all transactions that interact with the address.
     * @summary List transactions for an address.
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the transactions for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddressTransactions(networkId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressTransactionList>>;
};
/**
 * TransactionHistoryApi - factory interface
 * @export
 */
export declare const TransactionHistoryApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * List all transactions that interact with the address.
     * @summary List transactions for an address.
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the transactions for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddressTransactions(networkId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressTransactionList>;
};
/**
 * TransactionHistoryApi - interface
 * @export
 * @interface TransactionHistoryApi
 */
export interface TransactionHistoryApiInterface {
    /**
     * List all transactions that interact with the address.
     * @summary List transactions for an address.
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the transactions for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionHistoryApiInterface
     */
    listAddressTransactions(networkId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressTransactionList>;
}
/**
 * TransactionHistoryApi - object-oriented interface
 * @export
 * @class TransactionHistoryApi
 * @extends {BaseAPI}
 */
export declare class TransactionHistoryApi extends BaseAPI implements TransactionHistoryApiInterface {
    /**
     * List all transactions that interact with the address.
     * @summary List transactions for an address.
     * @param {string} networkId The ID of the blockchain network
     * @param {string} addressId The ID of the address to fetch the transactions for.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionHistoryApi
     */
    listAddressTransactions(networkId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AddressTransactionList, any>>;
}
/**
 * TransfersApi - axios parameter creator
 * @export
 */
export declare const TransfersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Broadcast a transfer
     * @summary Broadcast a transfer
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastTransferRequest} broadcastTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastTransfer: (walletId: string, addressId: string, transferId: string, broadcastTransferRequest: BroadcastTransferRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a new transfer
     * @summary Create a new transfer for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateTransferRequest} createTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransfer: (walletId: string, addressId: string, createTransferRequest: CreateTransferRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a transfer by ID
     * @summary Get a transfer by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransfer: (walletId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List transfers for an address.
     * @summary List transfers for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list transfers for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransfers: (walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TransfersApi - functional programming interface
 * @export
 */
export declare const TransfersApiFp: (configuration?: Configuration) => {
    /**
     * Broadcast a transfer
     * @summary Broadcast a transfer
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastTransferRequest} broadcastTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastTransfer(walletId: string, addressId: string, transferId: string, broadcastTransferRequest: BroadcastTransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>>;
    /**
     * Create a new transfer
     * @summary Create a new transfer for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateTransferRequest} createTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransfer(walletId: string, addressId: string, createTransferRequest: CreateTransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>>;
    /**
     * Get a transfer by ID
     * @summary Get a transfer by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransfer(walletId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>>;
    /**
     * List transfers for an address.
     * @summary List transfers for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list transfers for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransfers(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferList>>;
};
/**
 * TransfersApi - factory interface
 * @export
 */
export declare const TransfersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Broadcast a transfer
     * @summary Broadcast a transfer
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastTransferRequest} broadcastTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    broadcastTransfer(walletId: string, addressId: string, transferId: string, broadcastTransferRequest: BroadcastTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;
    /**
     * Create a new transfer
     * @summary Create a new transfer for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateTransferRequest} createTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransfer(walletId: string, addressId: string, createTransferRequest: CreateTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;
    /**
     * Get a transfer by ID
     * @summary Get a transfer by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransfer(walletId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;
    /**
     * List transfers for an address.
     * @summary List transfers for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list transfers for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTransfers(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<TransferList>;
};
/**
 * TransfersApi - interface
 * @export
 * @interface TransfersApi
 */
export interface TransfersApiInterface {
    /**
     * Broadcast a transfer
     * @summary Broadcast a transfer
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastTransferRequest} broadcastTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApiInterface
     */
    broadcastTransfer(walletId: string, addressId: string, transferId: string, broadcastTransferRequest: BroadcastTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;
    /**
     * Create a new transfer
     * @summary Create a new transfer for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateTransferRequest} createTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApiInterface
     */
    createTransfer(walletId: string, addressId: string, createTransferRequest: CreateTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;
    /**
     * Get a transfer by ID
     * @summary Get a transfer by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApiInterface
     */
    getTransfer(walletId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig): AxiosPromise<Transfer>;
    /**
     * List transfers for an address.
     * @summary List transfers for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list transfers for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApiInterface
     */
    listTransfers(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<TransferList>;
}
/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
export declare class TransfersApi extends BaseAPI implements TransfersApiInterface {
    /**
     * Broadcast a transfer
     * @summary Broadcast a transfer
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to broadcast
     * @param {BroadcastTransferRequest} broadcastTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    broadcastTransfer(walletId: string, addressId: string, transferId: string, broadcastTransferRequest: BroadcastTransferRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Transfer, any>>;
    /**
     * Create a new transfer
     * @summary Create a new transfer for an address
     * @param {string} walletId The ID of the wallet the source address belongs to
     * @param {string} addressId The ID of the address to transfer from
     * @param {CreateTransferRequest} createTransferRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    createTransfer(walletId: string, addressId: string, createTransferRequest: CreateTransferRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Transfer, any>>;
    /**
     * Get a transfer by ID
     * @summary Get a transfer by ID
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address the transfer belongs to
     * @param {string} transferId The ID of the transfer to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    getTransfer(walletId: string, addressId: string, transferId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Transfer, any>>;
    /**
     * List transfers for an address.
     * @summary List transfers for an address.
     * @param {string} walletId The ID of the wallet the address belongs to
     * @param {string} addressId The ID of the address to list transfers for
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    listTransfers(walletId: string, addressId: string, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<TransferList, any>>;
}
/**
 * UsersApi - axios parameter creator
 * @export
 */
export declare const UsersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get current user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * UsersApi - functional programming interface
 * @export
 */
export declare const UsersApiFp: (configuration?: Configuration) => {
    /**
     * Get current user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>>;
};
/**
 * UsersApi - factory interface
 * @export
 */
export declare const UsersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get current user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<User>;
};
/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * Get current user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<User>;
}
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export declare class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * Get current user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getCurrentUser(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<User, any>>;
}
/**
 * WalletsApi - axios parameter creator
 * @export
 */
export declare const WalletsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new wallet scoped to the user.
     * @summary Create a new wallet
     * @param {CreateWalletRequest} [createWalletRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWallet: (createWalletRequest?: CreateWalletRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get wallet
     * @summary Get wallet by ID
     * @param {string} walletId The ID of the wallet to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWallet: (walletId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the aggregated balance of an asset across all of the addresses in the wallet.
     * @summary Get the balance of an asset in the wallet
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWalletBalance: (walletId: string, assetId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List the balances of all of the addresses in the wallet aggregated by asset.
     * @summary List wallet balances
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWalletBalances: (walletId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List wallets belonging to the user.
     * @summary List wallets
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWallets: (limit?: number, page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * WalletsApi - functional programming interface
 * @export
 */
export declare const WalletsApiFp: (configuration?: Configuration) => {
    /**
     * Create a new wallet scoped to the user.
     * @summary Create a new wallet
     * @param {CreateWalletRequest} [createWalletRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWallet(createWalletRequest?: CreateWalletRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Wallet>>;
    /**
     * Get wallet
     * @summary Get wallet by ID
     * @param {string} walletId The ID of the wallet to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWallet(walletId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Wallet>>;
    /**
     * Get the aggregated balance of an asset across all of the addresses in the wallet.
     * @summary Get the balance of an asset in the wallet
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWalletBalance(walletId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance>>;
    /**
     * List the balances of all of the addresses in the wallet aggregated by asset.
     * @summary List wallet balances
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWalletBalances(walletId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressBalanceList>>;
    /**
     * List wallets belonging to the user.
     * @summary List wallets
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWallets(limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletList>>;
};
/**
 * WalletsApi - factory interface
 * @export
 */
export declare const WalletsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a new wallet scoped to the user.
     * @summary Create a new wallet
     * @param {CreateWalletRequest} [createWalletRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWallet(createWalletRequest?: CreateWalletRequest, options?: RawAxiosRequestConfig): AxiosPromise<Wallet>;
    /**
     * Get wallet
     * @summary Get wallet by ID
     * @param {string} walletId The ID of the wallet to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWallet(walletId: string, options?: RawAxiosRequestConfig): AxiosPromise<Wallet>;
    /**
     * Get the aggregated balance of an asset across all of the addresses in the wallet.
     * @summary Get the balance of an asset in the wallet
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWalletBalance(walletId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Balance>;
    /**
     * List the balances of all of the addresses in the wallet aggregated by asset.
     * @summary List wallet balances
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWalletBalances(walletId: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressBalanceList>;
    /**
     * List wallets belonging to the user.
     * @summary List wallets
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWallets(limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<WalletList>;
};
/**
 * WalletsApi - interface
 * @export
 * @interface WalletsApi
 */
export interface WalletsApiInterface {
    /**
     * Create a new wallet scoped to the user.
     * @summary Create a new wallet
     * @param {CreateWalletRequest} [createWalletRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApiInterface
     */
    createWallet(createWalletRequest?: CreateWalletRequest, options?: RawAxiosRequestConfig): AxiosPromise<Wallet>;
    /**
     * Get wallet
     * @summary Get wallet by ID
     * @param {string} walletId The ID of the wallet to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApiInterface
     */
    getWallet(walletId: string, options?: RawAxiosRequestConfig): AxiosPromise<Wallet>;
    /**
     * Get the aggregated balance of an asset across all of the addresses in the wallet.
     * @summary Get the balance of an asset in the wallet
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApiInterface
     */
    getWalletBalance(walletId: string, assetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Balance>;
    /**
     * List the balances of all of the addresses in the wallet aggregated by asset.
     * @summary List wallet balances
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApiInterface
     */
    listWalletBalances(walletId: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressBalanceList>;
    /**
     * List wallets belonging to the user.
     * @summary List wallets
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApiInterface
     */
    listWallets(limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<WalletList>;
}
/**
 * WalletsApi - object-oriented interface
 * @export
 * @class WalletsApi
 * @extends {BaseAPI}
 */
export declare class WalletsApi extends BaseAPI implements WalletsApiInterface {
    /**
     * Create a new wallet scoped to the user.
     * @summary Create a new wallet
     * @param {CreateWalletRequest} [createWalletRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    createWallet(createWalletRequest?: CreateWalletRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Wallet, any>>;
    /**
     * Get wallet
     * @summary Get wallet by ID
     * @param {string} walletId The ID of the wallet to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    getWallet(walletId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Wallet, any>>;
    /**
     * Get the aggregated balance of an asset across all of the addresses in the wallet.
     * @summary Get the balance of an asset in the wallet
     * @param {string} walletId The ID of the wallet to fetch the balance for
     * @param {string} assetId The symbol of the asset to fetch the balance for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    getWalletBalance(walletId: string, assetId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Balance, any>>;
    /**
     * List the balances of all of the addresses in the wallet aggregated by asset.
     * @summary List wallet balances
     * @param {string} walletId The ID of the wallet to fetch the balances for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    listWalletBalances(walletId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<AddressBalanceList, any>>;
    /**
     * List wallets belonging to the user.
     * @summary List wallets
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletsApi
     */
    listWallets(limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<WalletList, any>>;
}
/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export declare const WebhooksApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new webhook scoped to a wallet
     * @summary Create a new webhook scoped to a wallet
     * @param {string} walletId The ID of the wallet to create the webhook for.
     * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWalletWebhook: (walletId: string, createWalletWebhookRequest?: CreateWalletWebhookRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a new webhook
     * @summary Create a new webhook
     * @param {CreateWebhookRequest} [createWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook: (createWebhookRequest?: CreateWebhookRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete a webhook
     * @summary Delete a webhook
     * @param {string} webhookId The Webhook uuid that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook: (webhookId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List webhooks, optionally filtered by event type.
     * @summary List webhooks
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhooks: (limit?: number, page?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update a webhook
     * @summary Update a webhook
     * @param {string} webhookId The Webhook id that needs to be updated
     * @param {UpdateWebhookRequest} [updateWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhook: (webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * WebhooksApi - functional programming interface
 * @export
 */
export declare const WebhooksApiFp: (configuration?: Configuration) => {
    /**
     * Create a new webhook scoped to a wallet
     * @summary Create a new webhook scoped to a wallet
     * @param {string} walletId The ID of the wallet to create the webhook for.
     * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWalletWebhook(walletId: string, createWalletWebhookRequest?: CreateWalletWebhookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>>;
    /**
     * Create a new webhook
     * @summary Create a new webhook
     * @param {CreateWebhookRequest} [createWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook(createWebhookRequest?: CreateWebhookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>>;
    /**
     * Delete a webhook
     * @summary Delete a webhook
     * @param {string} webhookId The Webhook uuid that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * List webhooks, optionally filtered by event type.
     * @summary List webhooks
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhooks(limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookList>>;
    /**
     * Update a webhook
     * @summary Update a webhook
     * @param {string} webhookId The Webhook id that needs to be updated
     * @param {UpdateWebhookRequest} [updateWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhook(webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>>;
};
/**
 * WebhooksApi - factory interface
 * @export
 */
export declare const WebhooksApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a new webhook scoped to a wallet
     * @summary Create a new webhook scoped to a wallet
     * @param {string} walletId The ID of the wallet to create the webhook for.
     * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWalletWebhook(walletId: string, createWalletWebhookRequest?: CreateWalletWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook>;
    /**
     * Create a new webhook
     * @summary Create a new webhook
     * @param {CreateWebhookRequest} [createWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook(createWebhookRequest?: CreateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook>;
    /**
     * Delete a webhook
     * @summary Delete a webhook
     * @param {string} webhookId The Webhook uuid that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     * List webhooks, optionally filtered by event type.
     * @summary List webhooks
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhooks(limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookList>;
    /**
     * Update a webhook
     * @summary Update a webhook
     * @param {string} webhookId The Webhook id that needs to be updated
     * @param {UpdateWebhookRequest} [updateWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhook(webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook>;
};
/**
 * WebhooksApi - interface
 * @export
 * @interface WebhooksApi
 */
export interface WebhooksApiInterface {
    /**
     * Create a new webhook scoped to a wallet
     * @summary Create a new webhook scoped to a wallet
     * @param {string} walletId The ID of the wallet to create the webhook for.
     * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    createWalletWebhook(walletId: string, createWalletWebhookRequest?: CreateWalletWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook>;
    /**
     * Create a new webhook
     * @summary Create a new webhook
     * @param {CreateWebhookRequest} [createWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    createWebhook(createWebhookRequest?: CreateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook>;
    /**
     * Delete a webhook
     * @summary Delete a webhook
     * @param {string} webhookId The Webhook uuid that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     * List webhooks, optionally filtered by event type.
     * @summary List webhooks
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    listWebhooks(limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookList>;
    /**
     * Update a webhook
     * @summary Update a webhook
     * @param {string} webhookId The Webhook id that needs to be updated
     * @param {UpdateWebhookRequest} [updateWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    updateWebhook(webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<Webhook>;
}
/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export declare class WebhooksApi extends BaseAPI implements WebhooksApiInterface {
    /**
     * Create a new webhook scoped to a wallet
     * @summary Create a new webhook scoped to a wallet
     * @param {string} walletId The ID of the wallet to create the webhook for.
     * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    createWalletWebhook(walletId: string, createWalletWebhookRequest?: CreateWalletWebhookRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Webhook, any>>;
    /**
     * Create a new webhook
     * @summary Create a new webhook
     * @param {CreateWebhookRequest} [createWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    createWebhook(createWebhookRequest?: CreateWebhookRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Webhook, any>>;
    /**
     * Delete a webhook
     * @summary Delete a webhook
     * @param {string} webhookId The Webhook uuid that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * List webhooks, optionally filtered by event type.
     * @summary List webhooks
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    listWebhooks(limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<WebhookList, any>>;
    /**
     * Update a webhook
     * @summary Update a webhook
     * @param {string} webhookId The Webhook id that needs to be updated
     * @param {UpdateWebhookRequest} [updateWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    updateWebhook(webhookId: string, updateWebhookRequest?: UpdateWebhookRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Webhook, any>>;
}
