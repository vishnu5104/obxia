"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const coinbase_1 = require("../coinbase/coinbase");
const index_1 = require("../index");
const utils_1 = require("./utils");
const decimal_js_1 = __importDefault(require("decimal.js"));
const crypto_1 = require("crypto");
describe("Address", () => {
    const newAddress = (0, utils_1.newAddressModel)("", (0, crypto_1.randomUUID)(), coinbase_1.Coinbase.networks.EthereumHolesky);
    const address = new index_1.Address(newAddress.network_id, newAddress.address_id);
    describe(".getNetworkId", () => {
        it("should get the network ID", () => {
            const address = new index_1.Address(utils_1.VALID_ADDRESS_MODEL.network_id, utils_1.VALID_ADDRESS_MODEL.address_id);
            expect(address.getNetworkId()).toEqual(utils_1.VALID_ADDRESS_MODEL.network_id);
        });
    });
    describe(".geId", () => {
        it("should get the network ID", () => {
            const address = new index_1.Address(utils_1.VALID_ADDRESS_MODEL.network_id, utils_1.VALID_ADDRESS_MODEL.address_id);
            expect(address.getId()).toEqual(utils_1.VALID_ADDRESS_MODEL.address_id);
        });
    });
    describe(".toString()", () => {
        it("should get the network ID", () => {
            const address = new index_1.Address(utils_1.VALID_ADDRESS_MODEL.network_id, utils_1.VALID_ADDRESS_MODEL.address_id);
            expect(address.toString()).toEqual(`Address { addressId: '${utils_1.VALID_ADDRESS_MODEL.address_id}', networkId: '${utils_1.VALID_ADDRESS_MODEL.network_id}' }`);
        });
    });
    describe("#listTransactions", () => {
        beforeEach(() => {
            const mockTransactionsResponse = {
                data: [
                    {
                        network_id: "base-sepolia",
                        from_address_id: "from_address",
                        block_hash: "0x0dadd465fb063ceb78babbb30abbc6bfc0730d0c57a53e8f6dc778dafcea568f",
                        block_height: "12345",
                        unsigned_payload: "",
                        status: index_1.TransactionStatus.COMPLETE,
                    },
                    {
                        network_id: "base-sepolia",
                        from_address_id: "from_address_1",
                        block_hash: "block_hash",
                        block_height: "12348",
                        unsigned_payload: "",
                        status: index_1.TransactionStatus.FAILED,
                    },
                ],
                has_more: true,
                next_page: "pageToken",
            };
            coinbase_1.Coinbase.apiClients.transactionHistory = utils_1.transactionHistoryApiMock;
            coinbase_1.Coinbase.apiClients.transactionHistory.listAddressTransactions =
                (0, utils_1.mockReturnValue)(mockTransactionsResponse);
        });
        it("should return results with param", async () => {
            const paginationResponse = await address.listTransactions({ limit: 2, page: "page" });
            const transactions = paginationResponse.data;
            expect(transactions.length).toEqual(2);
            expect(transactions[0].blockHeight()).toEqual("12345");
            expect(coinbase_1.Coinbase.apiClients.transactionHistory.listAddressTransactions).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.transactionHistory.listAddressTransactions).toHaveBeenCalledWith(address.getNetworkId(), address.getId(), 2, "page");
            expect(paginationResponse.nextPage).toEqual("pageToken");
        });
        it("should return results without param", async () => {
            coinbase_1.Coinbase.apiClients.transactionHistory.listAddressTransactions = (0, utils_1.mockReturnValue)({
                data: [
                    {
                        network_id: "base-sepolia",
                        from_address_id: "from_address_1",
                        block_hash: "block_hash",
                        block_height: "12348",
                        unsigned_payload: "",
                        status: index_1.TransactionStatus.COMPLETE,
                    },
                ],
                has_more: false,
                next_page: "",
            });
            const paginationResponse = await address.listTransactions();
            const transactions = paginationResponse.data;
            expect(transactions.length).toEqual(1);
            expect(transactions[0].blockHeight()).toEqual("12348");
            expect(coinbase_1.Coinbase.apiClients.transactionHistory.listAddressTransactions).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.transactionHistory.listAddressTransactions).toHaveBeenCalledWith(address.getNetworkId(), address.getId(), coinbase_1.Coinbase.defaultPageLimit, undefined);
            expect(paginationResponse.nextPage).toBe(undefined);
        });
        it("should return empty if no transactions found", async () => {
            coinbase_1.Coinbase.apiClients.transactionHistory.listAddressTransactions = (0, utils_1.mockReturnValue)({
                data: [],
                has_more: false,
                next_page: "",
            });
            const paginationResponse = await address.listTransactions();
            const transactions = paginationResponse.data;
            expect(transactions.length).toEqual(0);
            expect(coinbase_1.Coinbase.apiClients.transactionHistory.listAddressTransactions).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.transactionHistory.listAddressTransactions).toHaveBeenCalledWith(address.getNetworkId(), address.getId(), coinbase_1.Coinbase.defaultPageLimit, undefined);
            expect(paginationResponse.nextPage).toBe(undefined);
        });
    });
    describe(".listHistoricalBalance", () => {
        beforeEach(() => {
            const mockHistoricalBalanceResponse = {
                data: [
                    {
                        amount: "1000000",
                        block_hash: "0x0dadd465fb063ceb78babbb30abbc6bfc0730d0c57a53e8f6dc778dafcea568f",
                        block_height: "12345",
                        asset: {
                            asset_id: "usdc",
                            network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                            decimals: 6,
                        },
                    },
                    {
                        amount: "5000000",
                        block_hash: "0x5c05a37dcb4910b22a775fc9480f8422d9d615ad7a6a0aa9d8778ff8cc300986",
                        block_height: "67890",
                        asset: {
                            asset_id: "usdc",
                            network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                            decimals: 6,
                        },
                    },
                ],
                has_more: false,
                next_page: "",
            };
            coinbase_1.Coinbase.apiClients.balanceHistory = utils_1.balanceHistoryApiMock;
            coinbase_1.Coinbase.apiClients.balanceHistory.listAddressHistoricalBalance = (0, utils_1.mockReturnValue)(mockHistoricalBalanceResponse);
        });
        it("should return results with USDC historical balance with limit", async () => {
            const paginationResponse = await address.listHistoricalBalances(coinbase_1.Coinbase.assets.Usdc);
            const historicalBalances = paginationResponse.data;
            expect(historicalBalances.length).toEqual(2);
            expect(historicalBalances[0].amount).toEqual(new decimal_js_1.default(1));
            expect(historicalBalances[1].amount).toEqual(new decimal_js_1.default(5));
            expect(coinbase_1.Coinbase.apiClients.balanceHistory.listAddressHistoricalBalance).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.balanceHistory.listAddressHistoricalBalance).toHaveBeenCalledWith(address.getNetworkId(), address.getId(), coinbase_1.Coinbase.assets.Usdc, 100, undefined);
            expect(paginationResponse.nextPage).toBe(undefined);
        });
        it("should return results with USDC historical balance with page", async () => {
            const paginationResponse = await address.listHistoricalBalances(coinbase_1.Coinbase.assets.Usdc, {
                page: "page_token",
            });
            const historicalBalances = paginationResponse.data;
            expect(historicalBalances.length).toEqual(2);
            expect(historicalBalances[0].amount).toEqual(new decimal_js_1.default(1));
            expect(historicalBalances[1].amount).toEqual(new decimal_js_1.default(5));
            expect(coinbase_1.Coinbase.apiClients.balanceHistory.listAddressHistoricalBalance).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.balanceHistory.listAddressHistoricalBalance).toHaveBeenCalledWith(address.getNetworkId(), address.getId(), coinbase_1.Coinbase.assets.Usdc, coinbase_1.Coinbase.defaultPageLimit, "page_token");
            expect(paginationResponse.nextPage).toBe(undefined);
        });
        it("should return empty if no historical balance found", async () => {
            coinbase_1.Coinbase.apiClients.balanceHistory.listAddressHistoricalBalance = (0, utils_1.mockReturnValue)({
                data: [],
                has_more: false,
                next_page: "",
            });
            const paginationResponse = await address.listHistoricalBalances(coinbase_1.Coinbase.assets.Usdc);
            const historicalBalances = paginationResponse.data;
            expect(historicalBalances.length).toEqual(0);
            expect(coinbase_1.Coinbase.apiClients.balanceHistory.listAddressHistoricalBalance).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.balanceHistory.listAddressHistoricalBalance).toHaveBeenCalledWith(address.getNetworkId(), address.getId(), coinbase_1.Coinbase.assets.Usdc, 100, undefined);
            expect(paginationResponse.nextPage).toBe(undefined);
        });
        it("should return results with USDC historical balance and next page", async () => {
            coinbase_1.Coinbase.apiClients.balanceHistory.listAddressHistoricalBalance = (0, utils_1.mockReturnValue)({
                data: [
                    {
                        amount: "5000000",
                        block_hash: "0x5c05a37dcb4910b22a775fc9480f8422d9d615ad7a6a0aa9d8778ff8cc300986",
                        block_height: "67890",
                        asset: {
                            asset_id: "usdc",
                            network_id: coinbase_1.Coinbase.networks.EthereumHolesky,
                            decimals: 6,
                        },
                    },
                ],
                has_more: true,
                next_page: "next page",
            });
            const paginationResponse = await address.listHistoricalBalances(coinbase_1.Coinbase.assets.Usdc, {
                limit: 1,
            });
            const historicalBalances = paginationResponse.data;
            expect(historicalBalances.length).toEqual(1);
            expect(historicalBalances[0].amount).toEqual(new decimal_js_1.default(5));
            expect(coinbase_1.Coinbase.apiClients.balanceHistory.listAddressHistoricalBalance).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.balanceHistory.listAddressHistoricalBalance).toHaveBeenCalledWith(address.getNetworkId(), address.getId(), coinbase_1.Coinbase.assets.Usdc, 1, undefined);
            expect(paginationResponse.nextPage).toEqual("next page");
        });
    });
    describe("#reputation", () => {
        beforeEach(() => {
            const mockReputationResponse = {
                score: 90,
                metadata: {
                    activity_period_days: 1,
                    bridge_transactions_performed: 1,
                    current_active_streak: 1,
                    ens_contract_interactions: 2,
                    lend_borrow_stake_transactions: 3,
                    longest_active_streak: 4,
                    smart_contract_deployments: 5,
                    token_swaps_performed: 6,
                    total_transactions: 7,
                    unique_days_active: 8,
                },
            };
            coinbase_1.Coinbase.apiClients.addressReputation = utils_1.reputationApiMock;
            coinbase_1.Coinbase.apiClients.addressReputation.getAddressReputation =
                (0, utils_1.mockReturnValue)(mockReputationResponse);
        });
        it("should return address reputation", async () => {
            const reputation = await address.reputation();
            expect(reputation.score).toEqual(90);
            expect(reputation.metadata).toEqual({
                activity_period_days: 1,
                bridge_transactions_performed: 1,
                current_active_streak: 1,
                ens_contract_interactions: 2,
                lend_borrow_stake_transactions: 3,
                longest_active_streak: 4,
                smart_contract_deployments: 5,
                token_swaps_performed: 6,
                total_transactions: 7,
                unique_days_active: 8,
            });
            expect(coinbase_1.Coinbase.apiClients.addressReputation.getAddressReputation).toHaveBeenCalledTimes(1);
            expect(coinbase_1.Coinbase.apiClients.addressReputation.getAddressReputation).toHaveBeenCalledWith(address.getNetworkId(), address.getId());
        });
    });
});
