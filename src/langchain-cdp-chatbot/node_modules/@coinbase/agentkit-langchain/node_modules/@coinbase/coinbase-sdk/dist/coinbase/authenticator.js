"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoinbaseAuthenticator = void 0;
const node_jose_1 = require("node-jose");
const errors_1 = require("./errors");
const package_json_1 = require("../../package.json");
const pemHeader = "-----BEGIN EC PRIVATE KEY-----";
const pemFooter = "-----END EC PRIVATE KEY-----";
/**
 * A class that builds JWTs for authenticating with the Coinbase Platform APIs.
 */
class CoinbaseAuthenticator {
    /**
     * Initializes the Authenticator.
     *
     * @param {string} apiKey - The API key name.
     * @param {string} privateKey - The private key associated with the API key.
     * @param {string} source - The source of the request.
     * @param {string} sourceVersion - The version of the source.
     */
    constructor(apiKey, privateKey, source, sourceVersion) {
        this.apiKey = apiKey;
        this.privateKey = privateKey;
        this.source = source;
        this.sourceVersion = sourceVersion;
    }
    /**
     * Middleware to intercept requests and add JWT to Authorization header.
     *
     * @param {InternalAxiosRequestConfig} config - The request configuration.
     * @param {boolean} debugging - Flag to enable debugging.
     * @returns {Promise<InternalAxiosRequestConfig>} The request configuration with the Authorization header added.
     * @throws {InvalidAPIKeyFormat} If JWT could not be built.
     */
    async authenticateRequest(config, debugging = false) {
        const method = config.method?.toString().toUpperCase();
        const token = await this.buildJWT(config.url || "", method);
        if (debugging) {
            console.log(`API REQUEST: ${method} ${config.url}`);
        }
        config.headers["Authorization"] = `Bearer ${token}`;
        config.headers["Content-Type"] = "application/json";
        config.headers["Correlation-Context"] = this.getCorrelationData();
        return config;
    }
    /**
     * Builds the JWT for the given API endpoint URL.
     *
     * @param {string} url - URL of the API endpoint.
     * @param {string} method - HTTP method of the request.
     * @returns {Promise<string>} JWT token.
     * @throws {InvalidAPIKeyFormat} If the private key is not in the correct format.
     */
    async buildJWT(url, method = "GET") {
        const pemPrivateKey = this.extractPemKey(this.privateKey);
        let privateKey;
        try {
            privateKey = await node_jose_1.JWK.asKey(pemPrivateKey, "pem");
            if (privateKey.kty !== "EC") {
                throw new errors_1.InvalidAPIKeyFormatError("Invalid key type");
            }
        }
        catch (error) {
            throw new errors_1.InvalidAPIKeyFormatError("Could not parse the private key");
        }
        const header = {
            alg: "ES256",
            kid: this.apiKey,
            typ: "JWT",
            nonce: this.nonce(),
        };
        const urlObject = new URL(url);
        const uri = `${method} ${urlObject.host}${urlObject.pathname}`;
        const claims = {
            sub: this.apiKey,
            iss: "cdp",
            aud: ["cdp_service"],
            nbf: Math.floor(Date.now() / 1000),
            exp: Math.floor(Date.now() / 1000) + 60, // +1 minute
            uris: [uri],
        };
        const payload = Buffer.from(JSON.stringify(claims)).toString("utf8");
        try {
            const result = await node_jose_1.JWS.createSign({ format: "compact", fields: header }, privateKey)
                .update(payload)
                .final();
            return result;
        }
        catch (err) {
            throw new errors_1.InvalidAPIKeyFormatError("Could not sign the JWT");
        }
    }
    /**
     * Extracts the PEM key from the given private key string.
     *
     * @param {string} privateKeyString - The private key string.
     * @returns {string} The PEM key.
     * @throws {InvalidAPIKeyFormat} If the private key string is not in the correct format.
     */
    extractPemKey(privateKeyString) {
        privateKeyString = privateKeyString.replace(/\n/g, "");
        if (privateKeyString.startsWith(pemHeader) && privateKeyString.endsWith(pemFooter)) {
            return privateKeyString;
        }
        throw new errors_1.InvalidAPIKeyFormatError("Invalid private key format");
    }
    /**
     * Generates a random nonce for the JWT.
     *
     * @returns {string} The generated nonce.
     */
    nonce() {
        const range = "0123456789";
        let result = "";
        for (let i = 0; i < 16; i++) {
            result += range.charAt(Math.floor(Math.random() * range.length));
        }
        return result;
    }
    /**
     * Returns encoded correlation data including the SDK version and language.
     *
     * @returns {string} Encoded correlation data.
     */
    getCorrelationData() {
        const data = {
            sdk_version: package_json_1.version,
            sdk_language: "typescript",
            source: this.source,
        };
        if (this.sourceVersion) {
            data["source_version"] = this.sourceVersion;
        }
        return Object.keys(data)
            .map(key => `${key}=${encodeURIComponent(data[key])}`)
            .join(",");
    }
}
exports.CoinbaseAuthenticator = CoinbaseAuthenticator;
